C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE MISC
OBJECT MODULE PLACED IN .\Output\Misc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Scaler\Code\Misc.c OPTIMIZE(9,SPEED) DEFINE(_PROJECT=_RTD2472D_DEMO_BOARD) 
                    -PRINT(.\Output\Misc.lst) OBJECT(.\Output\Misc.obj)

line level    source

   1          /********************************************************************************/
   2          /*   The  Software  is  proprietary,  confidential,  and  valuable to Realtek   */
   3          /*   Semiconductor  Corporation  ("Realtek").  All  rights, including but not   */
   4          /*   limited  to  copyrights,  patents,  trademarks, trade secrets, mask work   */
   5          /*   rights, and other similar rights and interests, are reserved to Realtek.   */
   6          /*   Without  prior  written  consent  from  Realtek,  copying, reproduction,   */
   7          /*   modification,  distribution,  or  otherwise  is strictly prohibited. The   */
   8          /*   Software  shall  be  kept  strictly  in  confidence,  and  shall  not be   */
   9          /*   disclosed to or otherwise accessed by any third party.                     */
  10          /*   c<2003> - <2010>                                                           */
  11          /*   The Software is provided "AS IS" without any warranty of any kind,         */
  12          /*   express, implied, statutory or otherwise.                                  */
  13          /********************************************************************************/
  14          
  15          //----------------------------------------------------------------------------------------------------
  16          // ID Code      : Misc.c No.0000
  17          // Update Note  :
  18          //----------------------------------------------------------------------------------------------------
  19          
  20          #define __MISC__
  21          
  22          #include "Common\Header\Include.h"
  23          
  24          #if(_SCALER_SERIES_TYPE == _RTD2472D_SERIES)
  25          
  26          //----------------------------------------------------------------------------------------------------
  27          // Polling Events
  28          //----------------------------------------------------------------------------------------------------
  29          
  30          //--------------------------------------------------
  31          // Description  : Stable flag polling event
  32          // Input Value  : None
  33          // Output Value : Return _TRUE if event occurs
  34          //--------------------------------------------------
  35          bit CMiscStableFlagPollingEvent(void)
  36          {
  37   1          if((bit)CScalerGetBit(_STABLE_MEASURE_4F, _BIT7))
  38   1          {
  39   2              return _TRUE;
  40   2          }
  41   1          else
  42   1          {
  43   2              return _FALSE;
  44   2          }
  45   1      }
  46          
  47          // V012 Modify 20100329 Start
  48          // V012 Patch Note (19) : Adjust polling time of Auto Run Typer according to different Crystal frequency.
  49          /*
  50          #if(_HSYNC_DETECTION == _AUTO_RUN)
  51          //--------------------------------------------------
  52          // Description  : Hsync Type Detection Auto Run flag polling event
  53          // Input Value  : None
  54          // Output Value : Return _TRUE if event occurs
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 2   

  55          //--------------------------------------------------
  56          bit CMiscHsyncTypeAutoRunFlagPollingEvent(void)
  57          {
  58              if((bit)CScalerGetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, _BIT7))
  59              {
  60                 return _TRUE;
  61              }
  62              else
  63              {
  64                  return _FALSE;
  65              }
  66          }
  67          #endif
  68          */
  69          // V012 Modify 20100329 End
  70          
  71          //--------------------------------------------------
  72          // Description  : Measure start/end polling event
  73          // Input Value  : None
  74          // Output Value : Return _TRUE if measure finished
  75          //--------------------------------------------------
  76          bit CMiscModeMeasurePollingEvent(void)
  77          {
  78   1          if((bit)CScalerGetBit(_MEAS_HS_PERIOD_H_52, _BIT7))
  79   1          {
  80   2              if(!(bit)CScalerGetBit(_STABLE_PERIOD_H_50, _BIT7))
  81   2              {
  82   3                  return _TRUE;
  83   3              }
  84   2              else
  85   2              {
  86   3                  return _FALSE;
  87   3              }
  88   2          }
  89   1          else
  90   1          {
  91   2              if(!(bit)CScalerGetBit(_MEAS_HS_PERIOD_H_52, _BIT5))
  92   2              {
  93   3                  return _TRUE;
  94   3              }
  95   2              else
  96   2              {
  97   3                  return _FALSE;
  98   3              }
  99   2          }
 100   1      }
 101          
 102          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
 103          //--------------------------------------------------
 104          // Description  : Auto measure start/end polling event
 105          // Input Value  : None
 106          // Output Value : Return _TRUE if auto measure finished
 107          //--------------------------------------------------
 108          bit CMiscAutoMeasurePollingEvent(void)
 109          {
 110   1          if(!(bit)CScalerGetBit(_AUTO_ADJ_CTRL1_7D, _BIT0))
 111   1          {
 112   2              return _TRUE;
 113   2          }
 114   1          else
 115   1          {
 116   2              return _FALSE;
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 3   

 117   2          }
 118   1      }
 119          #endif
 120          
 121          //--------------------------------------------------
 122          // Description  : Apply double buffer polling event
 123          // Input Value  : None
 124          // Output Value : Return _TRUE if apply double buffer finished
 125          //--------------------------------------------------
 126          bit CMiscApplyDoubleBufferPollingEvent(void)
 127          {
 128   1          if(!(bit)CScalerGetBit(_VGIP_CTRL_10, _BIT5))
 129   1          {
 130   2              return _TRUE;
 131   2          }
 132   1          else
 133   1          {
 134   2              return _FALSE;
 135   2          }
 136   1      }
 137          
 138          //--------------------------------------------------
 139          // Description  : DVS start polling event
 140          // Input Value  : None
 141          // Output Value : Return _TRUE if event occurs
 142          //--------------------------------------------------
 143          bit CMiscDVSStartPollingEvent(void)
 144          {
 145   1          if((bit)CScalerGetBit(_STATUS1_03, _BIT3))
 146   1          {
 147   2              return _TRUE;
 148   2          }
 149   1          else
 150   1          {
 151   2              return _FALSE;
 152   2          }
 153   1      }
 154          
 155          //--------------------------------------------------
 156          // Description  : Check State to Active state
 157          // Input Value  : None
 158          // Output Value : None
 159          //--------------------------------------------------
 160          void CMiscCheckToActiveEvent(void)
 161          {
 162   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
 163   1          {
 164   2              ucCurrState = _ACTIVE_STATE;
 165   2          }
 166   1          else
 167   1          {
 168   2      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2472D))
 169   2              if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) 
             -== _D1_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D
             -1_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_DV
             -I_I_PORT))
 170   2              {
 171   3                  if(CSyncCheckTMDSFreq() == _FALSE)
 172   3                  {
 173   4                      CModeResetMode();
 174   4                      return;
 175   4                  }
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 4   

 176   3      
 177   3                  if((GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
 178   3                  {
 179   4                      CScalerPageSelect(_PAGE2);
 180   4                      CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT3, _BIT3);
 181   4                      CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT1, 0x00);
 182   4                      CTimerDelayXms(5);
 183   4                      CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x02);
 184   4                      CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[0], _NON_AUTOINC);
 185   4      
 186   4                      if((pData[0] & 0x02) == 0x02)
 187   4                      {
 188   5                          CModeResetMode();
 189   5                          return;
 190   5                      }
 191   4                  }
 192   3              }
 193   2      #endif
 194   2      
 195   2              ucCurrState = _ACTIVE_STATE;
 196   2      
 197   2              // V016 System Patch Note (15) Modify 20100824 Start
 198   2              // Patch Reason : Fix IHCount=0 issue
 199   2              CModeAutoMeasureOn();
 200   2              CTimerPollingEventProc(120, CMiscModeMeasurePollingEvent);
 201   2              // V016 System Patch Note (15) Modify 20100824 End
 202   2      
 203   2          }
 204   1      }
 205          
 206          
 207          //----------------------------------------------------------------------------------------------------
 208          // Misc Functions
 209          //----------------------------------------------------------------------------------------------------
 210          
 211          //--------------------------------------------------
 212          // Description  : Enable double buffer
 213          // Input Value  : None
 214          // Output Value : None
 215          //--------------------------------------------------
 216          void CMiscEnableDoubleBuffer(void)
 217          {
 218   1          CScalerSetBit(_VGIP_CTRL_10, ~_BIT4, _BIT4);
 219   1      }
 220          
 221          //--------------------------------------------------
 222          // Description  : Disable double buffer
 223          // Input Value  : None
 224          // Output Value : None
 225          //--------------------------------------------------
 226          void CMiscDisableDoubleBuffer(void)
 227          {
 228   1          CScalerSetBit(_VGIP_CTRL_10, ~_BIT4, 0x00);
 229   1      }
 230          
 231          //--------------------------------------------------
 232          // Description  : Apply double buffer
 233          // Input Value  : None
 234          // Output Value : None
 235          //--------------------------------------------------
 236          void CMiscApplyDoubleBuffer(void)
 237          {
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 5   

 238   1          if((bit)CScalerGetBit(_VGIP_CTRL_10, _BIT4))
 239   1          {
 240   2              CScalerSetBit(_VGIP_CTRL_10, ~_BIT5, _BIT5);
 241   2              CTimerPollingEventProc(60, CMiscApplyDoubleBufferPollingEvent);
 242   2          }
 243   1      }
 244          
 245          //--------------------------------------------------
 246          // Description  : Clear status Reg[02] and Reg[03]
 247          // Input Value  : None
 248          // Output Value : None
 249          //--------------------------------------------------
 250          void CMiscClearStatusRegister(void)
 251          {
 252   1          CScalerSetByte(_STATUS0_02, 0x00);
 253   1          CScalerSetByte(_STATUS1_03, 0x00);
 254   1      }
 255          
 256          //--------------------------------------------------
 257          // Description  : Set pin share
 258          // Input Value  : None
 259          // Output Value : None
 260          //--------------------------------------------------
 261          void CMiscSetPinShare(void)
 262          {
 263   1          // V016 System Patch Note (17) Modify 20100825 Start
 264   1          // Patch Reason : Select CR[1F]-bit5:4 to Pin Share Part.
 265   1          if(CScalerGetBit(_V8_YUV_CONVERSION_1F, _BIT5 | _BIT4) != 0x10)
 266   1          {
 267   2              CScalerSetBit(_V8_YUV_CONVERSION_1F, ~(_BIT5 | _BIT4), _BIT5);
 268   2          }
 269   1          // V016 System Patch Note (17) Modify 20100825 End
 270   1      
 271   1      #if(_SCALER_TYPE == _RTD2472D)
 272   1      #if(_MCU_TYPE == _REALTEK_EMBEDDED)
 273   1      
 274   1          MCU_PIN_SHARE_CTRL00_FF94 = (((BYTE)_PIN_41 << 6) | (_PIN_42 << 4) | (_PIN_43 << 2) | (_PIN_54));
 275   1          MCU_PIN_SHARE_CTRL01_FF95 = (((BYTE)_PIN_45 << 6) | (_PIN_119 << 3) | (_PIN_126));
 276   1          MCU_PIN_SHARE_CTRL02_FF96 = (((BYTE)_PIN_58_59_DDC1_ENABLE << 7) | (_PIN_58 << 4) | (_PIN_59 << 1));
 277   1          MCU_PIN_SHARE_CTRL03_FF97 = (((BYTE)_PIN_46 << 6) | (_PIN_51 << 4) | (_PIN_64));
 278   1          MCU_PIN_SHARE_CTRL04_FF98 = (((BYTE)_PIN_52 << 6) | (_PIN_66 << 3) | (_PIN_67));
 279   1          MCU_PIN_SHARE_CTRL05_FF99 = (((BYTE)_PIN_53 << 6) | (_PIN_69 << 3) | (_PIN_70));
 280   1          MCU_PIN_SHARE_CTRL06_FF9A = (((BYTE)_PIN_47 << 6) | (_PIN_55 << 3) | (_PIN_63));
 281   1          MCU_PIN_SHARE_CTRL07_FF9B = (((BYTE)_PIN_48 << 6) | (_PIN_68 << 3) | (_PIN_71));
 282   1          MCU_PIN_SHARE_CTRL08_FF9C = (((BYTE)_PIN_44 << 5) | (_PIN_96 << 3) | (_PIN_97));
 283   1          MCU_PIN_SHARE_CTRL09_FF9D = (((BYTE)_PIN_74to83 << 6) | (_PIN_99 << 3) | (_PIN_100));
 284   1          MCU_PIN_SHARE_CTRL0A_FF9E = (((BYTE)_PIN_98 << 6) | (_PIN_102 << 3) | (_PIN_105));
 285   1          MCU_PIN_SHARE_CTRL0B_FF9F = (((BYTE)_PIN_50 << 5) | (_PIN_101 << 3) | (_PIN_108));
 286   1          MCU_PIN_SHARE_CTRL0C_FFA0 = (((BYTE)_PIN_103 << 4) | (_PIN_104 << 1));
 287   1          MCU_PIN_SHARE_CTRL0D_FFA1 = (((BYTE)_PIN_109 << 4) | (_PIN_110));
 288   1          MCU_PIN_SHARE_CTRL0E_FFA2 = (((BYTE)_PIN_111 << 4) | (_PIN_112));
 289   1          MCU_PIN_SHARE_CTRL0F_FFA3 = (((BYTE)_PIN_56_57_IIC_ENABLE << 7) | (_PIN_56 << 4) | (_PIN_57 << 1));
 290   1          MCU_PIN_SHARE_CTRL10_FFA4 = (((BYTE)_PIN_113 << 5) | (_PIN_121_122_DDC3_ENABLE << 4) | (_PIN_121 << 2)
             - | (_PIN_122));
 291   1          MCU_PIN_SHARE_CTRL11_FFA5 = (((BYTE)_PIN_65 << 5) | (_PIN_123_124_DDC2_ENABLE << 4) | (_PIN_123 << 2) 
             -| (_PIN_124));
 292   1          MCU_PIN_SHARE_CTRL12_FFA6 = (((BYTE)_PIN_72 << 5) | (_PIN_114 << 2));
 293   1      #else
                  pData[0] = (((BYTE)_PIN_41 << 6) | (_PIN_42 << 4) | (_PIN_43 << 2) | (_PIN_54));
                  pData[1] = (((BYTE)_PIN_45 << 6) | (_PIN_119 << 3) | (_PIN_126));
                  pData[2] = (((BYTE)_PIN_58_59_DDC1_ENABLE << 7) | (_PIN_58 << 4) | (_PIN_59 << 1));
              
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 6   

                  CScalerPageSelect(_PAGEE);
                  CScalerWrite(_PE_PIN_SHARE_CTRL00_D4, 3, pData, _AUTOINC);
              
                  pData[0] = (((BYTE)_PIN_46 << 6) | (_PIN_51 << 4) | (_PIN_64));
                  pData[1] = (((BYTE)_PIN_52 << 6) | (_PIN_66 << 3) | (_PIN_67));
                  pData[2] = (((BYTE)_PIN_53 << 6) | (_PIN_69 << 3) | (_PIN_70));
                  pData[3] = (((BYTE)_PIN_47 << 6) | (_PIN_55 << 3) | (_PIN_63));
                  pData[4] = (((BYTE)_PIN_48 << 6) | (_PIN_68 << 3) | (_PIN_71));
                  pData[5] = (((BYTE)_PIN_44 << 5) | (_PIN_96 << 3) | (_PIN_97));
                  pData[6] = (((BYTE)_PIN_74to83 << 6) | (_PIN_99 << 3) | (_PIN_100));
                  pData[7] = (((BYTE)_PIN_98 << 6) | (_PIN_102 << 3) | (_PIN_105));
                  pData[8] = (((BYTE)_PIN_50 << 5) | (_PIN_101 << 3) | (_PIN_108));
                  pData[9] = (((BYTE)_PIN_103 << 4) | (_PIN_104 << 1));
                  pData[10] = (((BYTE)_PIN_109 << 4) | (_PIN_110));
                  pData[11] = (((BYTE)_PIN_111 << 4) | (_PIN_112));
                  pData[12] = (((BYTE)_PIN_56_57_IIC_ENABLE << 7) | (_PIN_56 << 4) | (_PIN_57 << 1));
                  pData[13] = (((BYTE)_PIN_113 << 5) | (_PIN_121_122_DDC3_ENABLE << 4) | (_PIN_121 << 2) | (_PIN_122));
                  pData[14] = (((BYTE)_PIN_65 << 5) | (_PIN_123_124_DDC2_ENABLE << 4) | (_PIN_123 << 2) | (_PIN_124));
                  pData[15] = (((BYTE)_PIN_72 << 5) | (_PIN_114 << 2));
              
                  CScalerPageSelect(_PAGEE);
                  CScalerWrite(_PE_PIN_SHARE_CTRL03_D7, 16, pData, _AUTOINC);
              #endif
 321   1      #elif((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  pData[0] = (((BYTE)_PIN_31 << 6) | (_PIN_32 << 4) | (_PIN_33 << 2) | (_PIN_34)); // Page 10-A0
                  pData[1] = (((BYTE)_PIN_35 << 6) | (_PIN_36_37 << 4) | (_PIN_41)); // Page 10-A1
                  pData[2] = (((BYTE)_PIN_42 << 5) | (_PIN_43 << 3) | (_PIN_44)); // Page 10-A2
                  pData[3] = (((BYTE)_PIN_45 << 6) | (_PIN_46 << 4) | (_PIN_47 << 2) | (_PIN_48)); // Page 10-A3
                  pData[4] = (((BYTE)_PIN_50 << 5) | (_PIN_51 << 3) | (_PIN_55)); // Page 10-A4
                  pData[5] = (((BYTE)_PIN_52 << 6) | (_PIN_65 << 3) | (_PIN_66)); // Page 10-A5
                  pData[6] = (((BYTE)_PIN_53 << 6) | (_PIN_67 << 3) | (_PIN_68)); // Page 10-A6
                  pData[7] = (((BYTE)_PIN_54 << 6) | (_PIN_69 << 3) | (_PIN_70)); // Page 10-A7
                  pData[8] = (((BYTE)_PIN_56_57_IIC_ENABLE << 6) | (_PIN_56 << 3) | (_PIN_57)); // Page 10-A8
                  pData[9] = (((BYTE)_PIN_58_59_DDC1_ENABLE << 6) | (_PIN_58 << 3) | (_PIN_59)); // Page 10-A9
                  pData[10] = (((BYTE)_PIN_63 << 4) | (_PIN_64)); // Page 10-AA
                  pData[11] = (((BYTE)_PIN_71 << 5) | (_PIN_72 << 2) | (_PIN_74to83)); // Page 10-AB
                  pData[12] = (((BYTE)_PIN_99 << 5) | (_PIN_100 << 3) | (_PIN_102)); // Page 10-AC
                  pData[13] = (((BYTE)_PIN_96 << 6) | (_PIN_103 << 3) | (_PIN_104)); // Page 10-AD
                  pData[14] = (((BYTE)_PIN_97 << 6) | (_PIN_105 << 3) | (_PIN_108)); // Page 10-AE
                  pData[15] = (((BYTE)_PIN_109 << 4) | (_PIN_110to114_MIRROR << 3) | (_PIN_110)); // Page 10-AF
              
                  CScalerPageSelect(_PAGE10);
                  CScalerWrite(_P10_PIN_SHARE_CTRL00_A0, 16, pData, _AUTOINC);
              
                  pData[0] = (((BYTE)_PIN_98 << 6) | (_PIN_111 << 3) | (_PIN_112)); // Page 10-B0
                  pData[1] = (((BYTE)_PIN_101 << 6) | (_PIN_113 << 3) | (_PIN_114)); // Page 10-B1
                  pData[2] = (((BYTE)_PIN_119 << 5) | (_PIN_121_122_DDC3_ENABLE << 4) | (_PIN_121 << 2) | (_PIN_122)); /
             -/ Page 10-B2
                  pData[3] = (((BYTE)_PIN_123_124_DDC2_ENABLE << 7) | (_PIN_123 << 5) | (_PIN_124 << 3) | (_PIN_126)); /
             -/ Page 10-B3
              
                  CScalerPageSelect(_PAGE10);
                  CScalerWrite(_P10_PIN_SHARE_CTRL10_B0, 4, pData, _AUTOINC);
              
              #elif(_SCALER_TYPE == _RTD2545LR)
                  pData[0] = (((BYTE)_PIN_44 << 2) | (_PIN_43));
              
                  CScalerPageSelect(_PAGEE);
                  CScalerWrite(_PE_PIN_SHARE_CTRL01_D5, 1, pData, _AUTOINC);
              #else
                  No Setting  !!
              #endif  // End of #if(_SCALER_TYPE == _RTD2472D)
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 7   

 358   1      
 359   1      // V015 System Patch Note (7) Modify 20100630 Start
 360   1      // Patch Reason : New EEPROM emulation process.
 361   1      /*
 362   1      #if(_PCB_TYPE == _RTD2472D_DEMO_PCB) // For 6048
 363   1          // Output Enable
 364   1          CScalerSetByte(_TCON_ADDR_PORT_8B, 0xC3);
 365   1          CScalerSetByte(_TCON_DATA_PORT_8C, 0x02);
 366   1          HW_PROTECT_PIN_LOW();
 367   1      #elif(_PCB_TYPE == _RTD2472RD_DEMO_PCB) // For 6049
 368   1          HW_PROTECT_PIN_LOW();
 369   1      #endif
 370   1      */
 371   1          CMiscConfigureFlashWPPinLow();
 372   1      // V015 System Patch Note (7) Modify 20100630 End
 373   1      }
 374          
 375          //----------------------------------------------------------------------------------------------------
 376          // Debug Functions
 377          //----------------------------------------------------------------------------------------------------
 378          //--------------------------------------------------
 379          // Description  : ISP process
 380          // Input Value  : None
 381          // Output Value : None
 382          //--------------------------------------------------
 383          void CMiscIspack(void)
 384          {
 385   1      #if(_DEBUG_TOOL == _ISP_FOR_RTD2120)
              
                  BYTE halt = 0;
              
                  do
                  {
                      if(bRunCommand)
                      {
                          switch(ucDdcciData[0])
                          {
                              case 0x80:
                                  halt = ucDdcciData[1];
              
                                  break;
              
                              case 0x41:
                                  CScalerRead(ucDdcciData[1], 1, pData, _NON_AUTOINC);
                                  TxBUF = pData[0];
                                  MCU_I2C_DATA_OUT_FF2A = pData[0];
                                  break;
              
                              case 0x44:
                                  CI2cRead(NVRAM_LINE,ucDdcciData[2], ucDdcciData[1], 1, pData);
                                  TxBUF = pData[0];
                                  MCU_I2C_DATA_OUT_FF2A = pData[0];
                                  break;
              
                              default:
                                  switch (ucDdcciData[0] & 0x0F)          //Write command
                                  {
                                      case 0x00:
                                          CScalerSetByte(ucDdcciData[2], ucDdcciData[1]);
                                          break;
              
                                      case 0x01:
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 8   

                                      case 0x02:                          // for RTD & I2c Device
                                          ucDdcciData[2] = ucDdcciData[1];
                                          break;
              
                                      case 0x06:
                                      case 0x03:                          //for I2c Device
                                          ucDdcciData[3] = ucDdcciData[1];
                                          break;
              
                                      case 0x04:                         //for I2c Device
                                          CI2cWrite(NVRAM_LINE,ucDdcciData[2], ucDdcciData[1], 1, ucDdcciData + 3);
                                          break;
                                  }
                                  break;
                          }
              
                          bRunCommand = 0;
                          g_ucDdcciCommandNumber = 0;
                      }
                  }
                  while(halt != 0);
              
              #endif  // End of #if(_DEBUG_TOOL == _ISP_FOR_RTD2120)
 443   1      
 444   1      
 445   1      #if(_DEBUG_TOOL == _ISP_FOR_EMBEDDED)
 446   1          BYTE halt = 0;
 447   1          BYTE cnt = 0;
 448   1      
 449   1          // V015 System Patch Note (7) Modify 20100630 Start
 450   1          // Patch Reason : New EEPROM emulation process.
 451   1      #if((_MEMORY_LOCATION == _FLASH) && ((_GAMMA_LUT_LOCATION == _GAMMA_LUT_LOCATION_FLASH) || (_HDCP_KEY_LOCA
             -TION == _HDCP_LOCATION_FLASH)))
              #if(_FLASH_XDATA_ACCESS == _ON)
                  BYTE xdata *pFlashData = 0x0000;
              #endif
              #endif
 456   1          // V015 System Patch Note (7) Modify 20100630 End
 457   1      
 458   1      #if(_DDCCI_SUPPORT == _ON)
                  if(GET_DDCCI_STATUS())
                  {
                      return;
                  }
              #endif
 464   1      
 465   1          do
 466   1          {
 467   2              if(bRunCommand)
 468   2              {
 469   3                  cnt = 0;
 470   3                  switch(ucDdcciData[0])
 471   3                  {
 472   4                      case 0x80:
 473   4                          halt = ucDdcciData[1];
 474   4                          break;
 475   4      
 476   4                      case 0x41:
 477   4                          MCU_I2C_IRQ_CTRL2_FF2A |= 0x20;
 478   4                          /*
 479   4                          MCU_I2C_IRQ_CTRL2_FF2A |= 0x40;
 480   4                          */
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 9   

 481   4                          CScalerRead(ucDdcciData[1], 1, pData, _NON_AUTOINC);
 482   4                          /*
 483   4                          TxBUF= pData[0];
 484   4                          MCU_I2C_DATA_OUT_FF26 = pData[0];
 485   4                          */
 486   4                          do
 487   4                          {
 488   5                              MCU_I2C_IRQ_CTRL2_FF2A |= 0x40;
 489   5                              MCU_I2C_DATA_OUT_FF26 = pData[0];
 490   5      
 491   5                          }while(((MCU_DDCCI_REMAIN_FF35 & 0x1F) != 0x01) && ((cnt++) < _DATA_OUT_COUNT));
 492   4                          break;
 493   4      
 494   4                      case 0x44:
 495   4                          MCU_I2C_IRQ_CTRL2_FF2A |= 0x20;
 496   4                          /*
 497   4                          MCU_I2C_IRQ_CTRL2_FF2A |= 0x40;
 498   4                          */
 499   4                          CI2cRead(NVRAM_LINE,ucDdcciData[2], ucDdcciData[1], 1, pData);
 500   4                          /*
 501   4                          TxBUF= pData[0];
 502   4                          MCU_I2C_DATA_OUT_FF26 = pData[0];
 503   4                          */
 504   4                          do
 505   4                          {
 506   5                              MCU_I2C_IRQ_CTRL2_FF2A |= 0x40;
 507   5                              MCU_I2C_DATA_OUT_FF26 = pData[0];
 508   5      
 509   5                          }while(((MCU_DDCCI_REMAIN_FF35 & 0x1F) != 0x01) && ((cnt++) < _DATA_OUT_COUNT));
 510   4                          break;
 511   4      
 512   4      #if(_DEBUG_MESSAGE_SUPPORT == _ON)
 513   4                      case 0x2F:  //Debug Message Event finsih
 514   4                          MCU_I2C_IRQ_CTRL2_FF2A |= 0x20;
 515   4                          do
 516   4                          {
 517   5                              MCU_I2C_IRQ_CTRL2_FF2A |= 0x40;
 518   5                              MCU_I2C_IRQ_CTRL2_FF2A &= 0xBF; //Reset IIC Data Buffer
 519   5                              MCU_I2C_DATA_OUT_FF26 = 0xF5;
 520   5      
 521   5                          }while(((MCU_DDCCI_REMAIN_FF35 & 0x1F) != 0x01) && ((cnt++) < _DATA_OUT_COUNT));
 522   4      
 523   4                          MCU_I2C_IRQ_CTRL2_FF2A &= 0xDF;
 524   4                          g_bDebugMessageStart = 0;
 525   4                          g_bFwHalt = _FALSE;
 526   4                          g_bDebugMessageEven = 0;
 527   4                          break;
 528   4      #endif  // End of #if(_DEBUG_MESSAGE_SUPPORT == _ON)
 529   4      
 530   4      // V015 System Patch Note (7) Modify 20100630 Start
 531   4      // Patch Reason : New EEPROM emulation process.
 532   4      #if((_MEMORY_LOCATION == _FLASH) && ((_GAMMA_LUT_LOCATION == _GAMMA_LUT_LOCATION_FLASH) || (_HDCP_KEY_LOCA
             -TION == _HDCP_LOCATION_FLASH)))
              #if(_FLASH_XDATA_ACCESS == _ON)
                              case 0x35:
                                  TxBUF = _START_PAGE;
                                  MCU_I2C_DATA_OUT_FF26 = _START_PAGE;
                                  break;
              
                              case 0x36:
                                  TxBUF = _MISC_PAGE;
                                  MCU_I2C_DATA_OUT_FF26 = _MISC_PAGE;
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 10  

                                  break;
              
                              case 0x37:
                                  // Initial _MISC_PAGE
                                  CFlashInitialMISCPageStart();
                                  break;
              
                              case 0x38:
                                  // Restore _MISC_PAGE
                                  CFlashInitialMISCPageEnd();
                                  break;
              
                                  ////////////////0x3A command define////////////////////////////////////////////
                                  // g_ucDdcciData[1] (Bit7 ~ Bit3 = page number,    Bit2 ~ Bit0 = index number) //
                                  // g_ucDdcciData[2] (Bit7 ~ Bit1 = ID number,      Bit0 Reserved )             //
                                  // address = page * 1024 + ID * 8 + index                                    //
                                  ///////////////////////////////////////////////////////////////////////////////
              
                              case 0x3A:
                                  TxBUF = pFlashData[(ucDdcciData[2] << 8) + ucDdcciData[1]];
                                  MCU_I2C_DATA_OUT_FF26 = pFlashData[(ucDdcciData[2] << 8) + ucDdcciData[1]];
                                  break;
              
                              case 0x3B:
                                  CFlashWREN((BYTE)(ucDdcciData[2] >> 4));
                                  pFlashData[(ucDdcciData[2] << 8) + ucDdcciData[1]] = ucDdcciData[3];
                                  CFlashWRDis();
                                  break;
              #endif // End of #if(_FLASH_XDATA_ACCESS == _ON)
              #endif // End of #if((_MEMORY_LOCATION == _FLASH) && ((_GAMMA_LUT_LOCATION == _GAMMA_LUT_LOCATION_FLASH) |
             -| (_HDCP_KEY_LOCATION == _HDCP_LOCATION_FLASH)))
 572   4      // V015 System Patch Note (7) Modify 20100630 End
 573   4      
 574   4                      default:
 575   4                          switch (ucDdcciData[0] & 0x0F)          //Write command
 576   4                          {
 577   5                              case 0x00:
 578   5                                  CScalerSetByte(ucDdcciData[2], ucDdcciData[1]);
 579   5                                  break;
 580   5      
 581   5                              case 0x01:
 582   5                              case 0x02:                          // for RTD & I2c Device
 583   5                                  ucDdcciData[2] = ucDdcciData[1];
 584   5                                  break;
 585   5      
 586   5                              case 0x06:
 587   5                              case 0x03:                          //for I2c Device
 588   5                                  ucDdcciData[3] = ucDdcciData[1];
 589   5                                  break;
 590   5      
 591   5                              case 0x04:                         //for I2c Device
 592   5      // for RTD TOOL WRITE AND READ 24C16 SJP20110629
 593   5      #if((_PCB_TYPE == _RTD2472D_DEMO_PCB) || (_PCB_TYPE == _RTD2472RD_DEMO_PCB) || (_PCB_TYPE == _RTD2545LR_QA
             -_PCB) || (_PCB_TYPE == _RTD2472RD_DEMO_PCB) || (_PCB_TYPE == _RTD2472RD_QA_PCB)) //||(_PCB_TYPE == _RTD2472D_QA_PCB)||(_
             -PCB_TYPE == _RTD2472RD_QA_PCB))
 594   5          bEEPROM_WRITE_PROTECT = _LOW;
 595   5      #endif
 596   5                                  CI2cWrite(NVRAM_LINE,ucDdcciData[2], ucDdcciData[1], 1, ucDdcciData + 3);
 597   5      CI2cWritePolling(NVRAM_LINE,ucDdcciData[2]);
 598   5      CEepromLoadLSlumiData();//sjp20110715
 599   5      CEepromLoadPWMlumiData();//SJP20110715
 600   5      #if((_PCB_TYPE == _RTD2472D_DEMO_PCB) || (_PCB_TYPE == _RTD2472RD_DEMO_PCB) || (_PCB_TYPE == _RTD2545LR_QA
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 11  

             -_PCB) || (_PCB_TYPE == _RTD2472RD_DEMO_PCB) || (_PCB_TYPE == _RTD2472RD_QA_PCB)) //||(_PCB_TYPE == _RTD2472D_QA_PCB)||(_
             -PCB_TYPE == _RTD2472RD_QA_PCB))
 601   5          bEEPROM_WRITE_PROTECT = _HIGH;
 602   5      #endif                                          
 603   5           //                       CI2cWrite(NVRAM_LINE,ucDdcciData[2], ucDdcciData[1], 1, ucDdcciData + 3);
 604   5                                  break;
 605   5                          }
 606   4                          break;
 607   4                  }
 608   3      
 609   3                  bRunCommand = 0;
 610   3      
 611   3                  g_ucDdcciCommandNumber = 0;
 612   3      
 613   3                  // V012 Modify 20100324 Start
 614   3                  // V012 Patch Note (23) : Fix the issue that DDC debug could not read in power saving.
 615   3                  // Host write Enable
 616   3                  MCU_I2C_IRQ_CTRL2_FF2A &= (~_BIT5);
 617   3                  // V012 Modify 20100324 End
 618   3      
 619   3      #if(_DDC_CHANNEL_SEL == _HDMI_DDC_CHANNEL)
                          MCU_HDMI_DDC_CTRL2_FF2E &= 0xFE;
              #elif(_DDC_CHANNEL_SEL == _DVI_DDC_CHANNEL)
                          MCU_DVI_DDC_CTRL2_FF20 &= 0xFE;
              #else
 624   3                  MCU_ADC_DDC_CTRL2_FF1D &= 0xFE;
 625   3      #endif
 626   3              }
 627   2          }
 628   1          while(halt != 0);
 629   1      #endif  // End of #if(_DEBUG_TOOL == _ISP_FOR_EMBEDDED)
 630   1      }
 631          
 632          
 633          #if(_DEBUG_TOOL == _ISP_FOR_RTD2120)
              //--------------------------------------------------
              // Description  : ISP for RTD2120 Initial
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CDdcciInitial(void)
              {
              #if(_DDCCI_SUPPORT == _ON)
                  MCU_I2C_SET_SLAVE_FF27 = 0x6e;
              #elif(_DDC_CHANNEL_SEL == _VGA_DDC_CHANNEL)
              
                  MCU_I2C_SET_SLAVE_FF27 = 0x6a;
              #else
                  MCU_I2C_SET_SLAVE_FF27 = 0x6b;
              #endif
              
                  MCU_I2C_IRQ_CTRL_FF2C = 0x3f;
                  MCU_PIN_SHARE1_FF01 = MCU_PIN_SHARE1_FF01 | 0x01;
                  MCU_OPTION_FF38 = 0x80;
              
                  //CScalerSetByte(_DDC_SET_SLAVE_F4 , 0x00);
                  EA = 1;
                  EX0 = 1;
                  IE = 0x8e;
              
              #if(_DEBUG_MESSAGE_SUPPORT == _ON)
                  CDebugMessage("######    F/W START    ######", _NO_VALUE);
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 12  

              #endif
              
                  CScalerSetByte(_DDC_SET_SLAVE_F4, 0x00);
              }
              #endif  // End of #if(_DEBUG_TOOL == _ISP_FOR_RTD2120)
 666          
 667          
 668          #if((_DEBUG_TOOL == _ISP_FOR_EMBEDDED) || (_DEBUG_TOOL == _RS232))
 669          //--------------------------------------------------
 670          // Description  : ISP for RTD Embeded MCU Initial
 671          // Input Value  : None
 672          // Output Value : None
 673          //--------------------------------------------------
 674          void CDdcciInitial(void)
 675          {
 676   1      #if(_DDCCI_SUPPORT == _ON)
                  MCU_I2C_SET_SLAVE_FF23 = 0x6e & (~_BIT0);
              #else
 679   1          MCU_I2C_SET_SLAVE_FF23 = 0x6a;
 680   1      #endif
 681   1      
 682   1      #if((_DEBUG_TOOL == _ISP_FOR_EMBEDDED) && (_DDCCI_SUPPORT == _OFF))
 683   1          MCU_I2C_IRQ_CTRL_FF28 = 0x16;
 684   1      #elif(_DDCCI_SUPPORT == _ON)
                  MCU_I2C_IRQ_CTRL_FF28 = 0x3F;
              #else
                  MCU_I2C_IRQ_CTRL_FF28 = 0x3F;
              #endif
 689   1      
 690   1          MCU_IRQ_PRIORITY_FF01 = 0x01;     //assign int1 (IRQ2)
 691   1      
 692   1      // V015 System Patch Note (7) Modify 20100630 Start
 693   1      // Patch Reason : New EEPROM emulation process.
 694   1      /*
 695   1      #if(_EMBEDDED_EDID == _ON)
 696   1          MCU_ADC_DDC_ENA_FF1B = 0x07;
 697   1          MCU_DVI_DDC_ENA_FF1E = 0x07;
 698   1          MCU_HDMI_DDC_ENA_FF2C = 0x07;
 699   1      #else
 700   1          MCU_ADC_DDC_ENA_FF1B = 0xe2;
 701   1      #if(((_DDC_CHANNEL_FOR_D0 == _DDC2) && (_D0_INPUT_PORT_TYPE == _D0_DP_PORT)) || ((_DDC_CHANNEL_FOR_D1 == _
             -DDC2) && (_D1_INPUT_PORT_TYPE == _D1_DP_PORT)))
 702   1          MCU_DVI_DDC_ENA_FF1E = 0x07;
 703   1          MCU_HDMI_DDC_ENA_FF2C = 0xe7;
 704   1      
 705   1      #elif (((_DDC_CHANNEL_FOR_D0 == _DDC3) && (_D0_INPUT_PORT_TYPE == _D0_DP_PORT)) || ((_DDC_CHANNEL_FOR_D1 =
             -= _DDC3) && (_D1_INPUT_PORT_TYPE == _D1_DP_PORT)))
 706   1          MCU_DVI_DDC_ENA_FF1E = 0xe7;
 707   1          MCU_HDMI_DDC_ENA_FF2C = 0x07;
 708   1      #else
 709   1          MCU_DVI_DDC_ENA_FF1E = 0xe7;
 710   1          MCU_HDMI_DDC_ENA_FF2C = 0xe7;
 711   1      
 712   1      #endif
 713   1      #endif
 714   1      */
 715   1      #if(_EMBEDDED_EDID == _ON)
              #if(_EDID_PRO == _ON)
                  MCU_ADC_DDC_ENA_FF1B = 0x07;
                  MCU_DVI_DDC_ENA_FF1E = 0x07;
                  MCU_HDMI_DDC_ENA_FF2C = 0x07;
              #else
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 13  

                  MCU_ADC_DDC_ENA_FF1B = 0x03;
                  MCU_DVI_DDC_ENA_FF1E = 0x03;
                  MCU_HDMI_DDC_ENA_FF2C = 0x03;
              #endif // End of #if(_EDID_PRO == _ON)
              
              #else // else of #if(_EMBEDDED_EDID == _ON)
 727   1          MCU_ADC_DDC_ENA_FF1B = 0xe2;
 728   1      #if(((_DDC_CHANNEL_FOR_D0 == _DDC2) && (_D0_INPUT_PORT_TYPE == _D0_DP_PORT)) || ((_DDC_CHANNEL_FOR_D1 == _
             -DDC2) && (_D1_INPUT_PORT_TYPE == _D1_DP_PORT)))
                  MCU_DVI_DDC_ENA_FF1E = 0x07;
                  MCU_HDMI_DDC_ENA_FF2C = 0xe7;
              #elif (((_DDC_CHANNEL_FOR_D0 == _DDC3) && (_D0_INPUT_PORT_TYPE == _D0_DP_PORT)) || ((_DDC_CHANNEL_FOR_D1 =
             -= _DDC3) && (_D1_INPUT_PORT_TYPE == _D1_DP_PORT)))
                  MCU_DVI_DDC_ENA_FF1E = 0xe7;
                  MCU_HDMI_DDC_ENA_FF2C = 0x07;
              #else
 735   1          MCU_DVI_DDC_ENA_FF1E = 0xe2;
 736   1          MCU_HDMI_DDC_ENA_FF2C = 0xe2;
 737   1      
 738   1      #endif
 739   1      #endif // End of #if(_EMBEDDED_EDID == _ON)
 740   1      // V015 System Patch Note (7) Modify 20100630 End
 741   1      
 742   1      #if(_DDC_CHANNEL_SEL == _HDMI_DDC_CHANNEL)
                  MCU_I2C_CHANNEL_CTRL_FF2B |= 0x01;  // From HDMI DDC
              #elif(_DDC_CHANNEL_SEL == _DVI_DDC_CHANNEL)
                  MCU_I2C_CHANNEL_CTRL_FF2B &= 0xFE;
                  MCU_I2C_SET_SLAVE_FF23 |= 0x01;     // From DVI DDC
              #else
 748   1          MCU_I2C_CHANNEL_CTRL_FF2B &= 0xFE;
 749   1          MCU_I2C_SET_SLAVE_FF23 &= 0xFE;     // From ADC DDC
 750   1      #endif
 751   1      
 752   1          // V012 Modify 20100324 Start
 753   1          // V012 Patch Note (23) : Fix the issue that DDC debug could not read in power saving.
 754   1          /*
 755   1          MCU_I2C_IRQ_CTRL2_FF2A = 0x80; //host write/read enable
 756   1          */
 757   1      #if(_DDCCI_SUPPORT == _ON)
                  MCU_I2C_IRQ_CTRL2_FF2A = 0x80;
              #else
 760   1          MCU_I2C_IRQ_CTRL2_FF2A = 0xC0;
 761   1          MCU_I2C_STATUS_FF27 = 0;
 762   1      #endif
 763   1          // V012 Modify 20100324 End
 764   1      
 765   1          MCU_CTRL_FFED |= 0x80;
 766   1          EA = 1;
 767   1      
 768   1          // Enable interrupts of External INT1
 769   1          IE |= 0x04;
 770   1      
 771   1      
 772   1      #if(_DEBUG_MESSAGE_SUPPORT == _ON)
 773   1          CDebugMessage("######    F/W START    ######", _NO_VALUE);
 774   1      #endif
 775   1      
 776   1      }
 777          #endif  // End of #if(_DEBUG_TOOL == _ISP_FOR_EMBEDDED)
 778          
 779          
 780          //--------------------------------------------------
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 14  

 781          // Description  : Debug tool process
 782          // Input Value  : None
 783          // Output Value : None
 784          //--------------------------------------------------
 785          void CMiscIspDebugProc(void)
 786          {
 787   1          CMiscIspack();//uart zp0704
 788   1      
 789   1      #if(_DEBUG_TOOL == _RS232)
                  CUartHandler();
              #endif
 792   1      
 793   1      
 794   1      //CUartEnable();//uart zp0704
 795   1      //CUartTransferNumToScr('a', 0);//uart zp0704
 796   1      
 797   1      
 798   1      // V015 System Patch Note (7) Modify 20100630 Start
 799   1      // Patch Reason : New EEPROM emulation process.
 800   1      /*
 801   1      #if((_EDID_PRO == _ON) && ((_MCU_TYPE == _REALTEK_RTD2120) || (_MCU_TYPE == _REALTEK_RTD2122)))
 802   1          CMiscEdidPoc();
 803   1      #endif
 804   1      */
 805   1      #if((_MEMORY_LOCATION == _FLASH) && (_EDID_PRO == _ON))
                  CMiscEdidPoc();
              #endif
 808   1      // V015 System Patch Note (7) Modify 20100630 End
 809   1      }
 810          
 811          #if((_EDID_PRO == _ON) && ((_MCU_TYPE == _REALTEK_RTD2120) || (_MCU_TYPE == _REALTEK_RTD2122)))
              //--------------------------------------------------
              // Description  : EDID process
              //               (F/W will update EDID in Eeprom or Flash
              //                if DDCRAM of MCU has been modified.)
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CMiscEdidPoc(void)
              {
                  BYTE cnt;
              
                  pData[0] = MCU_I2C_STATUS_FF2B;
              
                  if(pData[0] & 0xc0) //ADC DDC Change bit
                  {
                      MCU_I2C_STATUS_FF2B = pData[0] & 0x3f;
              
                      do
                      {
                          MCU_I2C_STATUS_FF2B &= 0x3f;
                          CTimerDelayXms(100);
                      }
                      while(MCU_I2C_STATUS_FF2B & 0xc0);
              
                      pData[1] = 0;
              
                      for(cnt = 0; cnt < 128; cnt++)
                      {
                          if(pData[0] & 0x80)
                          {
                              pData[1] = (BYTE)(MCU_DDCRAM_VGA[cnt] + pData[1]);
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 15  

                          }
                          else if(pData[0] & 0x40)
                          {
                              pData[1] = (BYTE)(MCU_DDCRAM_DVI[cnt] + pData[1]);
                          }
                      }
              
                      if(pData[1] == 0)  //updata
                      {
                      /*
              #if((_EDID_PRO == _ON) && (_MEMORY_LOCATION == _EEPROM))
                          CEepromSaveEDIDData();
              #elif((_EDID_PRO == _ON) && (_MEMORY_LOCATION == _FLASH))
                          CEepromSaveEDIDToFlash();
              #endif*/
                      }
              
                  }
              }
              #endif  // End of #if((_EDID_PRO == _ON) && ((_MCU_TYPE == _REALTEK_RTD2120) || (_MCU_TYPE == _REALTEK_RTD
             -2122)))
 863          
 864          // V015 System Patch Note (7) Modify 20100630 Start
 865          // Patch Reason : New EEPROM emulation process.
 866          #if((_EDID_PRO == _ON) && (_MEMORY_LOCATION == _FLASH) && (_MCU_TYPE == _REALTEK_EMBEDDED))
              //--------------------------------------------------
              // Description  : EDID process
              //               (F/W will update EDID in Eeprom or Flash
              //                if DDCRAM of MCU has been modified.)
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CMiscEdidPoc(void)
              {
                  if(GET_EDIDPROSTATUS() == _FALSE)
                  {
                      SET_ADCDVIDDCSTATUS(MCU_I2C_STATUS_FF27); // Bit7 ADC DDC write bit, bit6 DVI DDC write bit.
                      SET_HDMIDDCSTATUS(MCU_I2C_STATUS2_FF29); // Bit0 HDMI DDC write bit.
              
                      if((GET_ADCDDCSTATUS() == _TRUE) || (GET_DVIDDCSTATUS() == _TRUE) || (GET_HDMIDDCSTATUS() == _TRUE
             -)) // DDC write bit
                      {
                          MCU_I2C_STATUS_FF27 &= (~(_BIT7 | _BIT6));
                          MCU_I2C_STATUS2_FF29 &= (~_BIT0);
                          SET_EDIDPROSTATUS();
              
                          CTimerActiveTimerEvent(SEC(0.1), CMiscSaveDDCToFlashEvent);
                      }
                  }
              }
              
              //--------------------------------------------------
              // Description  : EDID process
              //               (F/W will update EDID in Flash
              //                if DDCRAM of MCU has been modified.)
              // Input Value  : None
              // Output Value : TRUE or FALSE
              //--------------------------------------------------
              bit CMiscSaveDDCToFlashEvent(void)
              {
                  // DDC write bit is not zero and cnt is zero, can not save EDID.
                  if(((MCU_I2C_STATUS2_FF29 & _BIT0) != 0) || ((MCU_I2C_STATUS_FF27 & (_BIT7 | _BIT6)) != 0))
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 16  

                  {
                      SET_ADCDVIDDCSTATUS(MCU_I2C_STATUS_FF27); // Bit7 ADC DDC write bit, bit6 DVI DDC write bit.
                      SET_HDMIDDCSTATUS(MCU_I2C_STATUS2_FF29); // Bit0 HDMI DDC write bit.
              
                      MCU_I2C_STATUS_FF27 &= (~(_BIT7 | _BIT6));
                      MCU_I2C_STATUS2_FF29 &= (~_BIT0);
              
                      CLR_EDIDPROSTATUS();
              
                      return _FALSE;
                  }
              
                  if((GET_ADCDDCSTATUS() == _TRUE) || (GET_DVIDDCSTATUS() == _TRUE) || (GET_HDMIDDCSTATUS() == _TRUE))
                  {
                      CFlashSaveDDCData();
                  }
              
                  CLR_EDIDPROSTATUS();
                  CLR_ADCDVIDDCSTATUS();
                  CLR_HDMIDDCSTATUS();
              
                  return _TRUE;
              }
              
              #endif //  End of #if((_EDID_PRO == _ON) && (_MEMORY_LOCATION == _FLASH) && (_MCU_TYPE == _REALTEK_EMBEDDE
             -D))
 928          
 929          //--------------------------------------------------
 930          // Description  : Configure pin share for the flash WP#
 931          // Input Value  : None
 932          // Output Value : None
 933          //--------------------------------------------------
 934          void CMiscConfigureFlashWPPinHigh(void)
 935          {
 936   1      #if(_PCB_TYPE == _RTD2472D_DEMO_PCB) // For 6048
 937   1          // This is a reference configuration for _RTD2472D_DEMO_PCB,
 938   1          // WP# connected with pin108
 939   1          CScalerSetByte(_TCON_ADDR_PORT_8B, 0xC3);
 940   1          CScalerSetByte(_TCON_DATA_PORT_8C, 0x02);
 941   1      
 942   1          MCU_PIN_SHARE_CTRL0B_FF9F = 0x01;
 943   1      
 944   1          HW_PROTECT_PIN_HIGH();
 945   1      #elif(_PCB_TYPE == _RTD2472RD_DEMO_PCB) // For 6049
                  // This is a reference configuration for _RTD2472RD_DEMO_PCB,
                  // WP# connected with pin108
                  CScalerSetByte(_TCON_ADDR_PORT_8B, 0xC3);
                  CScalerSetByte(_TCON_DATA_PORT_8C, 0x02);
              
                  CScalerPageSelect(_PAGE10);
              
                  // V016 System Patch Note (27) Modify 20100831 Start
                  // Patch Reason : Modify Flash WP pin define
                  /*
                  CScalerSetBit(_P10_PIN_SHARE_CTRL0E_AE, ~(_BIT2 | _BIT1 | _BIT0), 0x01);
                  */
                  CScalerSetBit(_P10_PIN_SHARE_CTRL0E_AE, ~(_BIT2 | _BIT1 | _BIT0), _PIN_108);
                  // V016 System Patch Note (27) Modify 20100831 End
              
                  HW_PROTECT_PIN_HIGH();
              #endif
 963   1      }
C51 COMPILER V8.02   MISC                                                                  03/05/2012 13:24:16 PAGE 17  

 964          
 965          //--------------------------------------------------
 966          // Description  : Configure flash WP# pin to LOW
 967          // Input Value  : None
 968          // Output Value : None
 969          //--------------------------------------------------
 970          void CMiscConfigureFlashWPPinLow(void)
 971          {
 972   1      #if(_PCB_TYPE == _RTD2472D_DEMO_PCB) // For 6048
 973   1          // Output Enable
 974   1          CScalerSetByte(_TCON_ADDR_PORT_8B, 0xC3);
 975   1          CScalerSetByte(_TCON_DATA_PORT_8C, 0x02);
 976   1          HW_PROTECT_PIN_LOW();
 977   1      #elif(_PCB_TYPE == _RTD2472RD_DEMO_PCB) // For 6049
                  HW_PROTECT_PIN_LOW();
              #endif
 980   1      }
 981          // V015 System Patch Note (7) Modify 20100630 End
 982          
 983          
 984          #endif  // End of #if(_SCALER_SERIES_TYPE == _RTD2472D_SERIES)
 985          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    930    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       2
   IDATA SIZE       =      4    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
