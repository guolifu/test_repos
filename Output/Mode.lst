C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE MODE
OBJECT MODULE PLACED IN .\Output\Mode.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Scaler\Code\Mode.c OPTIMIZE(9,SPEED) DEFINE(_PROJECT=_RTD2472D_DEMO_BOARD) 
                    -PRINT(.\Output\Mode.lst) OBJECT(.\Output\Mode.obj)

line level    source

   1          /********************************************************************************/
   2          /*   The  Software  is  proprietary,  confidential,  and  valuable to Realtek   */
   3          /*   Semiconductor  Corporation  ("Realtek").  All  rights, including but not   */
   4          /*   limited  to  copyrights,  patents,  trademarks, trade secrets, mask work   */
   5          /*   rights, and other similar rights and interests, are reserved to Realtek.   */
   6          /*   Without  prior  written  consent  from  Realtek,  copying, reproduction,   */
   7          /*   modification,  distribution,  or  otherwise  is strictly prohibited. The   */
   8          /*   Software  shall  be  kept  strictly  in  confidence,  and  shall  not be   */
   9          /*   disclosed to or otherwise accessed by any third party.                     */
  10          /*   c<2003> - <2010>                                                           */
  11          /*   The Software is provided "AS IS" without any warranty of any kind,         */
  12          /*   express, implied, statutory or otherwise.                                  */
  13          /********************************************************************************/
  14          
  15          //----------------------------------------------------------------------------------------------------
  16          // ID Code      : Mode.c No.0000
  17          // Update Note  :
  18          //----------------------------------------------------------------------------------------------------
  19          
  20          #define __MODE__
  21          
  22          #include "Common\Header\Include.h"
  23          
  24          #if(_SCALER_SERIES_TYPE == _RTD2472D_SERIES)
  25          
  26          //--------------------------------------------------
  27          // Description  : Mode handler, the main control flow
  28          // Input Value  : None
  29          // Output Value : None
  30          //--------------------------------------------------
  31          void CModeHandler(void)
  32          {
  33   1          CKeyKeyPadLedControl();
  34   1      
  35   1          if(CPowerHandler())
  36   1          {
  37   2      #if _DEBUG_MESSAGE_SUPPORT
  38   2        //      CDebugMessage("CPowerHandler_CModeHandler", 0);
  39   2      #endif
  40   2              ucCurrState = _PWOFF_STATE;
  41   2      //bData=0;//sjp20110730
  42   2              
  43   2          }
  44   1      
  45   1      #if(_SWITCH_INPUT_SOURCE_OSD == _ON)
  46   1          if(GET_SOURCE_OSD_STATUS())
  47   1          {
  48   2              return;
  49   2          }
  50   1      #endif
  51   1      
  52   1              #if _DEBUG_MESSAGE_SUPPORT
  53   1        //       CDebugMessage("CModeHandler", 0);
  54   1        //       CDebugMessage("ucCurrState", ucCurrState);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 2   

  55   1               #endif
  56   1      
  57   1          switch(ucCurrState)
  58   1          {
  59   2              /********************/
  60   2              case _PWOFF_STATE:
  61   2              /********************/
  62   2      
  63   2                  ucCurrState = GET_POWERSTATUS() ? _INITIAL_STATE : _PWOFF_STATE;
  64   2                  break;
  65   2      
  66   2              /********************/
  67   2              case _INITIAL_STATE:
  68   2              /********************/
  69   2      
  70   2                  ucCurrState = _SEARCH_STATE;
  71   2                  break;
  72   2      
  73   2              /********************/
  74   2              case _SEARCH_STATE:
  75   2              /********************/
  76   2      
  77   2      #if((_HDMI_SUPPORT == _ON) || (_TMDS_SUPPORT == _ON))
  78   2                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchInd
             -ex) == _D1_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) =
             -= _D1_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D
             -1_DVI_I_PORT))
  79   2                  {
  80   3                      // ENC toggle (HDCP flag)
  81   3                      CScalerPageSelect(_PAGE2);
  82   3                      CScalerRead(_P2_HDCP_PORT_CTRL_C2, 1, pData, _NON_AUTOINC);
  83   3      
  84   3                      if((pData[0] & 0x10) == 0x10)
  85   3                      {
  86   4                          g_bHDMIHDCPFlag = 1;
  87   4                      }
  88   3                  }
  89   2      #endif
  90   2              #if _DEBUG_MESSAGE_SUPPORT
  91   2       //       CDebugMessage("CSourceHandler __SEARCH_STATE", 0);
  92   2               #endif
  93   2      
  94   2                  if(CSourceHandler())
  95   2                  {
  96   3              #if _DEBUG_MESSAGE_SUPPORT
  97   3              CDebugMessage("CSourceHandler true", 0);
  98   3               #endif
  99   3       #if(_SCALER_TYPE == _RTD2545LR)
                              CPowerM2PLLOn();
              #endif
 102   3      
 103   3                      // Source and sync OK
 104   3                      if(CModeDetect())
 105   3                      {
 106   4      
 107   4         #if _DEBUG_MESSAGE_SUPPORT
 108   4                                                 CDebugMessage("CSourceHandler true", 0);
 109   4      #endif
 110   4      
 111   4                          // Mode stable. Initial display settings  switch to active/nosignal/nosupport state
 112   4                          SET_READYFORDISPLAY();
 113   4      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 3   

 114   4      
 115   4                          ////////////////////////////////
 116   4                          //  Mode Detect for No-Signal //
 117   4                          ////////////////////////////////
 118   4      
 119   4                          if(stModeInfo.ModeCurr == _MODE_NOSIGNAL)
 120   4                          {
 121   5      #if(_DP_SUPPORT == _ON)
                                      if((GET_INPUTSOURCE_TYPE() == _SOURCE_DP))
                                      {
                                          if(g_bDpDisplayPass == _TRUE)
                                          {
                                              ucCurrState = _NOSUPPORT_STATE;
                               #if _DEBUG_MESSAGE_SUPPORT
                                      CDebugMessage("_NOSUPPORT_STATE5", 0);
                              #endif
                                              stModeInfo.ModeCurr = _MODE_NOSUPPORT;
                                          }
                                          else
                                          {
                                              // V016 System Patch Note (29) Modify 20100902 Start
                                              // Patch Reason : Fix mode handler flow issue.
                                              SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
                                              // V016 System Patch Note (29) Modify 20100902 End
              
                                              ucCurrState = _NOSIGNAL_STATE;
                                          }
                                      }
                                      else
                                      {
                                          // V016 System Patch Note (29) Modify 20100902 Start
                                          // Patch Reason : Fix mode handler flow issue.
                                          SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
                                          // V016 System Patch Note (29) Modify 20100902 End
              
                                          ucCurrState = _NOSIGNAL_STATE;
                                      }
              
              #else
 153   5                              // V016 System Patch Note (29) Modify 20100902 Start
 154   5                              // Patch Reason : Fix mode handler flow issue.
 155   5                              SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
 156   5                              // V016 System Patch Note (29) Modify 20100902 End
 157   5      
 158   5                              ucCurrState = _NOSIGNAL_STATE;
 159   5      #endif
 160   5                          }
 161   4      
 162   4                          /////////////////////////////////
 163   4                          //  Mode Detect for No-Support //
 164   4                          /////////////////////////////////
 165   4      
 166   4      #if(_FRC_SUPPORT == _ON)
                                  else if(stModeInfo.ModeCurr == _MODE_NOSUPPORT)
              #else
 169   4                          else if((stModeInfo.ModeCurr == _MODE_NOSUPPORT) || (stModeInfo.IVFreq > _PANEL_MAX_FR
             -AME_RATE))
 170   4      #endif
 171   4                          {
 172   5                              CModeAutoMeasureOn();
 173   5                              ucCurrState = _NOSUPPORT_STATE;
 174   5                              #if _DEBUG_MESSAGE_SUPPORT
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 4   

 175   5                                 CDebugMessage("_NOSUPPORT_STATE4", 0);
 176   5                             #endif
 177   5                              stModeInfo.ModeCurr = _MODE_NOSUPPORT;
 178   5                          }
 179   4      
 180   4                          //////////////////////////////////
 181   4                          //  Mode Detect for Active Mode //
 182   4                          //////////////////////////////////
 183   4      
 184   4                          else
 185   4                          {
 186   5      
 187   5      #if((_OD_SUPPORT == _ON) || (_FRC_SUPPORT == _ON))
                                      CMemorySDRAMReset();
              #endif
 190   5      
 191   5                              if(GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
 192   5                              {
 193   6                                  // HDCP MP Testing Mode: CTRL=1001, to avoid trigger WD when reset Rx_en
 194   6                                  CScalerPageSelect(_PAGE2);
 195   6                                  CScalerSetBit(_P2_UP_DOWN_CTRL0_B5, ~(_BIT1 | _BIT0), _BIT0);
 196   6      
 197   6                                  CScalerPageSelect(_PAGE2);
 198   6                                  CScalerRead(_P2_POWER_ON_OFF_CTRL_A7, 1, pData, _NON_AUTOINC);
 199   6      
 200   6                                  if((pData[0] & _BIT6) == _BIT6) // BR Swap: HDMI port
 201   6                                  {
 202   7                                      // Reset Rx_en(R & G lane)
 203   7                                      CScalerPageSelect(_PAGEB);
 204   7                                      CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x79);
 205   7                                      CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x7F);
 206   7                                  }
 207   6                                  else  // no BR Swap: DVI port
 208   6                                  {
 209   7                                      // Reset Rx_en(R & G lane)
 210   7                                      CScalerPageSelect(_PAGEB);
 211   7                                      CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x7C);
 212   7                                      CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x7F);
 213   7                                  }
 214   6      
 215   6                                  // Recover "HDCP MP Testing Mode" to original mode
 216   6                                  CScalerPageSelect(_PAGE2);
 217   6                                  CScalerSetBit(_P2_UP_DOWN_CTRL0_B5, ~_BIT0, 0);
 218   6                              }
 219   5      
 220   5                              CModeDisplayActiveMode();
 221   5      
 222   5                              if(GET_INPUTSOURCE_TYPE() == _SOURCE_NONE)
 223   5                              {
 224   6                                  return;
 225   6                              }
 226   5      
 227   5                              // V016 System Patch Note (15) Modify 20100824 Start
 228   5                              // Patch Reason : Fix IHCount=0 issue
 229   5                              /*
 230   5                              CModeAutoMeasureOn();
 231   5                              */
 232   5                              // V016 System Patch Note (15) Modify 20100824 End
 233   5      
 234   5      #if(_AUDIO_SUPPORT == _ON)
              #if((_SCALER_TYPE == _RTD2472D))
              #if(_HDMI_SUPPORT == _ON)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 5   

              #if(_HDMI_FROM_DVI_CONNECT == _OFF)
                                      if(CHdmiFormatDetect() && ((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) 
             -|| (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_HDMI_PORT)))//Input source is the HDMI format.
              #else
                                      if(CHdmiFormatDetect())
              #endif
                                      {
                                          CHdmiAudioFirstTracking();
                                      }
              
                                      CTimerActiveTimerEvent(SEC(0.5), CHdmiAudioWaitingFlagReadyEven);
              
              #endif  // End of #if(_HDMI_SUPPORT == _ON)
              #endif  // End of #if((_SCALER_TYPE == _RTD2472D))
              #endif  // End of #if(_AUDIO_SUPPORT == _ON)
 251   5      
 252   5      
 253   5      #if(_DCR_MODE == _DCR_TYPE_3)
                                      CDcrInitial();
              #endif
 256   5      
 257   5      
 258   5      #if((_OD_SUPPORT == _ON) || (_FRC_SUPPORT == _ON))
                                      if(ucCurrState == _NOSUPPORT_STATE)
                                      {
                                          ucCurrState = _NOSUPPORT_STATE;
                               #if _DEBUG_MESSAGE_SUPPORT
                                              CDebugMessage("_NOSUPPORT_STATE3", 0);
                               #endif
                                      }
                                      else
                                      {
                                          CSourceSetCountDown();
                                          ucCurrState = _CHECK_STATE;
                                      }
              #else
 272   5                              CSourceSetCountDown();
 273   5                              ucCurrState = _CHECK_STATE;
 274   5      
 275   5      #endif  // End of #if((_OD_SUPPORT == _ON) || (_FRC_SUPPORT == _ON))
 276   5                          }
 277   4                      }
 278   3                      else    // Else of if(CModeDetect())
 279   3                      {
 280   4                          ///////////////////////
 281   4                          //  Mode Detect Fail //
 282   4                          ///////////////////////
 283   4      
 284   4                          if(g_ucModeStableCount > 0)
 285   4                          {
 286   5                              // Still in search state
 287   5                              g_ucModeStableCount--;
 288   5                          }
 289   4                          else
 290   4                          {
 291   5                              CModeSyncTimeoutCountDownEvent();
 292   5                              CModeAutoMeasureOn();
 293   5      
 294   5                              // V013 System Patch Note (1) 20100409 Modify Start
 295   5                              // Patch Reason : Optimize code to avoid an unnecessary excution of CModeMeasureDa
             -ta.
 296   5                              /*
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 6   

 297   5                              CModeMeasureData();
 298   5      
 299   5      #if(_DP_SUPPORT == _ON)
 300   5                              if(CModeMeasureData() || (g_bDpDisplayPass == _TRUE))
 301   5                              {
 302   5                                  ucCurrState = _NOSUPPORT_STATE;
 303   5                              }
 304   5                              else
 305   5                              {
 306   5                                  ucCurrState = _NOSIGNAL_STATE;
 307   5                              }
 308   5      #else
 309   5                              ucCurrState = _NOSIGNAL_STATE;
 310   5      #endif
 311   5                              */
 312   5                              if(CModeMeasureData() == _TRUE)
 313   5                              {
 314   6                                  ucCurrState = _NOSUPPORT_STATE;
 315   6                               #if _DEBUG_MESSAGE_SUPPORT
 316   6                                      CDebugMessage("_NOSUPPORT_STATE2", 0);
 317   6                               #endif
 318   6                              }
 319   5                              else
 320   5                              {
 321   6                                  ucCurrState = _NOSIGNAL_STATE;
 322   6                              }
 323   5                              // V013 System Patch Note (1) 20100409 Modify End
 324   5                          }
 325   4                      }
 326   3      
 327   3                      ucEvent0 = _INACTIVE_COUNTDOWN_EVENT;
 328   3      
 329   3                  }
 330   2                  else    // Else of if(CSourceHandler())
 331   2                  {
 332   3              #if _DEBUG_MESSAGE_SUPPORT
 333   3               CDebugMessage("CSourceHandler fail", 0);
 334   3               #endif
 335   3                      /////////////////////////
 336   3                      //  Source Search Fail //
 337   3                      /////////////////////////
 338   3      
 339   3                      if(GET_SEARCH_FINISH())
 340   3                      {
 341   4      
 342   4      #if(_DP_SUPPORT == _ON)
              
                                  if((g_bDpDisplayPass == _TRUE) && (g_ucDpPowerStatus != _DP_POWER_DOWN))
                                  {
                                      ucCurrState = _NOSUPPORT_STATE;
                                      #if _DEBUG_MESSAGE_SUPPORT
                                      CDebugMessage("_NOSUPPORT_STATE1", 0);
                                      #endif
                                      SET_READYFORDISPLAY();
                                  }
                                  else
                                  {
                                      CModeSyncTimeoutCountDownEvent();
                                  }
              #else
 357   4                          CModeSyncTimeoutCountDownEvent();
 358   4                          /*
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 7   

 359   4                          CLR_SEARCH_FINISH();
 360   4                          */
 361   4      #endif
 362   4                          CLR_SEARCH_FINISH();
 363   4                      }
 364   3                  }
 365   2      
 366   2      
 367   2                  break;
 368   2      
 369   2              /********************/
 370   2              case _CHECK_STATE:
 371   2              /********************/
 372   2      
 373   2                  if(GET_COUNTDOWN_DP_STABLE())
 374   2                  {
 375   3                      CTimerActiveTimerEvent(SEC(0.5), CMiscCheckToActiveEvent);
 376   3                      CLR_COUNTDOWN_DP_STABLE();
 377   3                  }
 378   2                  else if(GET_COUNTDOWN_HDMI_HDCP_WORSE())
 379   2                  {
 380   3                      CTimerActiveTimerEvent(SEC(3), CMiscCheckToActiveEvent);
 381   3                      CLR_COUNTDOWN_HDMI_HDCP_WORSE();
 382   3                  }
 383   2                  else if(GET_COUNTDOWN_HDMI_STABLE())
 384   2                  {
 385   3                      CTimerActiveTimerEvent(SEC(0.3), CMiscCheckToActiveEvent);
 386   3                      CLR_COUNTDOWN_HDMI_STABLE();
 387   3                  }
 388   2                  else if(GET_COUNTDOWN_VGA_STABLE())
 389   2                  {
 390   3                      CTimerActiveTimerEvent(SEC(0.1), CMiscCheckToActiveEvent);
 391   3                      CLR_COUNTDOWN_VGA_STABLE();
 392   3                  }
 393   2      
 394   2                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchInd
             -ex) == _D1_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) =
             -= _D1_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D
             -1_DVI_I_PORT))
 395   2                  {
 396   3                      if(g_bHDMIHDCPFlag != 1)            // No HDCP
 397   3                      {
 398   4                          CScalerPageSelect(_PAGE2);
 399   4                          CScalerRead(_P2_HDCP_PORT_CTRL_C2, 1, pData, _NON_AUTOINC);
 400   4      
 401   4                          if((pData[0] & 0x10) == 0x10)   // from No HDCP ---> HDCP
 402   4                          {
 403   5                              CTimerCancelTimerEvent(CMiscCheckToActiveEvent); // cancel 0.3 secs event
 404   5                              SET_COUNTDOWN_HDMI_HDCP_WORSE();
 405   5                              g_bHDMIHDCPFlag = 1;
 406   5                          }
 407   4                      }
 408   3                      else // HDCP
 409   3                      {
 410   4                          CScalerPageSelect(_PAGE2);
 411   4                          CScalerSetByte(_P2_HDCP_ADDR_PORT_C3, 0x08);
 412   4                          CScalerRead(_P2_HDCP_DATA_PORT_C4, 1, pData, _NON_AUTOINC);
 413   4      
 414   4                          if(pData[0] != 0x00)    // Ri != 0;
 415   4                          {
 416   5                              // Frame Counter
 417   5                              CScalerPageSelect(_PAGE2);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 8   

 418   5                              CScalerSetByte(_P2_HDCP_ADDR_PORT_C3, 0xC0);
 419   5                              CScalerRead(_P2_HDCP_DATA_PORT_C4, 1, pData, _NON_AUTOINC);
 420   5      
 421   5                              if(pData[0] != 0x00)
 422   5                              {
 423   6                                  if(g_bCheckHDCP == 0)
 424   6                                  {
 425   7                                      CTimerCancelTimerEvent(CMiscCheckToActiveEvent); // cancel 3 secs event
 426   7                                      SET_COUNTDOWN_HDMI_STABLE();
 427   7                                      g_bCheckHDCP = 1;
 428   7                                  }
 429   6                              }
 430   5                          }
 431   4                      }
 432   3                  }
 433   2      
 434   2                  // V013 VGA Patch Note (9) Modify 20100414 Start
 435   2                  // Patch Reason : Add Checking Stable Signal mechanism for VGA Signal.
 436   2                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT)
 437   2                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT)
 438   2                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_YPBPR_PORT)
 439   2                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_YPBPR_PORT))
 440   2                  {
 441   3                      if(CSyncCheckVGAIsStable() == _FALSE)
 442   3                      {
 443   4                          CModeResetMode();
 444   4                          break;
 445   4                      }
 446   3                  }
 447   2                  // V013 VGA Patch Note (9) Modify 20100414 End
 448   2      
 449   2                  if(CModeStableDetect() == _FALSE)
 450   2                  {
 451   3                      CModeResetMode();
 452   3                  }
 453   2      
 454   2                  break;
 455   2      
 456   2              /********************/
 457   2              case _ACTIVE_STATE:
 458   2              /********************/
 459   2      #if(_DDCCI_SUPPORT == _ON)
                          g_ucActiveInputSourceType = GET_INPUTSOURCE_TYPE();
              #endif
 462   2      
 463   2                  if(CModeStableDetect() == _FALSE)
 464   2                  {
 465   3                      CModeResetMode();
 466   3                  }
 467   2                  else
 468   2                  {
 469   3      
 470   3      // V012 Modify 20100304 Start
 471   3      // V012 Patch Note (1) : Add RGB/YUV color space convert function.
 472   3      #if(_COLOR_FORMAT_CONVERT == _ON)
 473   3                      CModeColorFormatConvert();
 474   3      #endif
 475   3      // V012 Modify 20100304 End
 476   3      
 477   3                      if(GET_READYFORDISPLAY() == _TRUE)
 478   3                      {
 479   4      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 9   

 480   4      #if(_AUDIO_SUPPORT == _ON)
                                  CAdjustAudioControl(_ENABLE);
              #endif
 483   4                          CLR_READYFORDISPLAY();
 484   4                          SET_OSD_READYFORDISPLAY();
 485   4                          CSourceSaveSearchData();
 486   4      #if(_OD_SUPPORT == _ON)
                                  if(CMemorySetODCompress() == _FALSE)
                                  {
                                      CMemorySetODOnOff(_OFF);
                                  }
                                  else
                                  {
                                      CMemorySetODFIFO();
                                      CMemorySetODOnOff(_ON);
                                  }
              #endif
 497   4      
 498   4      // V012 Modify 20100316 Start
 499   4      // V012 Patch Note (2) : Overscan function update.
 500   4      #if(_OVERSCAN_SUPPORT == _ON)
 501   4                          CModeOverScanAdjustPos();
 502   4      #endif
 503   4      // V012 Modify 20100316 End
 504   4      
 505   4      
 506   4      #if((_ASPECT_RATIO_SUPPORT == _ON) && (_MEMORY_WORK_TYPE == _OD_OFF_FRC_OFF))
 507   4      
 508   4                          CModeSetDHWidthToDisplay();
 509   4                          CTimerDelayXms(100);
 510   4      
 511   4      #endif // End of #if((_ASPECT_RATIO_SUPPORT == _ON) && (_MEMORY_WORK_TYPE == _OD_OFF_FRC_OFF))
 512   4      
 513   4                          CPowerPanelOn();
 514   4      
 515   4                          CScalerPageSelect(_PAGE2);
 516   4                          CScalerSetBit(_P2_TMDS_RPS_AE, ~_BIT7, 0);
 517   4                          CAdjustEnableWatchDog(_WD_ALL);
 518   4      
 519   4      #if(_HDMI_SUPPORT == _ON)
                                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucS
             -earchIndex) == _D1_HDMI_PORT)
                                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSe
             -archIndex) == _D1_DVI_PORT)
                                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_uc
             -SearchIndex) == _D1_DVI_I_PORT))//sephinroth 20080606
                                  {
                                      if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
                                      {
                                          CScalerPageSelect(_PAGE2);
                                          CScalerRead(_P2_HDMI_SR_CB, 1, pData, _NON_AUTOINC);
              
                                          if((bit)(pData[0] & 0x40)) // AVMute detected!
                                          {
                                              CAdjustDisableHDMIWatchDog(_WD_PACKET_VARIATION | _WD_SET_AVMUTE_ENABLE); 
             - // Disable packet variation Watch Dog
                                              CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, _BIT5);
                                          }
                                          else
                                          {
                                               CAdjustEnableHDMIWatchDog(_WD_PACKET_VARIATION);   // Enable packet varia
             -tion Watch Dog
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 10  

                                               CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
                                          }
                                       }
                                       else
                                       {
                                              CAdjustDisableHDMIWatchDog(_WD_PACKET_VARIATION | _WD_SET_AVMUTE_ENABLE); 
             -  // Disable packet variation Watch Dog
                                              CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
                                       }
                                  }
                                  else
                                  {
                                      CAdjustDisableHDMIWatchDog(_WD_PACKET_VARIATION | _WD_SET_AVMUTE_ENABLE);   // Dis
             -able packet variation Watch Dog
                                      CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
                                  }
              #endif
 552   4      
 553   4      #if(_DP_SUPPORT == _ON)
                                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DP_PORT) || (GET_INPUTPORT_TYPE(g_ucSea
             -rchIndex) == _D1_DP_PORT))
                                  {
                                      CDpSinkStatusSet(_TRUE);    //! In Sync
                                  }
              #endif
 559   4      
 560   4                          // V013 VGA Patch Note (10) 20100416 Modify Start
 561   4                          // Patch Reason : Support Auto Config For Yuv Color.
 562   4      #if((_FIFO_MODE_ONLY == _ON) && (_YUV_AUTO_CONFIG_SUPPORT == _ON))
 563   4                          if((GET_AUTO_FLAG() == 0) && ((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOU
             -RCE_TYPE() == _SOURCE_YPBPR)))
 564   4      #else
                                  if((GET_AUTO_FLAG() == 0) && (GET_INPUTSOURCE_TYPE() == _SOURCE_VGA))
              #endif
 567   4                          // V013 VGA Patch Note (10) 20100416 Modify End
 568   4      
 569   4                          {
 570   5                              ucOsdEventMsg = _DO_AUTO_CONFIG;
 571   5                          }
 572   4                          else
 573   4                          {
 574   5                             CTimerReactiveTimerEvent(SEC(0), CModeOsdDisplayTimingAndInputEvent);
 575   5                          }
 576   4                      }   // End of if(GET_READYFORDISPLAY() == _TRUE)
 577   3      
 578   3      #if(_HDMI_SUPPORT == _ON)
                              CHdmiAVMuteCheck();
              #endif
 581   3      
 582   3      #if((_DCR_MODE == _DCR_TYPE_1) || (_DCR_MODE == _DCR_TYPE_2))
                              if(GET_DCR_STATUS())
                              {
                                  CDcrMeasureStartHD();
                              }
                              else if(!GET_DCR_STATUS())
                              {
                                  CDcrSlowAdjust(stSystemData.BackLight);
                              }
              #endif
 592   3      
 593   3      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2545LR))
              #if((_HDMI_SUPPORT == _ON) && (_AUDIO_SUPPORT == _ON))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 11  

                              if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
                              {
                                  CHdmiAudioControl();
                              }
              #endif // End of #if((_HDMI_SUPPORT == _ON))
              #endif
 601   3                  }   // End of if(CModeStableDetect() == _FALSE)
 602   2      
 603   2      #if(_DCR_MODE == _DCR_TYPE_3)
                          if(g_ucDcrTimer > 1)     // 20mSec
                          {
                              CDcrDcr3();
                              g_ucDcrTimer = 0;
                          }
              #endif
 610   2                  break;
 611   2      
 612   2      
 613   2              /********************/
 614   2              case _NOSUPPORT_STATE:
 615   2              /********************/
 616   2      
 617   2      
 618   2      #if(_DP_SUPPORT == _ON)
                          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DP_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex
             -) == _D1_DP_PORT))
                          {
                              if(CDpNosupportCheck() == _TRUE)
                              {
                                  CModeResetMode();
                                  break;
                              }
                          }
                          else
                          {
                              if(CModeIsChange())
                              {
                                  CModeResetMode();
                                  break;
                              }
                          }
              
                          if(GET_READYFORDISPLAY() == _TRUE)
                          {
                              CLR_READYFORDISPLAY();
                              SET_OSD_READYFORDISPLAY();
                              CModeSetFreeRun();
                          }
                          break;
              #else
 644   2      
 645   2                  if(CModeIsChange())
 646   2                  {
 647   3                      CModeResetMode();
 648   3                      break;
 649   3                  }
 650   2      
 651   2                  if(GET_READYFORDISPLAY() == _TRUE)
 652   2                  {
 653   3                      CLR_READYFORDISPLAY();
 654   3                      SET_OSD_READYFORDISPLAY();
 655   3                      CModeSetFreeRun();
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 12  

 656   3                  }
 657   2                  break;
 658   2      
 659   2      #endif //End of #if(_DP_SUPPORT == _ON)
 660   2      
 661   2      
 662   2              /********************/
 663   2              case _NOSIGNAL_STATE:
 664   2              /********************/
 665   2      
 666   2                  if(GET_READYFORDISPLAY() == _TRUE)
 667   2                  {
 668   3                      CLR_READYFORDISPLAY();
 669   3                      SET_OSD_READYFORDISPLAY();
 670   3                      CModeSetFreeRun();
 671   3      
 672   3                      CScalerPageSelect(_PAGE2);
 673   3                      CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_SCR_00, ~(_BIT3 | _BIT2), _BIT3);
 674   3                  }
 675   2      
 676   2      #if((_TMDS_SUPPORT == _ON))
 677   2                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchInd
             -ex) == _D1_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) =
             -= _D1_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D
             -1_DVI_I_PORT))
 678   2                  {
 679   3                      // DVI/HDMI: high sensitivity then can't sleep
 680   3                      CScalerPageSelect(_PAGE2);
 681   3                      CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT4 | _BIT3 | _BIT2 | _BIT1 | _BIT0), 0x00);
 682   3                      CTimerDelayXms(5);
 683   3                      CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), 0x0f);
 684   3                  }
 685   2      #endif
 686   2      #if _DEBUG_MESSAGE_SUPPORT
 687   2      //CDebugMessage("CSourceHandler__NOSIGNAL_STATE", 0);
 688   2      #endif
 689   2      /*****for source auto search 2011 0613*****/
 690   2      if(stSystemData.SearchIndex>1)
 691   2              {
 692   3              stSystemData.SearchIndex=1;//sjp20111206
 693   3              CEepromSaveSystemData();        
 694   3              }
 695   2       if(stSystemData.SearchIndex==1)
 696   2              {
 697   3              g_ucSearchIndex=0;
 698   3      #if(_D0_INPUT_PORT_TYPE == _D0_DVI_PORT)
 699   3          //CSourceSwitchInputPort(_D0_INPUT_PORT);
 700   3      #endif
 701   3      #if _DEBUG_MESSAGE_SUPPORT
 702   3      //CDebugMessage("CSourceHandler_stSystemData.SearchIndex==1", 0);
 703   3      #endif
 704   3              if(CSourceHandler())    
 705   3                      {
 706   4                    g_ucSearchIndex=0;
 707   4                      COsdMenuSingalDVI();
 708   4      #if _DEBUG_MESSAGE_SUPPORT
 709   4      //CDebugMessage("signal switch VGA switch to DVI", 0);
 710   4      #endif
 711   4                      }
 712   3              else
 713   3                      {
 714   4                              g_ucSearchIndex=1;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 13  

 715   4      #if _DEBUG_MESSAGE_SUPPORT
 716   4      //CDebugMessage("signal switch VGA switch fail", 0);
 717   4      #endif                  
 718   4                      }
 719   3              }
 720   2      else if (stSystemData.SearchIndex==0)
 721   2      {
 722   3              g_ucSearchIndex=1;
 723   3      #if(_D0_INPUT_PORT_TYPE == _D0_DVI_PORT)
 724   3          //CSourceSwitchInputPort(_D0_INPUT_PORT);
 725   3      #endif
 726   3      #if _DEBUG_MESSAGE_SUPPORT
 727   3      //CDebugMessage("CSourceHandler_stSystemData.SearchIndex==0", 0);
 728   3      #endif
 729   3              if(CSourceHandler())    
 730   3                      {
 731   4                    g_ucSearchIndex=1;
 732   4                      COsdMenuSingalVGA();
 733   4      #if _DEBUG_MESSAGE_SUPPORT
 734   4      //CDebugMessage("signal switch DVI switch to VGA", 0);
 735   4      #endif
 736   4                      }
 737   3              else
 738   3                      {
 739   4                              g_ucSearchIndex=0;
 740   4      #if _DEBUG_MESSAGE_SUPPORT
 741   4      //CDebugMessage("signal switch DVI switch fail", 0);
 742   4      #endif          
 743   4                      }       
 744   3      }
 745   2      /*****for source auto search 2011 0613*****/
 746   2                  if(CModeConnectIsChange() || CSourceHandler())
 747   2                  {
 748   3                      CModeResetMode();
 749   3                  }
 750   2                  break;
 751   2      
 752   2              /********************/
 753   2              case _SLEEP_STATE:
 754   2              /********************/
 755   2              #if _DEBUG_MESSAGE_SUPPORT
 756   2             // CDebugMessage("CSourceHandler ___SLEEP_STATE", 0);
 757   2               #endif
 758   2      /*****for source auto search 2011 0613*****/
 759   2      
 760   2       if(stSystemData.SearchIndex==1)
 761   2              {
 762   3              g_ucSearchIndex=0;
 763   3      #if(_D0_INPUT_PORT_TYPE == _D0_DVI_PORT)
 764   3          //CSourceSwitchInputPort(_D0_INPUT_PORT);
 765   3      #endif
 766   3      #if _DEBUG_MESSAGE_SUPPORT
 767   3      //CDebugMessage("CSourceHandler_stSystemData.SearchIndex==1", 0);
 768   3      #endif
 769   3              if(CSourceHandler())    
 770   3                      {
 771   4                    g_ucSearchIndex=0;
 772   4                      COsdMenuSingalDVI();
 773   4      #if _DEBUG_MESSAGE_SUPPORT
 774   4      //CDebugMessage("signal switch VGA switch to DVI", 0);
 775   4      #endif
 776   4                      }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 14  

 777   3              else
 778   3                      {
 779   4                              g_ucSearchIndex=1;
 780   4      #if _DEBUG_MESSAGE_SUPPORT
 781   4      //CDebugMessage("signal switch VGA switch fail", 0);
 782   4      #endif                  
 783   4                      }
 784   3      
 785   3              }
 786   2      else if (stSystemData.SearchIndex==0)
 787   2      {
 788   3              g_ucSearchIndex=1;
 789   3      #if(_D0_INPUT_PORT_TYPE == _D0_DVI_PORT)
 790   3          //CSourceSwitchInputPort(_D0_INPUT_PORT);
 791   3      #endif
 792   3      #if _DEBUG_MESSAGE_SUPPORT
 793   3      //CDebugMessage("CSourceHandler_stSystemData.SearchIndex==0", 0);
 794   3      #endif
 795   3              if(CSourceHandler())    
 796   3                      {
 797   4                    g_ucSearchIndex=1;
 798   4                      COsdMenuSingalVGA();
 799   4      #if _DEBUG_MESSAGE_SUPPORT
 800   4      //CDebugMessage("signal switch DVI switch to VGA", 0);
 801   4      #endif
 802   4                      }
 803   3              else
 804   3                      {
 805   4                              g_ucSearchIndex=0;
 806   4      #if _DEBUG_MESSAGE_SUPPORT
 807   4      //CDebugMessage("signal switch DVI switch fail", 0);
 808   4      #endif
 809   4                              
 810   4                              
 811   4                      }       
 812   3      
 813   3      
 814   3      
 815   3      
 816   3      }
 817   2      /*****for source auto search 2011 0613*****/
 818   2      
 819   2      
 820   2               
 821   2                  if(CModeConnectIsChange() || CSourceHandler())
 822   2                  {
 823   3                      CModeResetMode();
 824   3                  }
 825   2                  break;
 826   2              default:
 827   2                  break;
 828   2          }
 829   1      }
 830          
 831          //----------------------------------------------------------------------------------------------------
 832          // Measure Functions
 833          //----------------------------------------------------------------------------------------------------
 834          
 835          //--------------------------------------------------
 836          // Description  : Check measure ready process
 837          // Input Value  : None
 838          // Output Value : Return _TRUE if measure finished, _FALSE if timeout
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 15  

 839          //--------------------------------------------------
 840          bit CModeMeasureReady(void)
 841          {
 842   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
 843   1          {
 844   2              // V013 TMDS Patch Note (16) 20100422 Modify Start
 845   2              // Patch Reason : Solve DVI Interlace Issue
 846   2              CScalerPageSelect(_PAGE2);
 847   2              // V013 TMDS Patch Note (16) 20100422 Modify End
 848   2      
 849   2              if(CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7)
 850   2              {
 851   3                  CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, _BIT0);  // Digital Mode Measure
 852   3              }
 853   2              else
 854   2              {
 855   3                  CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, 0x00);   // Analog Mode Measure
 856   3              }
 857   2          }
 858   1          else
 859   1          {
 860   2              CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, 0x00);       // Analog Mode Measure
 861   2          }
 862   1      
 863   1          CAdjustSyncProcessorMeasureStart();
 864   1      
 865   1      // V015 VGA Patch Note (4) Modify 20100611 Start
 866   1      // Patch Reason : Modify HV measurement polling time
 867   1      /*
 868   1      #if(_LOW_FRAME_RATE_SUPPORT == _OFF)
 869   1          if(CTimerPollingEventProc(80, CMiscModeMeasurePollingEvent))
 870   1      #else
 871   1          if(CTimerPollingEventProc(120, CMiscModeMeasurePollingEvent))
 872   1      #endif
 873   1      */
 874   1      #if(_LOW_FRAME_RATE_SUPPORT == _OFF)
 875   1          if(CTimerPollingEventProc(_SP_AUTORUN_TIME_OUT, CMiscModeMeasurePollingEvent))
 876   1      #else
                  if(CTimerPollingEventProc(2 * _SP_AUTORUN_TIME_OUT, CMiscModeMeasurePollingEvent))
              #endif
 879   1      // V015 VGA Patch Note (4) Modify 20100611 End
 880   1          {
 881   2              return _TRUE;
 882   2          }
 883   1          else
 884   1          {
 885   2              CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, 0x00);
 886   2              return _FALSE;
 887   2          }
 888   1      }
 889          
 890          //--------------------------------------------------
 891          // Description  : Get measure data and convert into system information
 892          // Input Value  : None
 893          // Output Value : Return _TRUE if success, _FALSE if the measurement result is wrong
 894          //--------------------------------------------------
 895          bit CModeMeasureData(void)
 896          {
 897   1          // Read measurement status bit
 898   1          CScalerRead(_MEAS_HS_PERIOD_H_52, 3, &pData[8], _AUTOINC);
 899   1      
 900   1          if((bit)(pData[8] & _BIT4) || (bit)(pData[10] & _BIT4) || (bit)(pData[10] & _BIT5))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 16  

 901   1          {
 902   2      #if((_LOW_FRAME_RATE_SUPPORT == _OFF) || (_SCALER_TYPE == _RTD2472D))
 903   2      
 904   2              if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
 905   2              {
 906   3                  SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
 907   3              }
 908   2      
 909   2              return _FALSE;
 910   2      
 911   2      #else
              
                      if(CModeCheckLowFrameRate() == _FALSE)
                      {
                          SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
                          return _FALSE;
                      }
              
              #endif
 920   2          }
 921   1      
 922   1          // Pop up measurement result
 923   1          CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT6, _BIT6);
 924   1          CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, 0x00);
 925   1      
 926   1          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT)
 927   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT)
 928   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_YPBPR_PORT)
 929   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_YPBPR_PORT))
 930   1          {
 931   2              CScalerRead(_MEAS_VS_PERIOD_H_54, 2, &pData[10], _AUTOINC);     // VTotal
 932   2      
 933   2              CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT1, _BIT1);
 934   2              CScalerRead(_STABLE_PERIOD_H_50, 2, &pData[12], _AUTOINC);      // HCount
 935   2              CScalerRead(_STABLE_HIGH_PERIOD_H_4A, 2, &pData[14], _AUTOINC); // HSyncPulseWidth
 936   2          }
 937   1          else
 938   1          {
 939   2              CScalerRead(_MEAS_HS_PERIOD_H_52, 6, &pData[8], _AUTOINC);
 940   2          }
 941   1      
 942   1          // Calculate measurement result
 943   1          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT)
 944   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT)
 945   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_YPBPR_PORT)
 946   1          || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_YPBPR_PORT))
 947   1          {
 948   2              ((WORD *)pData)[0] = ((pData[12] & 0x07) << 8) | pData[13];  // HCount
 949   2              ((WORD *)pData)[1] = ((pData[10] & 0x0F) << 8) | pData[11];  // Vtotal
 950   2              ((WORD *)pData)[2] = ((pData[14] & 0x07) << 8) | pData[15]; // HSyncPulseWidth
 951   2          }
 952   1          else
 953   1          {
 954   2              ((WORD *)pData)[0] = ((pData[8] & 0x0f) << 8) | pData[9];   // HCount
 955   2              ((WORD *)pData)[1] = ((pData[10] & 0x0f) << 8) | pData[11]; // Vtotal
 956   2              ((WORD *)pData)[2] = ((pData[12] & 0xf0) << 4) | pData[13]; // HSyncPulseWidth
 957   2          }
 958   1      
 959   1          if((((WORD *)pData)[0] == 0) || (((WORD *)pData)[1] == 0))
 960   1          {
 961   2              // The measurement result is out of range
 962   2              return _FALSE;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 17  

 963   2          }
 964   1          else
 965   1          {
 966   2              /////////////////////// Digital Measure ////////////////////////////
 967   2              if(CScalerGetBit(_SYNC_SELECT_47, _BIT0) == _BIT0)
 968   2              {
 969   3                  // Save Polarity
 970   3                  stModeInfo.Polarity = (pData[10] & 0xc0) >> 6;
 971   3      
 972   3                  // V013 TMDS Patch Note (16) 20100422 Modify Start
 973   3                  // Patch Reason : Solve DVI Interlace Issue
 974   3                  // In digital measure HSYNC polarity is reverse of reality polarity
 975   3                  stModeInfo.Polarity = (stModeInfo.Polarity | (~(bit)(stModeInfo.Polarity & _BIT0)));
 976   3                  // V013 TMDS Patch Note (16) 20100422 Modify End
 977   3      
 978   3                  // Save IH_TOTAL
 979   3                  stModeInfo.IHCount = ((WORD *)pData)[0] + 1;
 980   3                  stModeInfo.IHTotal = stModeInfo.IHCount;
 981   3      
 982   3                  // Save input data enable width and height
 983   3                  stModeInfo.IVTotal = ((WORD *)pData)[1] + 1;
 984   3                  stModeInfo.IVHeight = stModeInfo.IVTotal;
 985   3                  stModeInfo.IHWidth = ((WORD *)pData)[2] + 1;
 986   3      
 987   3                  // V013 TMDS Patch Note (16) 20100422 Modify Start
 988   3                  // Patch Reason : Solve DVI Interlace Issue
 989   3                  /*
 990   3                  // Get IDEN vertical Start
 991   3                  CModeStartUpDVI();
 992   3      
 993   3                  stModeInfo.IVTotal = stModeInfo.IVStartPos + stModeInfo.IVHeight + 37;
 994   3      
 995   3                  // Measure IDEN Start Fail
 996   3                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_NONE)
 997   3                  {
 998   3                      return _FALSE;
 999   3                  }
1000   3                  */
1001   3                  stModeInfo.IVTotal = stModeInfo.IVStartPos + stModeInfo.IVHeight + 37;
1002   3                  // V013 TMDS Patch Note (16) 20100422 Modify End
1003   3      
1004   3                  CScalerPageSelect(_PAGE2);
1005   3      
1006   3                  // Read freq number result
1007   3                  CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x28);
1008   3                  CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[14], _NON_AUTOINC);
1009   3      
1010   3                  CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x29);
1011   3                  CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[15], _NON_AUTOINC);
1012   3      
1013   3                  ((DWORD *)pData)[0] = (((WORD)(pData[14] & 0x07) << 8) | pData[15]);
1014   3      
1015   3                  // Calculate IHS/IVS Frequency
1016   3                  stModeInfo.IHFreq = (WORD)(((DWORD)_RTD_XTAL * 1024) * 10 * 2 / (((DWORD *)pData)[0] * stModeI
             -nfo.IHTotal));
1017   3                  stModeInfo.IHFreq = (stModeInfo.IHFreq >> 1) + (stModeInfo.IHFreq & 0x01);
1018   3                  stModeInfo.IVFreq = (WORD)(((DWORD)_RTD_XTAL * 1024) * 10 / (((DWORD *)pData)[0] * stModeInfo.
             -IHTotal * (stModeInfo.IVStartPos + stModeInfo.IVHeight) / 1000));
1019   3      
1020   3                  return _TRUE;
1021   3      
1022   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 18  

1023   2      
1024   2              /////////////////////// Analog Measure ////////////////////////////
1025   2              // Store measurement results in global system variable
1026   2              stModeInfo.Polarity = (pData[10] & 0xc0) >> 6;
1027   2      
1028   2              stModeInfo.IHCount = ((WORD *)pData)[0] + 1;
1029   2      
1030   2              // V012 Modify 20100331 Start
1031   2              // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock 
             -with M2PLL.
1032   2              /*
1033   2              stModeInfo.IHFreq = (WORD)((DWORD)_RTD_XTAL * 10 * 2 / stModeInfo.IHCount);
1034   2              */
1035   2              stModeInfo.IHFreq = (WORD)((DWORD)_INTERNAL_SYSTEM_CLK * 10 * 2 / stModeInfo.IHCount);
1036   2              // V012 Modify 20100331 End
1037   2      
1038   2              stModeInfo.IHFreq = (stModeInfo.IHFreq >> 1) + (stModeInfo.IHFreq & 0x01);
1039   2              stModeInfo.IVTotal = ((WORD *)pData)[1] + 1;
1040   2      
1041   2              // V012 Modify 20100331 Start
1042   2              // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock 
             -with M2PLL.
1043   2              /*
1044   2              stModeInfo.IVFreq = (WORD)((DWORD)_RTD_XTAL * 10 * 1000 / ((DWORD)stModeInfo.IHCount * stModeInfo.
             -IVTotal));
1045   2              */
1046   2      
1047   2              // V012 Modify 20100402 Start
1048   2              // V012 Patch Note (29) : Fix the inaccurate Vfreq in OSD with SOG HORV/HEORV sync type.
1049   2              /*
1050   2              stModeInfo.IVFreq = (WORD)((DWORD)_INTERNAL_SYSTEM_CLK * 10 * 1000 / ((DWORD)stModeInfo.IHCount * 
             -stModeInfo.IVTotal));
1051   2              */
1052   2              if(CScalerGetBit(_SYNC_CTRL_49, _BIT2) == _BIT2)
1053   2              {
1054   3                  stModeInfo.IVFreq = (WORD)((DWORD)_INTERNAL_SYSTEM_CLK * 10 * 1000 / ((DWORD)stModeInfo.IHCoun
             -t * (stModeInfo.IVTotal + g_ucCoastLineCnt)));
1055   3              }
1056   2              else
1057   2              {
1058   3                  stModeInfo.IVFreq = (WORD)((DWORD)_INTERNAL_SYSTEM_CLK * 10 * 1000 / ((DWORD)stModeInfo.IHCoun
             -t * stModeInfo.IVTotal));
1059   3              }
1060   2              // V012 Modify 20100402 End
1061   2              // V012 Modify 20100331 End
1062   2      
1063   2              stModeInfo.IHSyncPulseCount = ((WORD *)pData)[2];
1064   2      
1065   2              if(stModeInfo.IHSyncPulseCount > (stModeInfo.IHCount / 2))
1066   2              {
1067   3                  stModeInfo.IHSyncPulseCount = stModeInfo.IHCount - stModeInfo.IHSyncPulseCount;
1068   3              }
1069   2      
1070   2              // Measure IVSyncPulseCount
1071   2              CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, _BIT0);
1072   2              CScalerRead(_MEAS_HS_VS_HIGH_PERIOD_H_56, 2, &pData[8], _AUTOINC);
1073   2      
1074   2              ((WORD *)pData)[0] = ((pData[8] & 0xF0) << 4) | pData[9];
1075   2      
1076   2              // V013 VGA Patch Note (3) 20100409 Modify Start
1077   2              // Patch Reason : Modify VSync Pulse Width Measure Result.
1078   2              /*
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 19  

1079   2              stModeInfo.IVSyncPulseCount = ((WORD *)pData)[0] + 1;
1080   2              */
1081   2              if(CScalerGetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, (_BIT6 | _BIT5 | _BIT4)) == 0x60) // SS Sync Type
1082   2              {
1083   3                  stModeInfo.IVSyncPulseCount = ((WORD *)pData)[0];
1084   3              }
1085   2              else
1086   2              {
1087   3                  stModeInfo.IVSyncPulseCount = ((WORD *)pData)[0] + 1;
1088   3              }
1089   2              // V013 VGA Patch Note (3) 20100409 Modify End
1090   2      
1091   2              if(stModeInfo.IVSyncPulseCount > (stModeInfo.IVTotal / 2))
1092   2              {
1093   3                  stModeInfo.IVSyncPulseCount = stModeInfo.IVTotal - stModeInfo.IVSyncPulseCount;
1094   3              }
1095   2      
1096   2      
1097   2              CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, 0x00);
1098   2      
1099   2              return _TRUE;
1100   2          }
1101   1      }
1102          
1103          // V013 TMDS Patch Note (16) 20100422 Modify Start
1104          // Patch Reason : Solve DVI Interlace Issue
1105          //--------------------------------------------------
1106          // Description  : Measure Active Region H/V Start
1107          // Input Value  : None
1108          // Output Value : None
1109          //--------------------------------------------------
1110          void CModeMeasureHVActiveStart(void)
1111          {
1112   1          CScalerSetBit(_AUTO_ADJ_CTRL0_7A, ~(_BIT7 | _BIT6 | _BIT1 | _BIT0), 0x00);
1113   1          CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~(_BIT7 | _BIT0), (_BIT7 | _BIT0));
1114   1      
1115   1          if(CTimerPollingEventProc(50, CMiscAutoMeasurePollingEvent))
1116   1          {
1117   2              CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
1118   2      
1119   2              CScalerPageSelect(_PAGE2);
1120   2              // IDEN horizontal Start
1121   2              stModeInfo.IHStartPos = ((((WORD)pData[3] & 0xf0) << 4) | (WORD)pData[4]) - ((CScalerGetBit(_P2_PO
             -WER_ON_OFF_CTRL_A7, _BIT7) == _BIT7) ? 16 - 14 : 18 - 14);
1122   2      
1123   2              // IDEN vertical Start
1124   2              stModeInfo.IVStartPos = (((WORD)pData[0] & 0xf0) << 4) | (WORD)pData[1];
1125   2          }
1126   1          else
1127   1          {
1128   2              CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x00);
1129   2              g_bDoModeResetMode = _TRUE;
1130   2          }
1131   1      }
1132          // V013 TMDS Patch Note (16) 20100422 Modify End
1133          
1134          //----------------------------------------------------------------------------------------------------
1135          // Mode Detect Functions
1136          //----------------------------------------------------------------------------------------------------
1137          
1138          //--------------------------------------------------
1139          // Description  : Mode detect process
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 20  

1140          // Input Value  : None
1141          // Output Value : Return _TRUE if we get a stable mode
1142          //--------------------------------------------------
1143          bit CModeDetect(void)
1144          {
1145   1          switch(GET_INPUTSOURCE_TYPE())
1146   1          {
1147   2              case _SOURCE_VGA:
1148   2      
1149   2      #if(_YPBPR_SUPPORT == _ON)
1150   2              case _SOURCE_YPBPR:
1151   2      #endif
1152   2                  CModeInitialVGA();
1153   2      
1154   2                  // V012 Modify 20100324 Start
1155   2                  // V012 Patch Note (18) : Fix the sync processor unlock issue which causes APLL setting fail.
1156   2                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_NONE)
1157   2                  {
1158   3                      return _FALSE;
1159   3                  }
1160   2                  // V012 Modify 20100324 End
1161   2      
1162   2      #if((_TMDS_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
1163   2              case _SOURCE_DVI:
1164   2              case _SOURCE_DP:
1165   2      #endif
1166   2      
1167   2      #if(_HDMI_SUPPORT == _ON)
                      case _SOURCE_HDMI:
              #endif
1170   2      
1171   2                  if(CModeDetectCommon())
1172   2                  {
1173   3                      return _TRUE;
1174   3                  }
1175   2                  break;
1176   2      
1177   2      #if(_VIDEO_SUPPORT == _ON)
              
                      case _SOURCE_VIDEO8:
                          stModeInfo.ModeCurr = _MODE_EXIST;
                          return _TRUE;
              
              #endif
1184   2      
1185   2          }
1186   1      
1187   1          return _FALSE;
1188   1      }
1189          
1190          //--------------------------------------------------
1191          // Description  : Mode detect process for VGA and DVI
1192          // Input Value  : None
1193          // Output Value : Return _TRUE if we get a stable mode
1194          //--------------------------------------------------
1195          bit CModeDetectCommon(void)
1196          {
1197   1          BYTE modetemp = _MODE_NOSIGNAL;
1198   1          BYTE polaritytemp;
1199   1          WORD hcount, vtotal;
1200   1      
1201   1      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2472D))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 21  

1202   1      
1203   1          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D0_DP_PORT) && (GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D1
             -_DP_PORT)
1204   1              && (GET_INPUTPORT_TYPE(g_ucSearchIndex) != _A0_VGA_PORT))
1205   1          {
1206   2              // Freq Check
1207   2              if(CSyncCheckTMDSFreq() == _FALSE)
1208   2              {
1209   3                  CModeResetMode();
1210   3                  return _FALSE;
1211   3              }
1212   2      
1213   2              // BCH Error Check
1214   2              if((GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
1215   2              {
1216   3                  CScalerPageSelect(_PAGE2);
1217   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT3, _BIT3);
1218   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT1, 0x00);
1219   3                  CTimerDelayXms(5);
1220   3                  CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x02);
1221   3                  CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[0], _NON_AUTOINC);
1222   3      
1223   3                  if((pData[0] & 0x02) == 0x02)
1224   3                  {
1225   4                      CModeResetMode();
1226   4                      return _FALSE;
1227   4                  }
1228   3              }
1229   2          }
1230   1      #endif
1231   1      
1232   1          if(CModeMeasureReady())
1233   1          {
1234   2              polaritytemp = stModeInfo.Polarity;
1235   2              hcount = stModeInfo.IHCount;
1236   2              vtotal = stModeInfo.IVTotal;
1237   2               #if _DEBUG_MESSAGE_SUPPORT
1238   2      //               CDebugMessage("stModeInfo.Polarity==", stModeInfo.Polarity);
1239   2       //              CDebugMessage("stModeInfo.IHCount==", stModeInfo.IHCount);
1240   2       //              CDebugMessage("stModeInfo.IHTotal==", stModeInfo.IHTotal);
1241   2      //               CDebugMessage("stModeInfo.IHFreq==", stModeInfo.IHFreq);
1242   2       //              CDebugMessage("stModeInfo.IHStartPos==", stModeInfo.IHStartPos);
1243   2       //              CDebugMessage("stModeInfo.IHSyncPulseCount==", stModeInfo.IHSyncPulseCount);
1244   2                       
1245   2       ///             CDebugMessage("stModeInfo.IHWidth==", stModeInfo.IHWidth);
1246   2                       
1247   2      //               CDebugMessage("stModeInfo.IVTotal==", stModeInfo.IVTotal);
1248   2      //               CDebugMessage("stModeInfo.IVFreq==", stModeInfo.IVFreq);
1249   2      //               CDebugMessage("stModeInfo.IVHeight==", stModeInfo.IVHeight);
1250   2       //              CDebugMessage("stModeInfo.IVStartPos==", stModeInfo.IVStartPos);
1251   2       //              CDebugMessage("stModeInfo.IVSyncPulseCount==", stModeInfo.IVSyncPulseCount);
1252   2                #endif
1253   2      
1254   2              // Get measure results and decide " modetemp = _MODE_NOSIGNAL/_MODE_NOSUPPORT/_MODE_EXIST "
1255   2              if(CModeMeasureData())
1256   2              {
1257   3               #if _DEBUG_MESSAGE_SUPPORT
1258   3      //               CDebugMessage("stModeInfo.Polarity==", stModeInfo.Polarity);
1259   3      //               CDebugMessage("stModeInfo.IHCount==", stModeInfo.IHCount);
1260   3       //              CDebugMessage("stModeInfo.IHTotal==", stModeInfo.IHTotal);
1261   3       //              CDebugMessage("stModeInfo.IHFreq==", stModeInfo.IHFreq);
1262   3       //              CDebugMessage("stModeInfo.IHStartPos==", stModeInfo.IHStartPos);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 22  

1263   3       //              CDebugMessage("stModeInfo.IHSyncPulseCount==", stModeInfo.IHSyncPulseCount);
1264   3       //              CDebugMessage("stModeInfo.IHWidth==", stModeInfo.IHWidth);
1265   3                       
1266   3       //              CDebugMessage("stModeInfo.IVTotal==", stModeInfo.IVTotal);
1267   3       //              CDebugMessage("stModeInfo.IVFreq==", stModeInfo.IVFreq);
1268   3       //              CDebugMessage("stModeInfo.IVHeight==", stModeInfo.IVHeight);
1269   3       //              CDebugMessage("stModeInfo.IVStartPos==", stModeInfo.IVStartPos);
1270   3       //              CDebugMessage("stModeInfo.IVSyncPulseCount==", stModeInfo.IVSyncPulseCount);
1271   3                #endif
1272   3                  CSyncModifyPolarity();
1273   3      
1274   3                  stModeInfo.ModeCurr = _MODE_NOSIGNAL;
1275   3      
1276   3                  if(abs(stModeInfo.IHCount - hcount) <= 2)
1277   3                  {
1278   4                      stModeInfo.IHCount = hcount;
1279   4                  }
1280   3      
1281   3                  if(abs(stModeInfo.IVTotal - vtotal) <= 2)
1282   3                  {
1283   4                      stModeInfo.IVTotal = vtotal;
1284   4                  }
1285   3      
1286   3                  if((stModeInfo.IHCount != hcount) || (stModeInfo.IVTotal != vtotal) || (stModeInfo.Polarity !=
             - polaritytemp))
1287   3                  {
1288   4                      modetemp = _MODE_NOSIGNAL;
1289   4                  }
1290   3                  else
1291   3                  {
1292   4                      if((stModeInfo.IHFreq < _H_FREQ_MIN) || (stModeInfo.IHFreq > _H_FREQ_MAX) || (stModeInfo.I
             -VFreq < _V_FREQ_MIN) || (stModeInfo.IVFreq > _V_FREQ_MAX))
1293   4                      {
1294   5                          modetemp = _MODE_NOSUPPORT;
1295   5                      }
1296   4                      else
1297   4                      {
1298   5                          modetemp = _MODE_EXIST;
1299   5                      }
1300   4                  }
1301   3              }
1302   2              else
1303   2              {
1304   3                  modetemp = _MODE_NOSIGNAL;
1305   3              }
1306   2      
1307   2      #if(_SCALER_TYPE == _RTD2472D)
1308   2              if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) ||
1309   2                 (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) ||
1310   2                 (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) ||
1311   2                 (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_HDMI_PORT) ||
1312   2                 (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_DVI_PORT) ||
1313   2                 (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_DVI_I_PORT))
1314   2              {
1315   3                  CTimerDelayXms(50);
1316   3              }
1317   2      #endif
1318   2      
1319   2              // Wait mode stable and decide the mode type for current source
1320   2              if(modetemp != ucModeFound)
1321   2              {
1322   3                  ucModeFound = modetemp;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 23  

1323   3                  ucEvent1 = _INACTIVE_COUNTDOWN_EVENT;
1324   3                  CLR_MODESTABLE();
1325   3                  CTimerCountDownEventProc(&ucEvent1, 3, CModeStableCountDownEvent);
1326   3      
1327   3                  return _FALSE;
1328   3              }
1329   2              else
1330   2              {
1331   3      
1332   3                  CTimerCountDownEventProc(&ucEvent1, 3, CModeStableCountDownEvent);
1333   3      
1334   3                  if(GET_MODESTABLE())
1335   3                  {
1336   4                      if(ucModeFound == _MODE_EXIST)
1337   4                      {
1338   5                          CModeInterlaceCheck();
1339   5                          stModeInfo.ModeCurr = CModeSearchDisplayMode();
1340   5      
1341   5                          // Issac-0129-Fixed
1342   5                          if (GET_INPUTSOURCE_TYPE() == _SOURCE_DVI || GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
1343   5                          {
1344   6                              if (stModeInfo.IHWidth == 0 || stModeInfo.IVHeight == 0)
1345   6                              {
1346   7                                  ucModeFound = _MODE_NOSIGNAL;
1347   7                                  ucEvent1 = _INACTIVE_COUNTDOWN_EVENT;
1348   7                                  CLR_MODESTABLE();
1349   7                                  CTimerCountDownEventProc(&ucEvent1, 3, CModeStableCountDownEvent);
1350   7      
1351   7                                  return _FALSE;
1352   7                              }
1353   6                          }
1354   5                      }
1355   4                      else
1356   4                      {
1357   5                          stModeInfo.ModeCurr = ucModeFound;
1358   5                      }
1359   4      
1360   4                      return _TRUE;
1361   4                  }
1362   3                  else
1363   3                  {
1364   4                      return _FALSE;
1365   4                  }
1366   3              }
1367   2          }
1368   1          else
1369   1          {
1370   2              return _FALSE;
1371   2          }
1372   1      }
1373          
1374          //--------------------------------------------------
1375          // Description  : Check if mode is changed
1376          // Input Value  : None
1377          // Output Value : Return _TRUE if mode is changed
1378          //--------------------------------------------------
1379          bit CModeIsChange(void)
1380          {
1381   1          BYTE polaritytemp;
1382   1          WORD hcount, vtotal;
1383   1          polaritytemp = stModeInfo.Polarity;
1384   1          hcount = stModeInfo.IHCount;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 24  

1385   1          vtotal = stModeInfo.IVTotal;
1386   1      
1387   1      #if(_VIDEO_SUPPORT == _ON)
              
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VIDEO8)
                  {
                      if(CVideoIsChange())
                      {
                          return _TRUE;
                      }
                  }
              
              #endif
1398   1      
1399   1          if((GET_DEEPCOLORMODE()) && (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))//sephinroth 20080710
1400   1          {
1401   2              CScalerPageSelect(_PAGE2);
1402   2              CScalerRead( _P2_TMDS_DPC0_B4, 1, pData, _NON_AUTOINC);
1403   2              if( (pData[0] & 0x07) == 0x00)
1404   2              {
1405   3                  return _TRUE;
1406   3              }
1407   2          }
1408   1      
1409   1          // V016 VGA Patch Note (4) Modify 20100803 Start
1410   1          // Patch Reason : Modify YPbPr Timing display green when changing timing.
1411   1          /*
1412   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
1413   1          {
1414   1              if(CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, _BIT6 | _BIT5))
1415   1              {
1416   1                  return _TRUE;
1417   1              }
1418   1          }
1419   1          */
1420   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
1421   1          {
1422   2              // Report Input Source Change If Overflow,Stable Period or Stable Polarity Flag Changed.
1423   2              if((bit)(CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, (_BIT7 | _BIT6 | _BIT5))) == _TRUE)
1424   2              {
1425   3                  return _TRUE;
1426   3              }
1427   2          }
1428   1          // V016 VGA Patch Note (4) Modify 20100803 End
1429   1      
1430   1          if(CModeMeasureData())
1431   1          {
1432   2              if(abs(stModeInfo.IHCount - hcount) <= 2)
1433   2              {
1434   3                  stModeInfo.IHCount = hcount;
1435   3              }
1436   2      
1437   2              if(abs(stModeInfo.IVTotal - vtotal) <= 2)
1438   2              {
1439   3                  stModeInfo.IVTotal = vtotal;
1440   3              }
1441   2      
1442   2              if((stModeInfo.IHCount != hcount) || (stModeInfo.IVTotal != vtotal) || (stModeInfo.Polarity != pol
             -aritytemp))
1443   2              {
1444   3                  return _TRUE;
1445   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 25  

1446   2              else
1447   2              {
1448   3                  return _FALSE;
1449   3              }
1450   2          }
1451   1          else
1452   1          {
1453   2              return _TRUE;
1454   2          }
1455   1      
1456   1      }
1457          
1458          //--------------------------------------------------
1459          // Description  : Search display mode process
1460          // Input Value  : None
1461          // Output Value : Mode number
1462          //--------------------------------------------------
1463          BYTE CModeSearchDisplayMode(void)
1464          {
1465   1          BYTE modetemp;
1466   1      
1467   1          switch(GET_INPUTSOURCE_TYPE())
1468   1          {
1469   2              case _SOURCE_VGA:
1470   2      
1471   2                  modetemp = CModeSearchModeVGA();
1472   2                  break;
1473   2      
1474   2      #if(_YPBPR_SUPPORT == _ON)
1475   2      
1476   2              case _SOURCE_YPBPR:
1477   2                  modetemp = CYPbPrSearchMode();
1478   2                  break;
1479   2      
1480   2      #endif
1481   2      
1482   2      #if(_TMDS_SUPPORT == _ON)
1483   2              case _SOURCE_DVI:
1484   2              case _SOURCE_HDMI:
1485   2              case _SOURCE_DP:
1486   2                  modetemp = CModeSearchModeDVI();
1487   2                  break;
1488   2      
1489   2      #endif
1490   2      
1491   2      #if(_VIDEO_SUPPORT == _ON)
                      case _SOURCE_VIDEO8:
                          break;
              #endif
1495   2          }
1496   1      
1497   1          return modetemp;
1498   1      }
1499          
1500          //--------------------------------------------------
1501          // Description  : Search mode for VGA
1502          // Input Value  : None
1503          // Output Value : Mode number
1504          //--------------------------------------------------
1505          BYTE CModeSearchModeVGA(void)
1506          {
1507   1          BYTE modecnt = _MODE_NOSUPPORT;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 26  

1508   1          bit bOtherError = _FALSE;
1509   1          BYTE ucCheckModeResult = 0xFF;
1510   1      
1511   1          // V012 Modify 20100331 Start
1512   1          // V012 Patch Note (30) : Use mode search incorrect flag to skip SOD clock seeking in the auto stage t
             -o avoid one missing vertical line at the edge of the picture.
1513   1          g_bModeSearchIncorrectFlag = _FALSE;
1514   1          // V012 Modify 20100331 End
1515   1      
1516   1          // V013 VGA Patch Note (11) Modify 20100416 Start
1517   1          // Patch Reason : Add FIFO Mode Only to save EEPROM space.
1518   1          // Activate FIFO Mode Only to save EEPROM space with 63 FIFO modes only.
1519   1      #if(_FIFO_MODE_ONLY == _ON)
1520   1          g_ucFIFOModeNum = 0;
1521   1      #endif
1522   1          // V013 VGA Patch Note (11) Modify 20100416 End
1523   1      
1524   1          // V012 Modify 20100322 Start
1525   1          // V012 Patch Note (8) : Add OOR Table to indicate in which modes the display could show OOR directly.
1526   1          for(modecnt = 0; modecnt < _MAX_OOR_MODE_NUMBER; modecnt++)
1527   1          {
1528   2              if(CModeSearchOORModeVGA(modecnt) == _TRUE)
1529   2              {
1530   3                  return _MODE_NOSUPPORT;
1531   3              }
1532   2          }
1533   1          // V012 Modify 20100322 End
1534   1      
1535   1          if((CAutoMeasurePositionV(_MIN_NOISE_MARGIN) != _ERROR_SUCCESS))
1536   1          {
1537   2              g_usVStartPos = 0;
1538   2              g_usVEndPos = 0;
1539   2      
1540   2              // V014 VGA Patch Note (2) Modify 20100526 Start
1541   2              // Patch Reason : Use width/HTotal ratio to distinguish mode _MODE_1440x900_60HZ_RB and _MODE_1600
             -x900_60HZ_CVR.
1542   2              g_usHStartPos = 0;
1543   2              g_usHEndPos = 0;
1544   2              // V014 VGA Patch Note (2) Modify 20100526 End
1545   2          }
1546   1      
1547   1          if(((g_usVEndPos - g_usVStartPos + 1) >= stModeInfo.IVTotal) || (g_usVEndPos <= g_usVStartPos - 1))
1548   1          {
1549   2              g_usVStartPos = 0;
1550   2              g_usVEndPos = 0;
1551   2          }
1552   1      
1553   1          // V014 VGA Patch Note (2) Modify 20100526 Start
1554   1          // Patch Reason : Use width/HTotal ratio to distinguish mode _MODE_1440x900_60HZ_RB and _MODE_1600x900
             -_60HZ_CVR.
1555   1          if(((g_usHEndPos - g_usHStartPos + 1) >= stModeUserData.Clock) || (g_usHEndPos <= g_usHStartPos - 1))
1556   1          {
1557   2              g_usHStartPos = 0;
1558   2              g_usHEndPos = 0;
1559   2          }
1560   1          // V014 VGA Patch Note (2) Modify 20100526 End
1561   1      
1562   1          g_usCurrIVHeight = CModeIVHeightVerify(g_usVEndPos - g_usVStartPos + 1);
1563   1      
1564   1          SET_MODE_SEARCH_TYPE(_PRESET_MODE_TYPE);
1565   1      
1566   1          for(modecnt = 0; modecnt < _MAX_PRESET_MODE; modecnt++)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 27  

1567   1          {
1568   2              if(CModeComparePresetModeVGA(modecnt))
1569   2              {
1570   3                  ucCheckModeResult = CModeCheckModeVGA(modecnt);
1571   3      
1572   3                  if((g_usCurrIVHeight > tINPUTMODE_PRESET_TABLE[modecnt].IVHeight)
1573   3                  || ((ucCheckModeResult != _CHECK_MODE_ADC_SPEED_ERROR)
1574   3                   && (ucCheckModeResult != _CHECK_MODE_SUCCESS)))
1575   3                  {
1576   4                      bOtherError = _TRUE;
1577   4                      continue;
1578   4                  }
1579   3                  else if(ucCheckModeResult == _CHECK_MODE_ADC_SPEED_ERROR)
1580   3                  {
1581   4                      continue;
1582   4                  }
1583   3                  else
1584   3                  {
1585   4                      // V012 Modify 20100324 Start
1586   4                      // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items,
             - and to sync with Dell case.
1587   4                      ucCheckModeResult = CModeSearchAcceptivePresetModeVGA(modecnt);
1588   4      
1589   4                      if(ucCheckModeResult != modecnt)
1590   4                      {
1591   5                          if(CModeCheckModeVGA(ucCheckModeResult) == _CHECK_MODE_SUCCESS)
1592   5                          {
1593   6                              modecnt = ucCheckModeResult;
1594   6                          }
1595   5                      }
1596   4                      // V012 Modify 20100324 End
1597   4      
1598   4                      // V013 VGA Patch Note (11) Modify 20100416 Start
1599   4                      // Patch Reason : Add FIFO Mode Only to save EEPROM space.
1600   4                      // Activate FIFO Mode Only to save EEPROM space with 63 FIFO modes only.
1601   4      #if(_FIFO_MODE_ONLY == _ON)
1602   4                      CModeCheckFIFOModeVGA(modecnt);
1603   4      #endif
1604   4                      // V013 VGA Patch Note (11) Modify 20100416 End
1605   4                      return modecnt;
1606   4                  }
1607   3              }
1608   2          }
1609   1          if((modecnt >= _MAX_PRESET_MODE) && (bOtherError == _FALSE) && (ucCheckModeResult == _CHECK_MODE_ADC_S
             -PEED_ERROR))
1610   1          {
1611   2              return _MODE_NOSUPPORT;
1612   2          }
1613   1      
1614   1          modecnt = CModeSearchAcceptiveModeVGA();
1615   1      
1616   1      // V012 Modify 20100316 Start
1617   1      // V012 Patch Note (2) : Overscan function update.
1618   1      #if(_OVERSCAN_SUPPORT == _ON)
1619   1          g_ucUserModeCurr = modecnt;
1620   1      #endif
1621   1      // V012 Modify 20100316 End
1622   1      
1623   1          if((modecnt == _MODE_NOSIGNAL) || (modecnt == _MODE_NOSUPPORT))
1624   1          {
1625   2              return modecnt;
1626   2          }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 28  

1627   1      
1628   1          SET_MODE_SEARCH_TYPE(_USER_MODE_TYPE);
1629   1      
1630   1          modecnt = CModeCheckFIFOModeVGA(modecnt);
1631   1      
1632   1          return modecnt;
1633   1      
1634   1      }
1635          
1636          // V012 Modify 20100324 Start
1637          // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items, and to sync wit
             -h Dell case.
1638          /*
1639          //--------------------------------------------------
1640          // Description  : Compare preset VGA mode
1641          // Input Value  : Mode number
1642          // Output Value : Return _TRUE if the input mode number is correspondence
1643          //--------------------------------------------------
1644          bit CModeComparePresetModeVGA(BYTE ucModeCnt)
1645          {
1646              BYTE polarity=0, polaritytemp=0;
1647          
1648          #if(_HSYNC_DETECTION == _AUTO_RUN)
1649              polarity = ((stModeInfo.Polarity & ~_BIT0) | ( ! (((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00 :
             - _BIT0) ^ ((bit)CScalerGetBit(_STABLE_PERIOD_H_50, _BIT6) ? 0x00 : _BIT0))));
1650          #else
1651              polarity = ((stModeInfo.Polarity & ~_BIT0) | ((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00 : _BIT
             -0));
1652          #endif
1653          
1654              if(abs(stModeInfo.IVFreq - tINPUTMODE_PRESET_TABLE[ucModeCnt].IVFreq) > tINPUTMODE_PRESET_TABLE[ucMode
             -Cnt].IVFreqTolerance)
1655              {
1656                  return _FALSE;
1657              }
1658          
1659              if(abs(stModeInfo.IHFreq - tINPUTMODE_PRESET_TABLE[ucModeCnt].IHFreq) > tINPUTMODE_PRESET_TABLE[ucMode
             -Cnt].IHFreqTolerance)
1660              {
1661                  return _FALSE;
1662              }
1663          
1664              if(abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].IVTotal) > 1)
1665              {
1666                  return _FALSE;
1667              }
1668          
1669              if((bit)(polarity & _BIT0))
1670              {
1671                  if((bit)(polarity & _BIT1))
1672                  {
1673                      polaritytemp    = _SYNC_HP_VP;
1674                  }
1675                  else
1676                  {
1677                      polaritytemp    = _SYNC_HP_VN;
1678                  }
1679              }
1680              else
1681              {
1682                  if((bit)(polarity & _BIT1))
1683                  {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 29  

1684                      polaritytemp    = _SYNC_HN_VP;
1685                  }
1686                  else
1687                  {
1688                      polaritytemp    = _SYNC_HN_VN;
1689                  }
1690              }
1691          
1692              if((polaritytemp & tINPUTMODE_PRESET_TABLE[ucModeCnt].PolarityFlag) == 0x00)
1693              {
1694                  return _FALSE;
1695              }
1696          
1697              return _TRUE;
1698          
1699          }
1700          */
1701          //--------------------------------------------------
1702          // Description  : Compare preset VGA mode
1703          // Input Value  : Mode number
1704          // Output Value : Return _TRUE if the input mode number is correspondence
1705          //--------------------------------------------------
1706          bit CModeComparePresetModeVGA(BYTE ucModeCnt)
1707          {
1708   1          if(abs(stModeInfo.IVFreq - tINPUTMODE_PRESET_TABLE[ucModeCnt].IVFreq) > tINPUTMODE_PRESET_TABLE[ucMode
             -Cnt].IVFreqTolerance)
1709   1          {
1710   2              return _FALSE;
1711   2          }
1712   1      
1713   1          if(abs(stModeInfo.IHFreq - tINPUTMODE_PRESET_TABLE[ucModeCnt].IHFreq) > tINPUTMODE_PRESET_TABLE[ucMode
             -Cnt].IHFreqTolerance)
1714   1          {
1715   2              return _FALSE;
1716   2          }
1717   1      
1718   1          if((ucModeCnt == _MODE_1024x768_60HZ_MAC) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeC
             -nt].IVTotal) > 3))
1719   1          {
1720   2              return _FALSE;
1721   2          }
1722   1      
1723   1          if((ucModeCnt == _MODE_1280x800_60HZ) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].
             -IVTotal) > 3))
1724   1          {
1725   2              return _FALSE;
1726   2          }
1727   1      
1728   1          if((ucModeCnt == _MODE_1600x1200_60HZ) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt]
             -.IVTotal) > 2))
1729   1          {
1730   2              return _FALSE;
1731   2          }
1732   1      
1733   1          if((ucModeCnt == _MODE_1600x1200_60HZ_RB) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeC
             -nt].IVTotal) > 3))
1734   1          {
1735   2              return _FALSE;
1736   2          }
1737   1      
1738   1          if((ucModeCnt == _MODE_1360x768_60HZ) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].
             -IVTotal) > 2))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 30  

1739   1          {
1740   2              return _FALSE;
1741   2          }
1742   1      
1743   1          // V013 VGA Patch Note (24) Modify 20100514 Start
1744   1          // Patch Reason : Mode search updates.
1745   1          /*
1746   1          if((ucModeCnt == _MODE_720x480_60HZ) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].I
             -VTotal) > 2))
1747   1          */
1748   1          if((ucModeCnt == _MODE_720x480_60HZ) && (abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].I
             -VTotal) >= 2))
1749   1          // V013 VGA Patch Note (24) Modify 20100514 End
1750   1          {
1751   2              return _FALSE;
1752   2          }
1753   1      
1754   1          if(abs(stModeInfo.IVTotal - tINPUTMODE_PRESET_TABLE[ucModeCnt].IVTotal) > 3)
1755   1          {
1756   2              return _FALSE;
1757   2          }
1758   1      
1759   1          return _TRUE;
1760   1      }
1761          // V012 Modify 20100324 End
1762          
1763          // V012 Modify 20100324 Start
1764          // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items, and to sync wit
             -h Dell case.
1765          /*
1766          //--------------------------------------------------
1767          // Description  : Search an acceptive mode
1768          // Input Value  : None
1769          // Output Value : Mode number
1770          //--------------------------------------------------
1771          BYTE CModeSearchAcceptiveModeVGA(void)
1772          {
1773              BYTE acceptivemode = _MODE_NOSUPPORT;
1774          
1775              if(stModeInfo.IVTotal < 350)
1776              {
1777          
1778              }
1779              else if(stModeInfo.IVTotal < 488)              // 720x400 Mode : Vertical Line < 488
1780              {
1781                  if(stModeInfo.IVFreq < 790)
1782                  {
1783                      acceptivemode = _MODE_720x400_70HZ;
1784                  }
1785                  else
1786                  {
1787                      acceptivemode = _MODE_720x400_85HZ;
1788                  }
1789              }
1790              else if(stModeInfo.IVTotal < 610)              // 640x480 Mode : 488 <= Vertical Line < 610
1791              {
1792          
1793                  if(stModeInfo.IVFreq < 640)
1794                  {
1795                      acceptivemode = _MODE_640x480_60HZ;
1796                  }
1797                  else if(stModeInfo.IVFreq < 690)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 31  

1798                  {
1799                      acceptivemode = _MODE_640x480_66HZ;
1800                  }
1801                  else if(stModeInfo.IVFreq < 740)
1802                  {
1803                      acceptivemode = _MODE_640x480_72HZ;
1804                  }
1805                  else if(stModeInfo.IVFreq < 790)
1806                  {
1807                      acceptivemode = _MODE_640x480_75HZ;
1808                  }
1809                  else
1810                  {
1811                      acceptivemode = _MODE_640x480_85HZ;
1812                  }
1813              }
1814              else if(stModeInfo.IVTotal < 660)              // 800x600 Mode : 610 <= Vertical Line < 660
1815              {
1816                  if(stModeInfo.IVFreq < 580)
1817                  {
1818                      acceptivemode = _MODE_800x600_56HZ;
1819                  }
1820                  else if(stModeInfo.IVFreq < 660)
1821                  {
1822                      acceptivemode = _MODE_800x600_60HZ;
1823                  }
1824                  else if(stModeInfo.IVFreq < 740)
1825                  {
1826                      acceptivemode = _MODE_800x600_72HZ;
1827                  }
1828                  else if(stModeInfo.IVFreq < 790)
1829                  {
1830                      acceptivemode = _MODE_800x600_75HZ;
1831                  }
1832                  else
1833                  {
1834                      acceptivemode = _MODE_800x600_85HZ;
1835                  }
1836              }
1837              else if(stModeInfo.IVTotal < 732)              // 832x624 Mode : 660 <= Vertical Line < 732
1838              {
1839                  if(stModeInfo.IVFreq < 740)
1840                  {
1841                      acceptivemode = _MODE_800x600_72HZ;
1842                  }
1843                  else
1844                  {
1845                      acceptivemode = _MODE_832x624_75HZ;
1846                  }
1847              }
1848              else if(stModeInfo.IVTotal < 780)              // 1280x720 Mode : 732 <= Vertical Line < 780
1849              {
1850                  if(stModeInfo.IVFreq < 740)
1851                  {
1852                      acceptivemode = _MODE_1280x720_60HZ;
1853                  }
1854                  else
1855                  {
1856                      acceptivemode = _MODE_1280x720_75HZ;
1857                  }
1858              }
1859              else if(stModeInfo.IVTotal < 820)              // 1024x768/1280x768 Mode : 780 <= Vertical Line < 820
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 32  

1860              {
1861                  if(stModeInfo.IVFreq < 650)
1862                  {
1863                      acceptivemode = _MODE_1024x768_60HZ;//Confuse mode between 1024x768 and 1280x768
1864                  }
1865                      //acceptivemode = _MODE_1280x768_60HZ;
1866                  else if(stModeInfo.IVFreq < 730)
1867                  {
1868                      acceptivemode = _MODE_1024x768_70HZ;
1869                  }
1870                  else if(stModeInfo.IVFreq < 790)
1871                  {
1872                      acceptivemode = _MODE_1024x768_75HZ;
1873                  }
1874                  else
1875                  {
1876                      acceptivemode = _MODE_1024x768_85HZ;
1877                  }
1878              }
1879              else if(stModeInfo.IVTotal < 880)              // 1024x800 Mode : 820 <= Vertical Line < 880
1880              {
1881                  acceptivemode = _MODE_1024x800_85HZ;
1882              }
1883              else if(stModeInfo.IVTotal < 920)              // 1152x864/870 Mode : 880 <= Vertical Line < 920
1884              {
1885                  if(stModeInfo.IVFreq < 650)
1886                  {
1887                      acceptivemode = _MODE_1152x864_60HZ;
1888                  }
1889                  else if(stModeInfo.IVFreq < 740)
1890                  {
1891                      acceptivemode = _MODE_1152x864_70HZ;
1892                  }
1893                  else if(stModeInfo.IVFreq < 790)
1894                  {
1895                      if((stModeInfo.IHFreq > 679) && (stModeInfo.IHFreq < 697))
1896                      {
1897                          acceptivemode = _MODE_1152x870_75HZ;
1898                      }
1899                      else
1900                      {
1901                          acceptivemode = _MODE_1152x864_75HZ;
1902                      }
1903                  }
1904                      else
1905                  {
1906                      acceptivemode = _MODE_1152x864_85HZ;
1907                  }
1908              }
1909              else if(stModeInfo.IVTotal < 975)              // 1152x900/1440x900 Mode : 920 <= Vertical Line < 975
1910              {
1911                  if(stModeInfo.IVFreq < 660)
1912                  {
1913                      acceptivemode = _MODE_1440x900_60HZ;
1914                  }
1915                  else if(stModeInfo.IVFreq < 700)
1916                  {
1917                      acceptivemode = _MODE_1152x900_66HZ;
1918                  }
1919                  else if(stModeInfo.IVFreq < 760)
1920                  {
1921                      acceptivemode = _MODE_1440x900_75HZ;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 33  

1922                  }
1923                  else if(stModeInfo.IVFreq < 790)
1924                  {
1925                      acceptivemode = _MODE_1152x900_76HZ;
1926                  }
1927              }
1928              else if(stModeInfo.IVTotal < 1040)             // 1280x960 Mode : 975 <= Vertical Line < 1040
1929              {
1930                  if(stModeInfo.IVFreq < 650)
1931                  {
1932                      acceptivemode = _MODE_1280x960_60HZ;
1933                  }
1934                  else
1935                  {
1936                      acceptivemode = _MODE_1280x960_75HZ;
1937                  }
1938              }
1939              else if(stModeInfo.IVTotal < 1087)             // 1280x1024 Mode : 1040 <= Vertical Line < 1087
1940              {
1941                  if(stModeInfo.IVFreq < 680)
1942                  {
1943                      acceptivemode = _MODE_1280x1024_60HZ;// Confuse mode between 1280x1024_60HZ and 1680x1050_60HZ
             -_BR
1944                  }
1945                      //acceptivemode = _MODE_1680x1050_60HZ_BR;
1946                  else if(stModeInfo.IVFreq < 720)
1947                  {
1948                      acceptivemode = _MODE_1280x1024_70HZ;
1949                  }
1950                  else if(stModeInfo.IVFreq < 780)
1951                  {
1952                      acceptivemode = _MODE_1280x1024_75HZ;
1953                  }
1954                  else
1955                  {
1956                      acceptivemode = _MODE_1280x1024_85HZ;
1957                  }
1958              }
1959              else if(stModeInfo.IVTotal < 1110)             // 1680x1050 Mode : 1087 <= Vertical Line < 1110
1960              {
1961                  if(stModeInfo.IVFreq < 640)
1962                  {
1963                      acceptivemode = _MODE_1680x1050_60HZ;
1964                  }
1965                  else
1966                  {
1967                      acceptivemode = _MODE_1680x1050_75HZ;
1968                  }
1969              }
1970              else if(stModeInfo.IVTotal < 1200)             // 1920x1080 Mode : 1110 <= Vertical Line < 1200
1971              {
1972                  acceptivemode = _MODE_1920x1080_60HZ;
1973              }
1974              else if(stModeInfo.IVTotal < 1300)             // 1600x1200 Mode : 1200 <= Vertical Line < 1300
1975              {
1976                  if(stModeInfo.IVFreq < 630)
1977                  {
1978                      acceptivemode = _MODE_1600x1200_60HZ;//Confuse mode between 1600x1200 and 1920x1200
1979                  }
1980                  else if(stModeInfo.IVFreq < 680)
1981                  {
1982                      acceptivemode = _MODE_1600x1200_65HZ;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 34  

1983                  }
1984                  else if(stModeInfo.IVFreq < 720)
1985                  {
1986                      acceptivemode = _MODE_1600x1200_70HZ;
1987                  }
1988                  else if(stModeInfo.IVFreq < 780)
1989                  {
1990                      acceptivemode = _MODE_1600x1200_75HZ;
1991                  }
1992                  else
1993                  {
1994                      acceptivemode = _MODE_1600x1200_85HZ;
1995                  }
1996              }
1997          
1998              acceptivemode = CModeAdditionalSearch(acceptivemode);
1999          
2000              return acceptivemode;
2001          }
2002          */
2003          //--------------------------------------------------
2004          // Description  : Search an acceptive mode
2005          // Input Value  : None
2006          // Output Value : Mode number
2007          //--------------------------------------------------
2008          BYTE CModeSearchAcceptiveModeVGA(void)
2009          {
2010   1          BYTE ucAcceptiveModeIndex = _MODE_NOSUPPORT;
2011   1          BYTE ucPolarity = 0;
2012   1          BYTE ucPolaritytemp = 0;
2013   1          WORD usIHSyncpulseCnt = 0;
2014   1      
2015   1          // V012 Modify 20100331 Start
2016   1          // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock with
             - M2PLL.
2017   1          /*
2018   1          usIHSyncpulseCnt = stModeInfo.IHSyncPulseCount;
2019   1          */
2020   1          usIHSyncpulseCnt = (DWORD)stModeInfo.IHSyncPulseCount * _XTAL27000K / _INTERNAL_SYSTEM_CLK;
2021   1          // V012 Modify 20100331 End
2022   1      
2023   1      #if(_HSYNC_DETECTION == _AUTO_RUN)
2024   1          ucPolarity = ((stModeInfo.Polarity & ~_BIT0) | ( ! (((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00
             - : _BIT0) ^ ((bit)CScalerGetBit(_STABLE_PERIOD_H_50, _BIT6) ? 0x00 : _BIT0))));
2025   1      #else
                  ucPolarity = ((stModeInfo.Polarity & ~_BIT0) | ((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00 : _B
             -IT0));
              #endif
2028   1      
2029   1          if((bit)(ucPolarity & _BIT0))
2030   1          {
2031   2              if((bit)(ucPolarity & _BIT1))
2032   2              {
2033   3                  ucPolaritytemp = _SYNC_HP_VP;
2034   3              }
2035   2              else
2036   2              {
2037   3                  ucPolaritytemp = _SYNC_HP_VN;
2038   3              }
2039   2          }
2040   1          else
2041   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 35  

2042   2              if((bit)(ucPolarity & _BIT1))
2043   2              {
2044   3                  ucPolaritytemp = _SYNC_HN_VP;
2045   3              }
2046   2              else
2047   2              {
2048   3                  ucPolaritytemp = _SYNC_HN_VN;
2049   3              }
2050   2          }
2051   1      
2052   1      
2053   1          if( stModeInfo.IVTotal < 420 )
2054   1          {
2055   2      
2056   2          }
2057   1          else if( stModeInfo.IVTotal < 435 )
2058   1          {
2059   2              if( stModeInfo.IVFreq < 790 )
2060   2              {
2061   3                  ucAcceptiveModeIndex = _MODE_640x350_70HZ;
2062   3              }
2063   2          }
2064   1          else if(stModeInfo.IVTotal < 488)
2065   1          {
2066   2              if(ucPolaritytemp == _SYNC_HP_VN) // HP/VN
2067   2              {
2068   3                  if( stModeInfo.IVFreq < 790 )
2069   3                  {
2070   4                      ucAcceptiveModeIndex = _MODE_640x350_70HZ;
2071   4                  }
2072   3              }
2073   2              else
2074   2              {
2075   3                  if( stModeInfo.IVFreq < 600 )
2076   3                  {
2077   4                      ucAcceptiveModeIndex = _MODE_640x400_56HZ;
2078   4                  }
2079   3                  else if(stModeInfo.IVFreq < 790)
2080   3                  {
2081   4                      ucAcceptiveModeIndex = _MODE_720x400_70HZ;
2082   4                  }
2083   3                  else
2084   3                  {
2085   4                      ucAcceptiveModeIndex = _MODE_720x400_85HZ;
2086   4                  }
2087   3              }
2088   2          }
2089   1          else if(stModeInfo.IVTotal < 590) // 640x480 Mode : 488 <= Vertical Line < 610
2090   1          {
2091   2              if(ucPolaritytemp == _SYNC_HN_VP) // HN/VP
2092   2              {
2093   3                  if(stModeInfo.IVFreq < 650)
2094   3                  {
2095   4                      if(abs(usIHSyncpulseCnt - 94) <= 10)
2096   4                      {
2097   5                          ucAcceptiveModeIndex = _MODE_640x400_60HZ;
2098   5                      }
2099   4      
2100   4                      else
2101   4                      {
2102   5                          ucAcceptiveModeIndex = _MODE_720x480_60HZ;
2103   5                      }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 36  

2104   4                  }
2105   3                  else if(stModeInfo.IVFreq < 690)
2106   3                  {
2107   4                      ucAcceptiveModeIndex = _MODE_848x480_70HZ;
2108   4                  }
2109   3                  else if(stModeInfo.IVFreq < 740)
2110   3                  {
2111   4                      ucAcceptiveModeIndex = _MODE_848x480_72HZ;
2112   4                  }
2113   3                  else if(stModeInfo.IVFreq < 790)
2114   3                  {
2115   4                      ucAcceptiveModeIndex = _MODE_848x480_75HZ;
2116   4                  }
2117   3              }
2118   2              else
2119   2              {
2120   3                  if(stModeInfo.IVFreq < 530)
2121   3                  {
2122   4                      ucAcceptiveModeIndex = _MODE_640x480_50HZ;
2123   4                  }
2124   3                  else if(stModeInfo.IVFreq < 650)
2125   3                  {
2126   4                      if((abs(usIHSyncpulseCnt - 59) <= 10) && (ucPolaritytemp == _SYNC_HN_VN))
2127   4                      {
2128   5                          ucAcceptiveModeIndex = _MODE_720x480_60HZ_GTF;
2129   5                      }
2130   4                      else if((abs(usIHSyncpulseCnt - 80) <= 15) && ((ucPolaritytemp == _SYNC_HP_VP) || (ucPolar
             -itytemp == _SYNC_HN_VP)))
2131   4                      {
2132   5                      ucAcceptiveModeIndex = _MODE_848x480_60HZ;
2133   5                      }
2134   4                      else
2135   4                      {
2136   5                          ucAcceptiveModeIndex = _MODE_640x480_60HZ;
2137   5                      }
2138   4                  }
2139   3                  else if( stModeInfo.IVFreq < 690 )
2140   3                  {
2141   4                      ucAcceptiveModeIndex = _MODE_640x480_66HZ;
2142   4                  }
2143   3      
2144   3                  // V012 Modify 20100324 Start
2145   3                  // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items, and
             - to sync with Dell case.
2146   3                  /*
2147   3                  else if(stModeInfo.IVFreq < 720)
2148   3                  {
2149   3                      ucAcceptiveModeIndex = _MODE_640x480_70HZ;
2150   3                  }
2151   3                  */
2152   3                  // V012 Modify 20100324 End
2153   3      
2154   3                  else if( stModeInfo.IVFreq < 740 )
2155   3                  {
2156   4                      ucAcceptiveModeIndex = _MODE_640x480_72HZ;
2157   4                  }
2158   3                  else if( stModeInfo.IVFreq < 790 )
2159   3                  {
2160   4                      ucAcceptiveModeIndex = _MODE_640x480_75HZ;
2161   4                  }
2162   3                  else
2163   3                  {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 37  

2164   4                      ucAcceptiveModeIndex = _MODE_640x480_85HZ;
2165   4                  }
2166   3              }
2167   2          }
2168   1          else if( stModeInfo.IVTotal < 670 ) // 800x600 Mode : 610 <= Vertical Line < 660
2169   1          {
2170   2              if(ucPolaritytemp == _SYNC_HP_VP) // HP/VP
2171   2              {
2172   3                  if( stModeInfo.IVFreq < 580 )
2173   3                  {
2174   4                      ucAcceptiveModeIndex = _MODE_800x600_56HZ;
2175   4                  }
2176   3                  else if( stModeInfo.IVFreq < 660 )
2177   3                  {
2178   4                      ucAcceptiveModeIndex = _MODE_800x600_60HZ;
2179   4                  }
2180   3                  else if( stModeInfo.IVFreq < 740 )
2181   3                  {
2182   4                      if(abs(usIHSyncpulseCnt - 45) <= 3)
2183   4                      {
2184   5                          ucAcceptiveModeIndex = _MODE_800x600_75HZ;
2185   5                      }
2186   4                      else
2187   4                      {
2188   5                          ucAcceptiveModeIndex = _MODE_800x600_72HZ;
2189   5                      }
2190   4                  }
2191   3                  else if( stModeInfo.IVFreq < 790 )
2192   3                  {
2193   4                      if(abs(usIHSyncpulseCnt - 45) <= 3)
2194   4                      {
2195   5                          ucAcceptiveModeIndex = _MODE_800x600_75HZ;
2196   5                      }
2197   4                      else
2198   4                      {
2199   5                          ucAcceptiveModeIndex = _MODE_800x600_72HZ;
2200   5                      }
2201   4                  }
2202   3                  else
2203   3                  {
2204   4                      ucAcceptiveModeIndex = _MODE_800x600_85HZ;
2205   4                  }
2206   3              }
2207   2              else
2208   2              {
2209   3                  // V012 Modify 20100324 Start
2210   3                  // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items, and
             - to sync with Dell case.
2211   3                  /*
2212   3                  if(stModeInfo.IVFreq < 580)
2213   3                  {
2214   3                      ucAcceptiveModeIndex = _MODE_720x576_50HZ;
2215   3                  }
2216   3                  else if(stModeInfo.IVFreq < 660)
2217   3                  */
2218   3                  // V012 Modify 20100324 End
2219   3      
2220   3                  if(stModeInfo.IVFreq < 660)
2221   3                  {
2222   4                      ucAcceptiveModeIndex = _MODE_720x576_60HZ;
2223   4                  }
2224   3                  else if(stModeInfo.IVFreq < 790)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 38  

2225   3                  {
2226   4                      if(abs(usIHSyncpulseCnt - 29) <= 3)
2227   4                      {
2228   5                          ucAcceptiveModeIndex = _MODE_832x624_75HZ;
2229   5                      }
2230   4                      else
2231   4                      {
2232   5                          ucAcceptiveModeIndex = _MODE_720x576_75HZ;
2233   5                      }
2234   4                  }
2235   3              }
2236   2          }
2237   1          else if(stModeInfo.IVTotal < 760) // 1280x720 Mode : 732 <= Vertical Line < 780
2238   1          {
2239   2              if(stModeInfo.IVFreq < 660)
2240   2              {
2241   3                  ucAcceptiveModeIndex = _MODE_1280x720p_60HZ;
2242   3              }
2243   2              else if(stModeInfo.IVFreq < 710)
2244   2              {
2245   3                  ucAcceptiveModeIndex = _MODE_1280x720_70HZ;
2246   3              }
2247   2              else if(stModeInfo.IVFreq < 740)
2248   2              {
2249   3                  ucAcceptiveModeIndex = _MODE_1280x720_72HZ;
2250   3              }
2251   2              else
2252   2              {
2253   3                  ucAcceptiveModeIndex = _MODE_1280x720_75HZ;
2254   3              }
2255   2          }
2256   1          else if(stModeInfo.IVTotal < 797)
2257   1          {
2258   2              ucAcceptiveModeIndex = _MODE_1360x768_60HZ;
2259   2          }
2260   1          else if(stModeInfo.IVTotal < 820) // 1024x768 Mode : 780 <= Vertical Line < 881
2261   1          {
2262   2              if(stModeInfo.IVFreq < 580)
2263   2              {
2264   3                  if(abs(usIHSyncpulseCnt - 33) <= 5)
2265   3                  {
2266   4                      ucAcceptiveModeIndex = _MODE_1024x768_60HZ_MAC;
2267   4                  }
2268   3                  else
2269   3                  {
2270   4                      ucAcceptiveModeIndex = _MODE_1024x768_50HZ;
2271   4                  }
2272   3              }
2273   2              else if(stModeInfo.IVFreq < 630)
2274   2              {
2275   3                  if(abs(usIHSyncpulseCnt - 33) <= 5)
2276   3                  {
2277   4                      ucAcceptiveModeIndex = _MODE_1024x768_60HZ_MAC;
2278   4                  }
2279   3                  else if(abs(usIHSyncpulseCnt - 15) <= 3)
2280   3                  {
2281   4                      ucAcceptiveModeIndex = _MODE_1280x768_60HZ_RB;
2282   4                  }
2283   3                  else if(abs(usIHSyncpulseCnt - 40) <= 3)
2284   3                  {
2285   4                      ucAcceptiveModeIndex = _MODE_1280x768_60HZ;
2286   4                  }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 39  

2287   3                  else
2288   3                  {
2289   4                      ucAcceptiveModeIndex = _MODE_1024x768_60HZ;
2290   4                  }
2291   3              }
2292   2              else if( stModeInfo.IVFreq < 670 )
2293   2              {
2294   3                  ucAcceptiveModeIndex = _MODE_1024x768_66HZ;
2295   3              }
2296   2              else if( stModeInfo.IVFreq < 720 )
2297   2              {
2298   3                  ucAcceptiveModeIndex = _MODE_1024x768_70HZ;
2299   3              }
2300   2              else if(stModeInfo.IVFreq < 740)
2301   2              {
2302   3                  if(abs(usIHSyncpulseCnt - 33) <= 4)
2303   3                  {
2304   4                      ucAcceptiveModeIndex = _MODE_1024x768_75HZ;
2305   4                  }
2306   3                  else
2307   3                  {
2308   4                      ucAcceptiveModeIndex = _MODE_1024x768_72HZ;
2309   4                  }
2310   3              }
2311   2              else if( stModeInfo.IVFreq < 790 )
2312   2              {
2313   3                  if(ucPolaritytemp == _SYNC_HN_VN) // HN/VN
2314   3                  {
2315   4                      ucAcceptiveModeIndex = _MODE_1024x768_75HZ_MAC;
2316   4                  }
2317   3                  else
2318   3                  {
2319   4                      ucAcceptiveModeIndex = _MODE_1024x768_75HZ;
2320   4                  }
2321   3              }
2322   2              else
2323   2              {
2324   3                  if(ucPolaritytemp == _SYNC_HN_VP) // HN/VP
2325   3                  {
2326   4                      ucAcceptiveModeIndex = _MODE_1280x768_85HZ;
2327   4                  }
2328   3                  else
2329   3                  {
2330   4                      ucAcceptiveModeIndex = _MODE_1024x768_85HZ;
2331   4                  }
2332   3              }
2333   2          }
2334   1          else if(stModeInfo.IVTotal < 850) // 1024x768 Mode : 780 <= Vertical Line < 881
2335   1          {
2336   2              if(stModeInfo.IVFreq < 670)
2337   2              {
2338   3                  ucAcceptiveModeIndex = _MODE_1280x800_60HZ;
2339   3              }
2340   2              else if(stModeInfo.IVFreq < 710)
2341   2              {
2342   3                  ucAcceptiveModeIndex = _MODE_1280x800_70HZ;
2343   3              }
2344   2              else if(stModeInfo.IVFreq < 740)
2345   2              {
2346   3                  ucAcceptiveModeIndex = _MODE_1280x800_72HZ;
2347   3              }
2348   2              else
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 40  

2349   2              {
2350   3                  ucAcceptiveModeIndex = _MODE_1280x800_75HZ;
2351   3              }
2352   2          }
2353   1          else if(stModeInfo.IVTotal < 914) // 1152x864/870 Mode : 881 <= Vertical Line < 932
2354   1          {
2355   2              if( stModeInfo.IVFreq < 650 )
2356   2              {
2357   3                  ucAcceptiveModeIndex = _MODE_1152x864_60HZ;
2358   3              }
2359   2              else if( stModeInfo.IVFreq < 740 )
2360   2              {
2361   3                  ucAcceptiveModeIndex = _MODE_1152x864_70HZ;
2362   3              }
2363   2              else if(stModeInfo.IVFreq < 790)
2364   2              {
2365   3                  ucAcceptiveModeIndex = _MODE_1152x864_75HZ;
2366   3              }
2367   2              else
2368   2              {
2369   3                  ucAcceptiveModeIndex = _MODE_1152x864_85HZ;
2370   3              }
2371   2          }
2372   1          else if(stModeInfo.IVTotal < 920) // 1152x864/870 Mode : 881 <= Vertical Line < 932
2373   1          {
2374   2              ucAcceptiveModeIndex = _MODE_1152x870_75HZ;
2375   2          }
2376   1      
2377   1          else if(stModeInfo.IVTotal < 927)
2378   1          {
2379   2              ucAcceptiveModeIndex = _MODE_1440x900_60HZ_RB;
2380   2          }
2381   1          else if(stModeInfo.IVTotal < 935)
2382   1          {
2383   2              if( stModeInfo.IVFreq < 650)
2384   2              {
2385   3                  ucAcceptiveModeIndex = _MODE_1440x900_60HZ;
2386   3              }
2387   2              else if(stModeInfo.IVFreq < 790)
2388   2              {
2389   3                 ucAcceptiveModeIndex = _MODE_1440x900_75HZ;
2390   3              }
2391   2          }
2392   1          else if(stModeInfo.IVTotal < 938)
2393   1          {
2394   2              if(ucPolaritytemp == _SYNC_HN_VP)
2395   2              {
2396   3                  ucAcceptiveModeIndex = _MODE_1440x900_60HZ;
2397   3              }
2398   2              else if(ucPolaritytemp == _SYNC_HP_VP)
2399   2              {
2400   3                  ucAcceptiveModeIndex = _MODE_1152x900_66HZ;
2401   3              }
2402   2              else
2403   2              {
2404   3                  ucAcceptiveModeIndex = _MODE_1152x900_66HZ_S;
2405   3              }
2406   2          }
2407   1          else if(stModeInfo.IVTotal < 950)
2408   1          {
2409   2              if(stModeInfo.IVFreq < 780)
2410   2              {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 41  

2411   3                  ucAcceptiveModeIndex = _MODE_1440x900_75HZ;
2412   3              }
2413   2          }
2414   1          else if(stModeInfo.IVTotal < 1020) // 1280x960 Mode : 975 <= Vertical Line < 1040
2415   1          {
2416   2              if(stModeInfo.IVFreq < 660)
2417   2              {
2418   3                  ucAcceptiveModeIndex = _MODE_1280x960_60HZ;
2419   3              }
2420   2              else if(stModeInfo.IVFreq < 710)
2421   2              {
2422   3                  ucAcceptiveModeIndex = _MODE_1280x960_70HZ;
2423   3              }
2424   2              else if(stModeInfo.IVFreq < 730)
2425   2              {
2426   3                  ucAcceptiveModeIndex = _MODE_1280x960_72HZ;
2427   3              }
2428   2              else if( stModeInfo.IVFreq < 780 )
2429   2              {
2430   3                  ucAcceptiveModeIndex = _MODE_1280x960_75HZ;
2431   3              }
2432   2              else
2433   2              {
2434   3                  ucAcceptiveModeIndex = _MODE_1280x960_85HZ;
2435   3              }
2436   2          }
2437   1          else if(stModeInfo.IVTotal < 1085)
2438   1          {
2439   2              if(stModeInfo.IVFreq < 660)
2440   2              {
2441   3                  ucAcceptiveModeIndex = _MODE_1280x1024_60HZ;
2442   3              }
2443   2              else if(stModeInfo.IVFreq < 710)
2444   2              {
2445   3                  ucAcceptiveModeIndex = _MODE_1280x1024_70HZ;
2446   3              }
2447   2              else if(stModeInfo.IVFreq < 730)
2448   2              {
2449   3                  ucAcceptiveModeIndex = _MODE_1280x1024_72HZ;
2450   3              }
2451   2              else if( stModeInfo.IVFreq < 780 )
2452   2              {
2453   3                  ucAcceptiveModeIndex = _MODE_1280x1024_75HZ;
2454   3              }
2455   2              else
2456   2              {
2457   3                  ucAcceptiveModeIndex = _MODE_1280x1024_85HZ;
2458   3              }
2459   2          }
2460   1          else if(stModeInfo.IVTotal < 1100)
2461   1          {
2462   2              if(stModeInfo.IVFreq < 620)
2463   2              {
2464   3                  if(abs(usIHSyncpulseCnt - 11) <= 4)
2465   3                  {
2466   4                      ucAcceptiveModeIndex = _MODE_1680x1050_60HZ_RB;
2467   4                  }
2468   3                  else
2469   3                  {
2470   4                      ucAcceptiveModeIndex = _MODE_1680x1050_60HZ;
2471   4                  }
2472   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 42  

2473   2              else
2474   2              {
2475   3                  ucAcceptiveModeIndex = _MODE_1680x1050_75HZ;
2476   3              }
2477   2          }
2478   1          else if(stModeInfo.IVTotal < 1200)
2479   1          {
2480   2              if(stModeInfo.IVFreq < 520)
2481   2              {
2482   3                  ucAcceptiveModeIndex = _MODE_1920x1080p_50Hz;
2483   3              }
2484   2              else
2485   2              {
2486   3                  if(stModeInfo.IVTotal < 1110)
2487   3                  {
2488   4                      ucAcceptiveModeIndex = _MODE_1680x1050_60HZ;
2489   4                  }
2490   3                  else
2491   3                  {
2492   4                      // V014 VGA Patch Note (2) Modify 20100526 Start
2493   4                      // Patch Reason : Mode search update
2494   4                      /*
2495   4                      if(stModeInfo.IVTotal < 1118)
2496   4                      */
2497   4                      if(stModeInfo.IVTotal < 1117)
2498   4                      // V014 VGA Patch Note (2) Modify 20100526 End
2499   4                      {
2500   5                          ucAcceptiveModeIndex = _MODE_1920x1080_60HZ_RB;
2501   5                      }
2502   4                      else
2503   4                      {
2504   5                          ucAcceptiveModeIndex = _MODE_1920x1080_60HZ;
2505   5                      }
2506   4                  }
2507   3              }
2508   2          }
2509   1          else if(stModeInfo.IVTotal < 1248)
2510   1          {
2511   2              if(stModeInfo.IVFreq < 630)
2512   2              {
2513   3                  if(abs(usIHSyncpulseCnt - 9) <= 5)
2514   3                  {
2515   4                      ucAcceptiveModeIndex = _MODE_1920x1200_60HZ_RB;
2516   4                  }
2517   3                  else
2518   3                  {
2519   4                      ucAcceptiveModeIndex = _MODE_1920x1200_60HZ;
2520   4                  }
2521   3              }
2522   2          }
2523   1          else if(stModeInfo.IVTotal < 1300)
2524   1          {
2525   2              if( stModeInfo.IVFreq < 630 )
2526   2              {
2527   3                  if(abs(usIHSyncpulseCnt - 10) <= 5)
2528   3                  {
2529   4                      ucAcceptiveModeIndex = _MODE_1600x1200_60HZ_RB;
2530   4                  }
2531   3                  else
2532   3                  {
2533   4                      ucAcceptiveModeIndex = _MODE_1600x1200_60HZ;
2534   4                  }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 43  

2535   3              }
2536   2              else if( stModeInfo.IVFreq < 680 )
2537   2              {
2538   3                  ucAcceptiveModeIndex = _MODE_1600x1200_65HZ;
2539   3              }
2540   2              else
2541   2              {
2542   3                  ucAcceptiveModeIndex = _MODE_1600x1200_70HZ;
2543   3              }
2544   2          }
2545   1      
2546   1          ucAcceptiveModeIndex = CModeAdditionalSearch(ucAcceptiveModeIndex);
2547   1      
2548   1          return ucAcceptiveModeIndex;
2549   1      }
2550          // V012 Modify 20100324 End
2551          
2552          //--------------------------------------------------
2553          // Description  : Check FIFO mode for VGA
2554          // Input Value  : Mode number
2555          // Output Value : FIFO mode number
2556          //--------------------------------------------------
2557          BYTE CModeCheckFIFOModeVGA(BYTE ucModeCnt)
2558          {
2559   1          BYTE cnt0, cnt1;
2560   1          StructModeUserFIFODataType stFIFOModeTemp;
2561   1      
2562   1          // V013 VGA Patch Note (11) Modify 20100416 Start
2563   1          // Patch Reason : Add FIFO Mode Only to save EEPROM space.
2564   1          // Activate FIFO Mode Only to save EEPROM space with 63 FIFO modes only.
2565   1          /*
2566   1          for(cnt0 = 0; cnt0 < 4; cnt0++)
2567   1          {
2568   1              CEepromLoadUserFIFOModeData(cnt0, pData);
2569   1      
2570   1              for(cnt1 = 0; cnt1 < 4; cnt1++)
2571   1              {
2572   1                  if(CModeCompareFIFOModeVGA(cnt1, ucModeCnt) == _TRUE)
2573   1                  {
2574   1                      return (cnt0 * 4 + cnt1);
2575   1                  }
2576   1              }
2577   1          }
2578   1      
2579   1          if(stSystemData.UserFIFOMode >= 15)
2580   1          {
2581   1              stSystemData.UserFIFOMode = 0;
2582   1          }
2583   1          else
2584   1          {
2585   1              stSystemData.UserFIFOMode++;
2586   1          }
2587   1          */
2588   1      #if(_FIFO_MODE_ONLY == _ON)
2589   1          for(cnt0 = 0; cnt0 < 16; cnt0++)
2590   1          {
2591   2              CEepromLoadUserFIFOModeData(cnt0, pData);
2592   2      
2593   2              for(cnt1 = 0; cnt1 < 4; cnt1++)
2594   2              {
2595   3                  if(CModeCompareFIFOModeVGA(cnt1, ucModeCnt) == _TRUE)
2596   3                  {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 44  

2597   4                      g_ucFIFOModeNum = (cnt0 * 4 + cnt1);
2598   4                      return (cnt0 * 4 + cnt1);
2599   4                  }
2600   3              }
2601   2          }
2602   1      #else
                  for(cnt0 = 0; cnt0 < 4; cnt0++)
                  {
                      CEepromLoadUserFIFOModeData(cnt0, pData);
              
                      for(cnt1 = 0; cnt1 < 4; cnt1++)
                      {
                          if(CModeCompareFIFOModeVGA(cnt1, ucModeCnt) == _TRUE)
                          {
                              return (cnt0 * 4 + cnt1);
                          }
                      }
                  }
              #endif
2616   1      
2617   1      #if(_FIFO_MODE_ONLY == _ON)
2618   1          if(stSystemData.UserFIFOMode >= _MAX_FIFO_MODE_INDEX)
2619   1          {
2620   2              stSystemData.UserFIFOMode = 0;
2621   2          }
2622   1          else
2623   1          {
2624   2              stSystemData.UserFIFOMode++;
2625   2          }
2626   1      
2627   1          g_ucFIFOModeNum = stSystemData.UserFIFOMode;
2628   1      #else
                  if(stSystemData.UserFIFOMode >= 15)
                  {
                      stSystemData.UserFIFOMode = 0;
                  }
                  else
                  {
                      stSystemData.UserFIFOMode++;
                  }
              #endif
2638   1          // V013 VGA Patch Note (11) Modify 20100416 End
2639   1      
2640   1          stFIFOModeTemp.ModeNum = ucModeCnt;
2641   1          stFIFOModeTemp.IHFreq = stModeInfo.IHFreq;
2642   1          stFIFOModeTemp.IVFreq = stModeInfo.IVFreq;
2643   1          CEepromSaveUserFIFOModeData(stFIFOModeTemp);
2644   1      
2645   1          CLR_AUTO_FLAG();
2646   1          CLR_AUTO_FAIL_COUNT();
2647   1      
2648   1      // V014 VGA Patch Note (6) Modify 20100527 Start
2649   1      // Patch Reason : Modify Video Mode Can't Light On
2650   1      #if(_COLOR_FORMAT_CONVERT == _ON)
2651   1          CLR_MODE_COLOR_FORMAT_FLAG();
2652   1      #endif
2653   1      // V014 VGA Patch Note (6) Modify 20100527 End
2654   1      
2655   1          stModeUserData.HPosition = tINPUTMODE_PRESET_TABLE[ucModeCnt].IHStartPos;
2656   1          stModeUserData.VPosition = tINPUTMODE_PRESET_TABLE[ucModeCnt].IVStartPos;
2657   1          stModeUserData.Clock = tINPUTMODE_PRESET_TABLE[ucModeCnt].IHTotal;
2658   1          stModeUserData.Phase = 0;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 45  

2659   1          CEepromSaveModeData(stSystemData.UserFIFOMode);
2660   1      
2661   1          CEepromSaveSystemData();
2662   1      
2663   1          return stSystemData.UserFIFOMode;
2664   1      }
2665          
2666          //--------------------------------------------------
2667          // Description  : Compare mode in FIFO memory
2668          // Input Value  : Mode number and FIFO mode number
2669          // Output Value : _TRUE if both are correspondence
2670          //--------------------------------------------------
2671          bit CModeCompareFIFOModeVGA(BYTE ucNum, BYTE ucModeCnt)
2672          {
2673   1          StructModeUserFIFODataType stFIFOModeTemp;
2674   1      
2675   1          stFIFOModeTemp.ModeNum = (pData[ucNum * 4]);
2676   1          stFIFOModeTemp.IHFreq = ((WORD)(pData[ucNum * 4 + 1] & 0x0f) << 8) | pData[ucNum * 4 + 2];
2677   1      
2678   1          // V013 VGA Patch Note (11) Modify 20100416 Start
2679   1          // Patch Reason : Add FIFO Mode Only to save EEPROM space.
2680   1          // Activate FIFO Mode Only to save EEPROM space with 63 FIFO modes only.
2681   1          /*
2682   1          stFIFOModeTemp.IVFreq = ((WORD)(pData[ucNum * 4 + 1] & 0xf0) << 4) | pData[ucNum * 4 + 3];
2683   1          */
2684   1      #if(_FIFO_MODE_ONLY == _ON)
2685   1          stFIFOModeTemp.IVFreq = ((WORD)(pData[ucNum * 4 + 1] & 0x70) << 4) | pData[ucNum * 4 + 3];
2686   1      #else
                  stFIFOModeTemp.IVFreq = ((WORD)(pData[ucNum * 4 + 1] & 0xf0) << 4) | pData[ucNum * 4 + 3];
              #endif
2689   1      
2690   1          // V014 VGA Patch Note (2) Modify 20100528 Start
2691   1          // Patch Reason : Mode search update.
2692   1          // Mode Search Type should only be checked for FIFO Mode Only.
2693   1          /*
2694   1          if(GET_MODE_SEARCH_TYPE() != (bit)(pData[ucNum * 4 + 1] & 0x80))
2695   1          {
2696   1              return _FALSE;
2697   1          }
2698   1          */
2699   1      #if(_FIFO_MODE_ONLY == _ON)
2700   1          if(GET_MODE_SEARCH_TYPE() != (bit)(pData[ucNum * 4 + 1] & 0x80))
2701   1          {
2702   2              return _FALSE;
2703   2          }
2704   1      #endif
2705   1          // V014 VGA Patch Note (2) Modify 20100528 End
2706   1      
2707   1          // V013 VGA Patch Note (11) Modify 20100416 End
2708   1      
2709   1          if(stFIFOModeTemp.ModeNum != ucModeCnt)
2710   1          {
2711   2              return _FALSE;
2712   2          }
2713   1      
2714   1          if(abs(stModeInfo.IVFreq - stFIFOModeTemp.IVFreq) > tINPUTMODE_PRESET_TABLE[ucModeCnt].IVFreqTolerance
             -)
2715   1          {
2716   2              return _FALSE;
2717   2          }
2718   1      
2719   1          if(abs(stModeInfo.IHFreq - stFIFOModeTemp.IHFreq) > tINPUTMODE_PRESET_TABLE[ucModeCnt].IHFreqTolerance
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 46  

             -)
2720   1          {
2721   2              return _FALSE;
2722   2          }
2723   1      
2724   1          return _TRUE;
2725   1      }
2726          
2727          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
2728          //--------------------------------------------------
2729          // Description  : Search mode for DVI and HDMI
2730          // Input Value  : None
2731          // Output Value : Mode number
2732          //--------------------------------------------------
2733          BYTE CModeSearchModeDVI(void)
2734          {
2735   1          BYTE modecnt = 0 , temp = 0;
2736   1      
2737   1      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2472D))
2738   1      
2739   1      
2740   1          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D0_DP_PORT) && (GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D1
             -_DP_PORT))
2741   1          {
2742   2              if(CSyncCheckTMDSFreq() == _FALSE)
2743   2              {
2744   3                  CModeResetMode();
2745   3                  return _MODE_NOSIGNAL;
2746   3              }
2747   2      
2748   2              if((GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
2749   2              {
2750   3                  CScalerPageSelect(_PAGE2);
2751   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT3, _BIT3);
2752   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT1, 0x00);
2753   3                  CTimerDelayXms(5);
2754   3                  CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x02);
2755   3                  CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[0], _NON_AUTOINC);
2756   3      
2757   3                  if((pData[0] & 0x02) == 0x02)
2758   3                  {
2759   4                      CModeResetMode();
2760   4                      return _MODE_NOSIGNAL;
2761   4                  }
2762   3              }
2763   2      
2764   2              if(GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
2765   2              {
2766   3                  if(CHdmiFormatDetect() == _TRUE) // HDMI
2767   3                  {
2768   4                      CModeResetMode();
2769   4                      return _MODE_NOSIGNAL;
2770   4                  }
2771   3              }
2772   2              else if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
2773   2              {
2774   3                  if(CHdmiFormatDetect() == _FALSE) // DVI
2775   3                  {
2776   4                      CModeResetMode();
2777   4                      return _MODE_NOSIGNAL;
2778   4                  }
2779   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 47  

2780   2          }
2781   1      #endif
2782   1      
2783   1          stModeInfo.IHTotal = 0;
2784   1          stModeInfo.IVHeight = 0;
2785   1          stModeInfo.IHWidth = 0;
2786   1      
2787   1          CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, _BIT0); // Digital Measure
2788   1          CScalerPageSelect(_PAGE2);
2789   1          CScalerRead( _P2_TMDS_DPC0_B4, 1, &pData[3], _NON_AUTOINC);
2790   1          temp = pData[3] & 0x07;
2791   1      
2792   1          if(((temp == 0x05) || (temp == 0x06) || (temp == 0x07)) && (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)) /
             -/ deep color mode input
2793   1          {
2794   2      #if(_HDMI_SUPPORT == _ON)
                      CAdjustDeepColorMode();
              #endif
2797   2      
2798   2              CTimerDelayXms(5); //wait deep color PLL stable
2799   2      
2800   2              // Wait Phase Counter
2801   2              pData[15] = 0;
2802   2      
2803   2              do
2804   2              {
2805   3                  CScalerPageSelect(_PAGE2);
2806   3                  CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, 0x82, 0x18);
2807   3                  CTimerDelayXms(1);
2808   3                  CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, 0x82, 1, &pData[5], _NON_AUTOINC);
2809   3                  pData[15]++;
2810   3      
2811   3              }while(((pData[5] & 0x02) != 0) && (pData[15] < 10));
2812   2      
2813   2              if(pData[15] >= 10)
2814   2              {
2815   3                  CModeResetMode();
2816   3                  return _MODE_NOSIGNAL;
2817   3              }
2818   2      
2819   2              SET_DEEPCOLORMODE();
2820   2      
2821   2      #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      CAdjustDither(tDITHER_SEQ_TABLE_0, tDITHER_TABLE_10_TO_8_I_DOMAIN, tDITHER_TEMPOFFSET_TABLE, _INPU
             -T_DITHER); //I Domain Dithering
              #endif
2824   2      
2825   2              CScalerPageSelect(_PAGE2);
2826   2              CScalerSetByte(_P2_UP_DOWN_CTRL0_B5, 0xd8);
2827   2      
2828   2              CAdjustSyncProcessorMeasureStart();
2829   2      
2830   2              if(CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent))
2831   2              {
2832   3                  CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT6, _BIT6);
2833   3                  CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, 0x00);
2834   3                  CScalerRead(_MEAS_HS_PERIOD_H_52, 6, &pData[8], _AUTOINC);
2835   3      
2836   3                  ((WORD *)pData)[0] = ((pData[8] & 0x0f) << 8) | pData[9];
2837   3                  ((WORD *)pData)[1] = ((pData[10] & 0x0f) << 8) | pData[11];
2838   3                  ((WORD *)pData)[2] = ((pData[12] & 0xf0) << 4) | pData[13];
2839   3      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 48  

2840   3                  if((((WORD *)pData)[0] == 0) || (((WORD *)pData)[1] == 0) || (bit)(pData[10] & _BIT5))
2841   3                  {
2842   4                      modecnt = _MODE_NOSUPPORT;
2843   4                  }
2844   3                  else
2845   3                  {
2846   4                      // Save IH_TOTAL
2847   4                      stModeInfo.IHTotal = ((WORD *)pData)[0] + 1;
2848   4      
2849   4                      // Save input data enable width and height
2850   4                      stModeInfo.IVHeight = ((WORD *)pData)[1] + 1;
2851   4                      stModeInfo.IHWidth = ((WORD *)pData)[2] + 1;
2852   4      
2853   4                      for(modecnt = 0; modecnt < _MAX_PRESET_MODE; modecnt++)
2854   4                      {
2855   5                          if(CModeCompareModeDVI(modecnt))
2856   5                          {
2857   6                              break;
2858   6                          }
2859   5                      }
2860   4      
2861   4      #if(_TMDS_SHRINK_SUPPORT == _ON)
                              stModeInfo.IVHeight = stModeInfo.IVHeight - (_TMDS_SHRINK_RANGE * 2);
                              stModeInfo.IHWidth = stModeInfo.IHWidth - (_TMDS_SHRINK_RANGE * 2);
              #endif  // End of  #if(_TMDS_SHRINK_SUPPORT == _ON)
2865   4                  }
2866   3              }
2867   2              else
2868   2              {
2869   3                  CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, 0x00);
2870   3                  modecnt = _MODE_NOSUPPORT;
2871   3              }
2872   2      
2873   2          }
2874   1          else // 24 bit input including HDMI or DVI format !!
2875   1          {
2876   2      
2877   2              CLR_DEEPCOLORMODE();
2878   2      
2879   2              CAdjustSyncProcessorMeasureStart();
2880   2      
2881   2              if(CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent))
2882   2              {
2883   3                  CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT6, _BIT6);
2884   3                  CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, 0x00);
2885   3                  CScalerRead(_MEAS_HS_PERIOD_H_52, 6, &pData[8], _AUTOINC);
2886   3      
2887   3                  ((WORD *)pData)[0] = ((pData[8] & 0x0f) << 8) | pData[9];
2888   3                  ((WORD *)pData)[1] = ((pData[10] & 0x0f) << 8) | pData[11];
2889   3                  ((WORD *)pData)[2] = ((pData[12] & 0xf0) << 4) | pData[13];
2890   3      
2891   3                  if((((WORD *)pData)[0] == 0) || (((WORD *)pData)[1] == 0) || (bit)(pData[10] & _BIT5))
2892   3                  {
2893   4                      modecnt = _MODE_NOSUPPORT;
2894   4                  }
2895   3                  else
2896   3                  {
2897   4                      // Save IH_TOTAL
2898   4                      stModeInfo.IHTotal = ((WORD *)pData)[0] + 1;
2899   4      
2900   4                      // Save input data enable width and height
2901   4                      stModeInfo.IVHeight = ((WORD *)pData)[1] + 1;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 49  

2902   4                      stModeInfo.IHWidth = ((WORD *)pData)[2] + 1;
2903   4      
2904   4                      if(stModeInfo.IVHeight >= stModeInfo.IHWidth)
2905   4                      {
2906   5                          // V013 TMDS Patch Note (17) 20100422 Modify Start
2907   5                          // Patch Reason : Solve Dual Link DVI Issue.
2908   5                          /*
2909   5                          CModeResetMode();
2910   5                          */
2911   5                          if((stModeInfo.IHWidth == g_usIHWidthBackUp) && (stModeInfo.IVHeight == g_usIVHeightBa
             -ckUp))
2912   5                          {
2913   6                              g_ucNoSupportCnt++;
2914   6                          }
2915   5                          else
2916   5                          {
2917   6                              g_ucNoSupportCnt = 0;
2918   6                              g_usIHWidthBackUp = stModeInfo.IHWidth;
2919   6                              g_usIVHeightBackUp = stModeInfo.IVHeight;
2920   6                          }
2921   5      
2922   5                          if(g_ucNoSupportCnt >= 3)
2923   5                          {
2924   6                              modecnt = _MODE_NOSUPPORT;
2925   6                          }
2926   5                          else
2927   5                          {
2928   6                              CModeResetMode();
2929   6                          }
2930   5                          // V013 TMDS Patch Note (17) 20100422 Modify End
2931   5                      }
2932   4      
2933   4                      for(modecnt = 0; modecnt < _MAX_PRESET_MODE; modecnt++)
2934   4                      {
2935   5                          if(CModeCompareModeDVI(modecnt))
2936   5                          {
2937   6                              break;
2938   6                          }
2939   5                      }
2940   4      
2941   4      #if(_TMDS_SHRINK_SUPPORT == _ON)
                              stModeInfo.IVHeight = stModeInfo.IVHeight - (_TMDS_SHRINK_RANGE * 2);
                              stModeInfo.IHWidth = stModeInfo.IHWidth - (_TMDS_SHRINK_RANGE * 2);
              #endif  // End of  #if(_TMDS_SHRINK_SUPPORT == _ON)
2945   4                  }
2946   3              }
2947   2              else
2948   2              {
2949   3                  CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, 0x00);
2950   3                  modecnt = _MODE_NOSUPPORT;
2951   3              }
2952   2      
2953   2          }
2954   1      
2955   1          CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, 0x00); // Analog Measure
2956   1      
2957   1          // If no mode found, set to mode 0
2958   1          if(modecnt >= _MAX_PRESET_MODE)
2959   1          {
2960   2              modecnt = 0;
2961   2          }
2962   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 50  

2963   1          // We don't support input image large than 2048 active pixel or less than 240 active lines.
2964   1          // added deep color mode limitation
2965   1          if(GET_DEEPCOLORMODE())
2966   1          {
2967   2              CScalerPageSelect(_PAGE2);
2968   2              CScalerRead( _P2_TMDS_DPC0_B4, 1, &pData[3], _NON_AUTOINC);
2969   2              CTimerDelayXms(5);
2970   2      
2971   2              temp = pData[3] & 0x07;
2972   2              if(temp == 0x05)
2973   2              {  //30 bit 1920
2974   3                  if((stModeInfo.IHWidth > 2560) || (stModeInfo.IVHeight < 240))
2975   3                  {
2976   4                      modecnt = _MODE_NOSUPPORT;
2977   4                  }
2978   3              }
2979   2              else if(temp == 0x06)   //36 bit
2980   2              {
2981   3                  if((stModeInfo.IHWidth > 3072) || (stModeInfo.IVHeight < 240))
2982   3                  {
2983   4                      modecnt = _MODE_NOSUPPORT;
2984   4                  }
2985   3              }
2986   2              else if(temp == 0x07)     //48 bit
2987   2              {
2988   3                  if((stModeInfo.IHWidth > 4096) || (stModeInfo.IVHeight < 240))
2989   3                  {
2990   4                      modecnt = _MODE_NOSUPPORT;
2991   4                  }
2992   3              }
2993   2          }
2994   1          else
2995   1          {
2996   2              if((stModeInfo.IHWidth > 2048) || (stModeInfo.IVHeight < 240))
2997   2              {
2998   3                  modecnt = _MODE_NOSUPPORT;
2999   3              }
3000   2          }
3001   1      
3002   1          return modecnt;
3003   1      }
3004          
3005          //--------------------------------------------------
3006          // Description  : Compare mode for DVI
3007          // Input Value  : Mode number
3008          // Output Value : Retrun _TRUE if it's correspondence
3009          //--------------------------------------------------
3010          bit CModeCompareModeDVI(BYTE ucModeCnt)
3011          {
3012   1          if(abs(stModeInfo.IHWidth - tINPUTMODE_PRESET_TABLE[ucModeCnt].IHWidth) > 3)
3013   1          {
3014   2              return _FALSE;
3015   2          }
3016   1      
3017   1          if(stModeInfo.IVHeight != tINPUTMODE_PRESET_TABLE[ucModeCnt].IVHeight)
3018   1          {
3019   2              return _FALSE;
3020   2          }
3021   1      
3022   1          if(abs(stModeInfo.IVFreq - tINPUTMODE_PRESET_TABLE[ucModeCnt].IVFreq) > tINPUTMODE_PRESET_TABLE[ucMode
             -Cnt].IVFreqTolerance)
3023   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 51  

3024   2              return _FALSE;
3025   2          }
3026   1      
3027   1          return _TRUE;
3028   1      }
3029          #endif  // End of #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)||(_DP_SUPPORT == _ON))
3030          
3031          //----------------------------------------------------------------------------------------------------
3032          // Mode Display Functions
3033          //----------------------------------------------------------------------------------------------------
3034          
3035          //--------------------------------------------------
3036          // Description  : Display active mode process
3037          // Input Value  : None
3038          // Output Value : None
3039          //--------------------------------------------------
3040          void CModeDisplayActiveMode(void)
3041          {
3042   1          switch(GET_INPUTSOURCE_TYPE())
3043   1          {
3044   2              case _SOURCE_VGA:
3045   2      
3046   2      #if(_FRC_SUPPORT == _ON)
                          // RGB Input
                          SET_FRCRGBIN();
              #endif
3050   2                  CModeSetupModeVGA();
3051   2                  break;
3052   2      
3053   2      #if(_YPBPR_SUPPORT == _ON)
3054   2      
3055   2              case _SOURCE_YPBPR:
3056   2      #if(_FRC_SUPPORT == _ON)
                          // YUV Input
                          CLR_FRCRGBIN();
              #endif
3060   2                  CYPbPrSetupMode();
3061   2                  break;
3062   2      
3063   2      #endif
3064   2      
3065   2      #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
3066   2              case _SOURCE_DVI:
3067   2              case _SOURCE_HDMI:
3068   2              case _SOURCE_DP:
3069   2      #if(_FRC_SUPPORT == _ON)
                          // Input source is the HDMI format
                          if(!CHdmiFormatDetect())
                          {
                              // RGB Input
                              SET_FRCRGBIN();
                          }
              #endif
3077   2                  CModeSetupModeDVI();
3078   2                  break;
3079   2      #endif
3080   2      
3081   2      #if(_VIDEO_SUPPORT == _ON)
              
                      case _SOURCE_VIDEO8:
              #if(_FRC_SUPPORT == _ON)
                          // YUV Input
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 52  

                          CLR_FRCRGBIN();
              #endif
                          CVideoDisplaySet();
                          break;
              
              #endif
3092   2      
3093   2          }
3094   1      }
3095          
3096          //--------------------------------------------------
3097          // Description  : Setup VGA mode
3098          // Input Value  : None
3099          // Output Value : None
3100          //--------------------------------------------------
3101          void CModeSetupModeVGA(void)
3102          {
3103   1          BYTE option = 0;
3104   1      
3105   1          // Load mode user data from eeprom
3106   1          CEepromLoadModeData(stModeInfo.ModeCurr);
3107   1      
3108   1          // Get information from mode table, such as IHTotal, IHStartPos, IHWidth, IVStartPos, IVHeight.
3109   1          CModeGetModeTableInfo();
3110   1      
3111   1          // V016 VGA Patch Note (11) Modify 20100830 Start
3112   1          // Patch Reason : Modify Color Space Load Data Position For OverScan.
3113   1      #if(_COLOR_FORMAT_CONVERT == _ON)
3114   1          CModeGetCurrentModeColorFormat();
3115   1      #endif
3116   1          // V016 VGA Patch Note (11) Modify 20100830 End
3117   1      
3118   1          // V014 VGA Patch Note (6) Modify 20100527 Start
3119   1          // Patch Reason : Modify Video Mode Can't Light On
3120   1          CModeConfirmClampPositionSetting();
3121   1          // V014 VGA Patch Note (6) Modify 20100527 End
3122   1      
3123   1          CModeCheckUserData();
3124   1      
3125   1      // V012 Modify 20100317 Start
3126   1      // V012 Patch Note (9) : Remove safe mode.
3127   1      // Remove save mode on purpose, as there're still some issue with it.
3128   1      /*
3129   1      #if(_SAFE_MODE == _ON)
3130   1          if (stModeInfo.ModeCurr == _MODE_720x400_70HZ || stModeInfo.ModeCurr == _MODE_640x350_70HZ) //for 24w 
             -dos mode
3131   1          {
3132   1              CScalerSetBit(_VGIP_SIGINV_11, 0xff, 0x80);
3133   1              CScalerSetBit(_VGIP_ODD_CTRL_13, 0xff, 0x10);
3134   1          }
3135   1      #endif
3136   1      */
3137   1      // V012 Modify 20100317 End
3138   1      
3139   1          // Start up settings of VGA mode.
3140   1          CModeStartUpVGA();
3141   1      
3142   1      // V012 Modify 20100316 Start
3143   1      // V012 Patch Note (2) : Overscan function update.
3144   1      #if(_OVERSCAN_SUPPORT == _ON)
3145   1          CModeOverScanSelect();
3146   1      #endif
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 53  

3147   1      // V012 Modify 20100316 End
3148   1      
3149   1          // Get scaling option, Capture window setup, Scaling setup, Display setup
3150   1          CModeSetupDisplay();
3151   1      
3152   1          // Setup color processing
3153   1          CModeSetupColorProcess();
3154   1      
3155   1          CAdjustAdcGainOffset();
3156   1      
3157   1          CAdjustAdcClock(stModeUserData.Clock);
3158   1      
3159   1          CAdjustDcRestore();
3160   1      
3161   1          CAdjustHPosition();
3162   1      
3163   1          CAdjustVPosition();
3164   1      
3165   1          // V012 Modify 20100321 Start
3166   1          // V012 Patch Note (14) : Fix the issue that SOG interlace signal could not light up the display when 
             - V sync pulse is only 1H.
3167   1          CModeCheckDVTotal();
3168   1          // V012 Modify 20100321 End
3169   1      
3170   1          // V013 VGA Patch Note (16) Modify 20100422 Start
3171   1          // Patch Reason : Add fineTune display position for VGA interlace mode.
3172   1          CFrameSyncAnalogFineTune();
3173   1          // V013 VGA Patch Note (16) Modify 20100422 End
3174   1      
3175   1      #if(_FRC_SUPPORT == _ON)
                  if(!GET_FRCSTATUS())
                  {
                      CModeSetFIFOForFrameSync();
              #else
3180   1          {
3181   2      #endif
3182   2              pData[0] = CFrameSyncDo();
3183   2      
3184   2              if(pData[0] == 2)
3185   2              {
3186   3                  CModeResetMode();
3187   3                  return;
3188   3              }
3189   2          }
3190   1      
3191   1      #if((_MEMORY_WORK_TYPE == _OD_ON_FRC_ON) || (_MEMORY_WORK_TYPE == _OD_OFF_FRC_ON))
                  else
                  {
              #if(_FIELD_MERGE_SUPPORT == _ON)
                      if(GET_FIELDMERGE_MODE())
                      {
                          CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, _BIT4);
                      }
              #endif
                      // Disable video compensation & IVS-to-DVS-delay control by ODD when FRC
                      CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0);
                      CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, 0);
                  }
              #endif
3205   1      
3206   1          CAdjustADCClamp();
3207   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 54  

3208   1          CModeSetupEtcs(_FUNCTION_ENABLE);
3209   1      
3210   1      }
3211          
3212          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
3213          //--------------------------------------------------
3214          // Description  : Setup mode DVI
3215          // Input Value  : None
3216          // Output Value : None
3217          //--------------------------------------------------
3218          void CModeSetupModeDVI(void)
3219          {
3220   1          BYTE option = 0;
3221   1      
3222   1          // Do initial settings of DVI mode.
3223   1          CModeStartUpDVI();
3224   1      
3225   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_NONE)
3226   1          {
3227   2              return;
3228   2          }
3229   1      
3230   1      // V013 TMDS Patch Note (16) 20100422 Modify Start
3231   1      // Patch Reason : Solve DVI Interlace Issue.
3232   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
3233   1          {
3234   2              CScalerPageSelect(_PAGE2);
3235   2      
3236   2              if(CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7) // Digital Measure
3237   2              {
3238   3                  stModeInfo.IVTotal = stModeInfo.IVStartPos + stModeInfo.IVHeight + 37;
3239   3              }
3240   2          }
3241   1      // V013 TMDS Patch Note (16) 20100422 Modify End
3242   1      
3243   1      // V012 Modify 20100316 Start
3244   1      // V012 Patch Note (2) : Overscan function update.
3245   1      #if(_OVERSCAN_SUPPORT == _ON)
3246   1          CModeOverScanSelect();
3247   1      #endif
3248   1      // V012 Modify 20100316 End
3249   1      
3250   1          // Get scaling option, Capture window setup, Scaling setup, Display setup
3251   1          CModeSetupDisplay();
3252   1      
3253   1          // Setup color processing
3254   1          CModeSetupColorProcess();
3255   1      
3256   1          //Issac 2006-09-12
3257   1          if(GET_INTERLACE_MODE())
3258   1          {
3259   2      // V013 TMDS Patch Note (16) 20100422 Modify Start
3260   2      // Patch Reason : Solve DVI Interlace Issue.
3261   2              /*
3262   2              CScalerSetBit(_VGIP_ODD_CTRL_13, (~_BIT6 | _BIT0), _BIT6);
3263   2              */
3264   2              CScalerPageSelect(_PAGE2);
3265   2      
3266   2              if(CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7)
3267   2              {
3268   3                  CScalerSetBit(_VGIP_ODD_CTRL_13, ~(_BIT0), _BIT0);
3269   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 55  

3270   2              else
3271   2              {
3272   3                  CScalerSetBit(_VGIP_ODD_CTRL_13, ~(_BIT0), 0x00);
3273   3              }
3274   2      
3275   2              if(g_bIVSDelayOneLine == _TRUE)
3276   2              {
3277   3                  CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT6, _BIT6);
3278   3      
3279   3                  if(g_bIVSDelayOneLineInvert == _TRUE)
3280   3                  {
3281   4                      CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT7, _BIT7);
3282   4                  }
3283   3                  else
3284   3                  {
3285   4                      CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT7, 0x00);
3286   4                  }
3287   3              }
3288   2              else
3289   2              {
3290   3                  CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT6, 0x00);
3291   3              }
3292   2      
3293   2      // V013 TMDS Patch Note (16) 20100422 Modify End
3294   2      
3295   2      #if(_DP_SUPPORT == _ON)
                      if(GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
                      {
                          CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), _BIT7);
                      }
                      else
                      {
                          CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), (_BIT7 | _BIT6));
                      }
              #else
3305   2              CScalerSetBit(_SCALE_CTRL_32, ~(_BIT7 | _BIT6), (_BIT7 | _BIT6));
3306   2      #endif
3307   2      
3308   2      
3309   2      #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      CScalerPageSelect(_PAGE5);
                      CScalerSetBit(_P5_SDRF_IN1_SDR_CTRL_B9, ~_BIT7, _BIT7);//For interlace mode odd field toggle
              #endif
3313   2      
3314   2              CFrameSyncFineTune(_EVEN);
3315   2          }
3316   1      
3317   1      #if(_FRC_SUPPORT == _ON)
                  if(!GET_FRCSTATUS())
                  {
                      CModeSetFIFOForFrameSync();
              #else
3322   1          {
3323   2      #endif
3324   2              pData[0] = CFrameSyncDo();
3325   2      
3326   2              if(pData[0] == 2)
3327   2              {
3328   3                  CModeResetMode();
3329   3                  return;
3330   3              }
3331   2          }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 56  

3332   1      #if((_MEMORY_WORK_TYPE == _OD_ON_FRC_ON) || (_MEMORY_WORK_TYPE == _OD_OFF_FRC_ON))
                  else
                  {
              #if(_FIELD_MERGE_SUPPORT == _ON)
                      if(GET_FIELDMERGE_MODE())
                      {
                          CScalerSetBit(_VGIP_SIGINV_11, ~_BIT4, 0x00);
                      }
              #endif
                      // Disable video compensation & IVS-to-DVS-delay control by ODD when FRC
                      CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0x00);
                      CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, 0x00);
                  }
              #endif
3346   1      
3347   1          CAdjustTMDSCaptureCheck();
3348   1      
3349   1      #if(_TMDS_SHRINK_SUPPORT == _ON)
              #if(_SCALER_TYPE == 2472D)
                  CScalerRead(_IPH_ACT_STA_H_14, 2, pData, _AUTOINC);
                  ((WORD *)pData)[1] = (((WORD)(pData[0] & 0x07)) << 8) | pData[1];
                  CScalerRead(_IPV_ACT_STA_H_18, 2, pData, _AUTOINC);
                  ((WORD *)pData)[2] = (((WORD)(pData[0] & 0x07)) << 8) | pData[1];
              #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  CScalerRead(_IPH_ACT_STA_H_14, 1, &pData[0], _NON_AUTOINC);
                  CScalerRead(_IPH_ACT_WID_L_17, 1, &pData[1], _NON_AUTOINC);
                  ((WORD *)pData)[1] = (((WORD)(pData[0] & 0x0F)) << 8) | pData[1];
                  CScalerRead(_IPV_ACT_STA_H_18, 1, &pData[0], _NON_AUTOINC);
                  CScalerRead(_IPV_ACT_LEN_L_1B, 1, &pData[1], _NON_AUTOINC);
                  ((WORD *)pData)[2] = (((WORD)(pData[0] & 0x0F)) << 8) | pData[1];
              #else
                  No Setting !!
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
              
                  ((WORD *)pData)[1] = ((WORD *)pData)[1] + _TMDS_SHRINK_RANGE;
                  ((WORD *)pData)[2] = ((WORD *)pData)[2] + _TMDS_SHRINK_RANGE;
              #if(_SCALER_TYPE == 2472D)
                  CScalerSetByte(_IPH_ACT_STA_H_14, pData[2] & 0x07);
                  CScalerSetByte(_IPH_ACT_STA_L_15, pData[3]);
                  CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT2 | _BIT1 | _BIT0), pData[4] & 0x07);
              #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  CScalerSetByte(_IPH_ACT_STA_H_14, pData[2] & 0x0F);
                  CScalerSetByte(_IPH_ACT_STA_L_15, pData[3]);
                  CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), pData[4] & 0x0F);
              #else
                  No Setting !!
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
              
                  CScalerSetByte(_IPV_ACT_STA_L_19, pData[5]);
              
                  CScalerSetByte(_IVS2DVS_DELAY_LINES_40, _TMDS_SHRINK_RANGE);
              
              #endif  // End of #if(_TMDS_SHRINK_SUPPORT == _ON)
3385   1      
3386   1      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2472D))
3387   1          if((GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D0_DP_PORT) && (GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D1
             -_DP_PORT))
3388   1          {
3389   2              if(CSyncCheckTMDSFreq() == _FALSE)
3390   2              {
3391   3                  CModeResetMode();
3392   3                  return;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 57  

3393   3              }
3394   2      
3395   2              if((GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
3396   2              {
3397   3                  CScalerPageSelect(_PAGE2);
3398   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT3, _BIT3);
3399   3                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, 0x02, ~_BIT1, 0x00);
3400   3                  CTimerDelayXms(5);
3401   3                  CScalerSetByte(_P2_HDMI_ADDR_PORT_C9, 0x02);
3402   3                  CScalerRead(_P2_HDMI_DATA_PORT_CA, 1, &pData[0], _NON_AUTOINC);
3403   3      
3404   3                  if((pData[0] & 0x02) == 0x02)
3405   3                  {
3406   4                      CModeResetMode();
3407   4                      return;
3408   4                  }
3409   3              }
3410   2          }
3411   1      #endif
3412   1      
3413   1          CModeSetupEtcs(_FUNCTION_DISABLE);
3414   1      
3415   1      }
3416          #endif  // End of #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)||(_DP_SUPPORT == _ON))
3417          
3418          //--------------------------------------------------
3419          // Description  : Setup display
3420          // Input Value  : None
3421          // Output Value : None
3422          //--------------------------------------------------
3423          void CModeSetupDisplay(void)
3424          {
3425   1          BYTE option = 0;
3426   1      
3427   1          // Get scaling option
3428   1          option = CModeGetScaleSetting();
3429   1      
3430   1          // Capture window setup
3431   1          CModeSetCaptureWindow(option);
3432   1      
3433   1          // Scaling setup
3434   1          CModeSetScaling(option);
3435   1      
3436   1          // Display setup
3437   1          CModeSetDisplay(option);
3438   1      }
3439          
3440          //--------------------------------------------------
3441          // Description  : Setup contrast and brightness
3442          // Input Value  : None
3443          // Output Value : None
3444          //--------------------------------------------------
3445          void CModeSetupColorProcess(void)
3446          {
3447   1      #if(_YPBPR_SUPPORT == _ON)
3448   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
3449   1      #else
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
              #endif
3452   1          {
3453   2              CEepromLoadAdcData();
3454   2              #if _DEBUG_MESSAGE_SUPPORT
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 58  

3455   2              CDebugMessage("CEepromLoadAdcData", 0);
3456   2              CDebugMessage("stAdcData.AdcGain.[_RED]",stAdcData.AdcGain[_RED]);
3457   2              CDebugMessage("stAdcData.AdcGain.[_GREEN]",stAdcData.AdcGain[_GREEN]);
3458   2              CDebugMessage("stAdcData.AdcGain.[_BLUE]",stAdcData.AdcGain[_BLUE]);
3459   2              
3460   2              CDebugMessage("stAdcData.AdcOffset.[_RED]",stAdcData.AdcOffset[_RED]);
3461   2              CDebugMessage("stAdcData.AdcOffset.[_GREEN]",stAdcData.AdcOffset[_GREEN]);
3462   2              CDebugMessage("stAdcData.AdcOffset.[_BLUE]",stAdcData.AdcOffset[_BLUE]);
3463   2              #endif
3464   2          }
3465   1      
3466   1      
3467   1      #if(_SWITCH_INPUT_SOURCE == _OFF)
3468   1      
3469   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
3470   1          {
3471   2              CScalerSetDataPortBit(_HW_ACCESS_PORT_60, _HW_WINDOW_CTRL0_0C, ~(_BIT7 | _BIT6 | _BIT3 | _BIT2), (
             -_BIT7 | _BIT6 | _BIT2));
3472   2              CScalerSetDataPortBit(_HW_ACCESS_PORT_60, _HW_WINDOW_CTRL1_0D, ~(_BIT7 | _BIT6), _BIT6);
3473   2          }
3474   1      
3475   1      #endif
3476   1      
3477   1          COsdDispColorProcess();
3478   1      
3479   1      }
3480          
3481          //--------------------------------------------------
3482          // Description  : Setup other setings for display
3483          // Input Value  : None
3484          // Output Value : None
3485          //--------------------------------------------------
3486          void CModeSetupEtcs(BYTE ucPar)
3487          {
3488   1          CMiscEnableDoubleBuffer();
3489   1      #if(_FRC_SUPPORT == _ON)
                  if(GET_FRCSTATUS())
                  {
                      CScalerSetBit(_WATCH_DOG_CTRL0_0C, ~(_BIT5 | _BIT4 | _BIT3), 0x00);
                      CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
                  }
                  else
              #endif
3497   1          {
3498   2              if((bit)CScalerGetBit(_VDISP_CTRL_28, _BIT3))
3499   2              {
3500   3                  CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
3501   3              }
3502   2          }
3503   1      
3504   1          CAdjustDigitalFilter(_PHASE_ACCESS_PORT, _PHASE_THD_0, _DIV_VALUE_2, ucPar);
3505   1          CAdjustDigitalFilter(_NEG_SMEAR_ACCESS_PORT, _SMEAR_RING_THD_4, _DIV_VALUE_1, ucPar); //KEN 2005/09/23
3506   1          CAdjustDigitalFilter(_MISMATCH_ACCESS_PORT, _MISMATCH_THD_0, _DIV_VALUE_0, ucPar);
3507   1          CAdjustDigitalFilter(_NOISE_REDUCTION_PORT, _NOISE_REDUCTION_THD_7, _DIV_VALUE_0, ucPar);
3508   1      
3509   1          CAdjustDigitalFilter(_YPBPR_ACCESS_PORT, _YPBPR_ENABLE, _DIV_VALUE_0, ucPar);
3510   1      
3511   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
3512   1          {
3513   2              g_usVTotalTemp = stModeInfo.IVTotal;
3514   2              g_ucVSyncPulseWidthTemp = stModeInfo.IVSyncPulseCount;
3515   2          }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 59  

3516   1      
3517   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
3518   1          {
3519   2              if(CScalerGetBit(_SYNC_CTRL_49, _BIT2) == 0x00)
3520   2              {
3521   3                  // Select Hsync Measure Source to DeHS or SeHS.
3522   3                  CScalerSetBit(_SYNC_CTRL_49, ~_BIT2, _BIT2);
3523   3      
3524   3                  if(CModeMeasureReady())
3525   3                  {
3526   4                      CModeMeasureData();
3527   4      
3528   4                      // V012 Modify 20100402 Start
3529   4                      // V012 Patch Note (29) : Fix the inaccurate Vfreq in OSD with SOG HORV/HEORV sync type.
3530   4                      g_ucCoastLineCnt = (BYTE)(abs(g_usVTotalTemp - stModeInfo.IVTotal));
3531   4                      // V012 Modify 20100402 End
3532   4                  }
3533   3              }
3534   2      
3535   2              // V013 VGA Patch Note (7) Modify 20100412 Start
3536   2              // Patch Reason : Adjust Coast Region.
3537   2              CAdjustCoastRegion();
3538   2              // V013 VGA Patch Note (7) Modify 20100412 End
3539   2          }
3540   1      
3541   1      
3542   1          // V013 VGA Patch Note (28) Modify 20100518 Start
3543   1          // Patch Reason : Change the CMiscClearStatusRegister() to be use timing.
3544   1          /*
3545   1          CMiscClearStatusRegister();
3546   1          */
3547   1          // V013 VGA Patch Note (28) Modify 20100518 End
3548   1      
3549   1      // V016 VGA Patch Note (11) Modify 20100830 Start
3550   1      // Patch Reason : Modify Color Space Load Data Position For OverScan.
3551   1      /*
3552   1      // V012 Modify 20100304 Start
3553   1      // V012 Patch Note (1) : Add RGB/YUV color space convert function.
3554   1      #if(_COLOR_FORMAT_CONVERT == _ON)
3555   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR) || (GET_INPUTSOURCE_TYPE() == _SOURCE_VGA))
3556   1          {
3557   1              if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
3558   1              {
3559   1                  g_bColorFormatStatus = _YUV_COLOR_FORMAT;
3560   1              }
3561   1              else
3562   1              {
3563   1                  g_bColorFormatStatus = _RGB_COLOR_FORMAT;
3564   1              }
3565   1          }
3566   1      
3567   1          // V014 VGA Patch Note (6) Modify 20100527 Start
3568   1          // Patch Reason : Modify Video Mode Can't Light On
3569   1          CModeGetCurrentModeColorFormat();
3570   1          // V014 VGA Patch Note (6) Modify 20100527 End
3571   1      
3572   1      #endif
3573   1      // V012 Modify 20100304 End
3574   1      */
3575   1      // V016 VGA Patch Note (11) Modify 20100830 End
3576   1      
3577   1          // V016 System Patch Note (31) Modify 20100909 Start
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 60  

3578   1          // Patch Reason : Open Spread Spectrum after display setting.
3579   1          CAdjustDclkSpreadSpectrumRange(_DCLK_SPREAD_RANGE);
3580   1          // V016 System Patch Note (31) Modify 20100909 End
3581   1      
3582   1          // V013 VGA Patch Note (28) Modify 20100518 Start
3583   1          // Patch Reason : Change the CMiscClearStatusRegister() to be use timing.
3584   1          CMiscClearStatusRegister();
3585   1          // V013 VGA Patch Note (28) Modify 20100518 End
3586   1      }
3587          
3588          //--------------------------------------------------
3589          // Description  : Get mode information from mode table
3590          // Input Value  : None
3591          // Output Value : None
3592          //--------------------------------------------------
3593          void CModeGetModeTableInfo(void)
3594          {
3595   1          BYTE modetemp;
3596   1      
3597   1          if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
3598   1          {
3599   2              modetemp = stModeInfo.ModeCurr;
3600   2          }
3601   1          else if(GET_MODE_SEARCH_TYPE() == _USER_MODE_TYPE)
3602   1          {
3603   2              CEepromLoadUserFIFOModeData((stModeInfo.ModeCurr / 4), pData);
3604   2      
3605   2              modetemp = pData[(stModeInfo.ModeCurr % 4) * 4];
3606   2          }
3607   1      
3608   1          // V016 VGA Patch Note (3) Modify 20100730 Start
3609   1          // Patch Reason : Modify 640x350_70 Timing to show blank on top and buttom.
3610   1          if(modetemp == _MODE_640x350_70HZ)
3611   1          {
3612   2              modetemp = _MODE_720x400_70HZ;
3613   2          }
3614   1          // V016 VGA Patch Note (3) Modify 20100730 End
3615   1      
3616   1          stModeInfo.IHTotal = tINPUTMODE_PRESET_TABLE[modetemp].IHTotal;
3617   1          stModeInfo.IHStartPos = tINPUTMODE_PRESET_TABLE[modetemp].IHStartPos;
3618   1          stModeInfo.IHWidth = tINPUTMODE_PRESET_TABLE[modetemp].IHWidth;
3619   1      
3620   1          stModeInfo.IVStartPos = tINPUTMODE_PRESET_TABLE[modetemp].IVStartPos;
3621   1          stModeInfo.IVHeight = tINPUTMODE_PRESET_TABLE[modetemp].IVHeight;
3622   1      
3623   1          CEepromLoadCenterModeData(stModeInfo.ModeCurr);
3624   1      }
3625          
3626          //--------------------------------------------------
3627          // Description  : Startup settings for VGA
3628          // Input Value  : None
3629          // Output Value : None
3630          //--------------------------------------------------
3631          void CModeStartUpVGA(void)
3632          {
3633   1          WORD pixelclock;
3634   1      
3635   1          CScalerPageSelect(_PAGE2);
3636   1          CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT4 | _BIT3 | _BIT2 | _BIT1 | _BIT0), 0x00);
3637   1          CScalerSetBit(_P2_TMDS_OUTPUT_CTRL_A6, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4 | _BIT3), 0x00);
3638   1      
3639   1          // To imporve the FIFO efficiency only when input data rate is slow, and display data rate is high.
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 61  

3640   1          CScalerSetBit(_VGIP_CTRL_10, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), _BIT0);
3641   1      
3642   1          // Calculate pixel clock rate (round to MHz)
3643   1          pixelclock = (((DWORD)stModeInfo.IHFreq * (DWORD)stModeInfo.IHTotal) * 2 / (1000 * 10));
3644   1          pixelclock = (pixelclock >> 1) + (pixelclock & 0x01);
3645   1      
3646   1          // ADC differential mode and Set ADC bandwidth to reduce high frequency noise
3647   1          CScalerPageSelect(_PAGE0);
3648   1          if(pixelclock < 38)
3649   1          {
3650   2              CScalerSetBit(_P0_ADC_RGB_CTRL_CE, ~(_BIT2 | _BIT1 | _BIT0), _BIT2);                    //75MHz
3651   2          }
3652   1          else if(pixelclock < 68)
3653   1          {
3654   2              CScalerSetBit(_P0_ADC_RGB_CTRL_CE, ~(_BIT2 | _BIT1 | _BIT0), (_BIT2 | _BIT0));          //150MHz
3655   2          }
3656   1          else if(pixelclock < 160)
3657   1          {
3658   2              CScalerSetBit(_P0_ADC_RGB_CTRL_CE, ~(_BIT2 | _BIT1 | _BIT0), (_BIT2 | _BIT1));          //300MHz
3659   2          }
3660   1          else
3661   1          {
3662   2              CScalerSetBit(_P0_ADC_RGB_CTRL_CE, ~(_BIT2 | _BIT1 | _BIT0), (_BIT2 | _BIT1 | _BIT0));  //500MHz
3663   2          }
3664   1      
3665   1          if(pixelclock < 50)
3666   1          {
3667   2              // V012 Modify 20100329 Start
3668   2              // V012 Patch Note (28) : Fix ADC configurations to reduce noise.
3669   2              /*
3670   2              CScalerSetByte(_P0_ADC_I_BAIS3_CA, 0x76);
3671   2              */
3672   2              CScalerSetByte(_P0_ADC_I_BAIS3_CA, 0x5A);
3673   2              // V012 Modify 20100329 End
3674   2      
3675   2          }
3676   1          else if(pixelclock < 200)
3677   1          {
3678   2              CScalerSetByte(_P0_ADC_I_BAIS3_CA, 0x5C);
3679   2          }
3680   1          else
3681   1          {
3682   2              CScalerSetByte(_P0_ADC_I_BAIS3_CA, 0x5E);
3683   2          }
3684   1      
3685   1          // V012 Modify 20100329 Start
3686   1          // V012 Patch Note (28) : Fix ADC configurations to reduce noise.
3687   1          // PGA Input GM Current 700uA
3688   1          CScalerSetBit(_P0_ADC_I_BAIS0_C7, ~(_BIT7 | _BIT6), (_BIT7 | _BIT6));
3689   1          CScalerSetBit(_P0_ADC_I_BAIS1_C8, ~(_BIT7 | _BIT6), _BIT7);
3690   1          // PGA Input offset Current 480uA
3691   1          CScalerSetBit(_P0_ADC_V_BIAS0_CC, ~(_BIT7 | _BIT6 | _BIT3 | _BIT2), (_BIT7 | _BIT6));
3692   1          // V012 Modify 20100329 End
3693   1      
3694   1          CScalerPageSelect(_PAGE1);
3695   1          // Phase interpolation control load modified.   Marvin 0812
3696   1          if(pixelclock < 50)
3697   1          {
3698   2              CScalerSetBit(_P1_PLL_PHASE_INTERPOLATION_B5, ~(_BIT7 | _BIT6), 0x00);
3699   2          }
3700   1          else
3701   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 62  

3702   2              CScalerSetBit(_P1_PLL_PHASE_INTERPOLATION_B5, ~(_BIT7 | _BIT6), _BIT6);
3703   2          }
3704   1      
3705   1          // Fine-tune R/G/B delay and enable the ADC frame-modulation
3706   1          CScalerPageSelect(_PAGE0);
3707   1          CScalerSetBit(_P0_ADC_RED_CTL_CF, ~(_BIT2 | _BIT1 | _BIT0), (_ADC_FINE_TUNE_DELAY_RED & 0x07));
3708   1          CScalerSetBit(_P0_ADC_GREEN_CTL_D0, ~(_BIT2 | _BIT1 | _BIT0), (_ADC_FINE_TUNE_DELAY_GREEN & 0x07));
3709   1      
3710   1          CScalerSetBit(_P0_ADC_BLUE_CTL_D1, ~(_BIT2 | _BIT1 | _BIT0), (_ADC_FINE_TUNE_DELAY_BLUE & 0x07));
3711   1      
3712   1      #if(_SCALER_TYPE == _RTD2472D)
3713   1          CScalerSetByte(_YUV2RGB_CTRL_9C, 0x00);
3714   1          CScalerSetByte(_YUV_RGB_ACCESS_9D, 0x00);
3715   1      
3716   1      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  CScalerSetByte(_YUV_RGB_CTRL_9C, 0x00);
                  CScalerSetByte(_YUV_RGB_COEF_DATA_9D, 0x00);
              #else
                  No Setting !!
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
3722   1      
3723   1          // HSYNC positive/negtive tracking
3724   1          CScalerPageSelect(_PAGE1);
3725   1          CScalerSetBit(_P1_PLL_DIV_CTRL_A0, ~_BIT7, 0x00);
3726   1      }
3727          
3728          #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_DP_SUPPORT == _ON))
3729          //--------------------------------------------------
3730          // Description  : Startup settings for DVI
3731          // Input Value  : None
3732          // Output Value : None
3733          //--------------------------------------------------
3734          void CModeStartUpDVI(void)
3735          {
3736   1      // V013 TMDS Patch Note (16) 20100422 Modify Start
3737   1      // Patch Reason : Solve DVI Interlace Issue.
3738   1          WORD usIVStartPos = 0;
3739   1          WORD usIVEndPos = 0;
3740   1          WORD usIVHieghtEven = 0;
3741   1          WORD usIVHieghtOdd = 0;
3742   1          WORD usIVBoundary = 0;
3743   1      // V013 TMDS Patch Note (16) 20100422 Modify End
3744   1      
3745   1          CScalerSetBit(_VGIP_HV_DELAY_1E, 0x0f, 0x00);
3746   1      
3747   1          CScalerSetBit(_VGIP_CTRL_10, ~(_BIT3 | _BIT2 | _BIT0), (_BIT2 | _BIT0));
3748   1      
3749   1          CTimerWaitForEvent(_EVENT_IVS);
3750   1      
3751   1      // V013 TMDS Patch Note (16) 20100422 Modify Start
3752   1      // Patch Reason : Solve DVI Interlace Issue.
3753   1          CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~_BIT0, 0x00); // Clear Auto
3754   1      // V013 TMDS Patch Note (16) 20100422 Modify End
3755   1      
3756   1          // V015 System Patch Note (6) Modify 20100630 Start
3757   1          // Patch Reason : Correct measure boundary extract bit setting according to each spec.
3758   1          /*
3759   1          pData[0] = HIBYTE(stModeInfo.IHTotal - 2);
3760   1          pData[1] = 0x02;
3761   1          pData[2] = LOBYTE(stModeInfo.IHTotal - 2);
3762   1          pData[3] = HIBYTE(stModeInfo.IVTotal - 2);
3763   1          pData[4] = 0x02;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 63  

3764   1          pData[5] = LOBYTE(stModeInfo.IVTotal - 2);
3765   1          */
3766   1          pData[0] = (HIBYTE(stModeInfo.IHTotal - 2) & 0x0F);
3767   1          pData[1] = 0x02;
3768   1          pData[2] = LOBYTE(stModeInfo.IHTotal - 2);
3769   1          pData[3] = (HIBYTE(stModeInfo.IVTotal - 2) & 0x0F);
3770   1          pData[4] = 0x02;
3771   1          pData[5] = LOBYTE(stModeInfo.IVTotal - 2);
3772   1          // V015 System Patch Note (6) Modify 20100630 End
3773   1      
3774   1      // V013 TMDS Patch Note (16) 20100422 Modify Start
3775   1      // Patch Reason : Solve DVI Interlace Issue.
3776   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI))
3777   1          {
3778   2              CScalerPageSelect(_PAGE2);
3779   2              if(CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7) // DE only mode: use Digital Measure
3780   2              {
3781   3                  CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, 0x00); // Analog Mode Measure
3782   3      
3783   3                  CAdjustSyncProcessorMeasureStart();
3784   3                  if(CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent))
3785   3                  {
3786   4                      // Pop up measurement result
3787   4                      CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT6, _BIT6);
3788   4                      CScalerSetBit(_MEAS_HS_VS_HI_SEL_58, ~_BIT0, 0x00);
3789   4      
3790   4                      CScalerRead(_MEAS_VS_PERIOD_H_54, 2, &pData[10], _AUTOINC);
3791   4                      ((WORD *)pData)[4] = ((pData[10] & 0x0f) << 8) | pData[11]; // Vtotal
3792   4      
3793   4                      usIVBoundary = (((WORD *)pData)[4] + 1);
3794   4      
3795   4                      // V015 System Patch Note (6) Modify 20100630 Start
3796   4                      // Patch Reason : Correct measure boundary extract bit setting according to each spec.
3797   4                      /*
3798   4                      pData[3] = HIBYTE(usIVBoundary - 2);
3799   4                      */
3800   4                      pData[3] = (HIBYTE(usIVBoundary - 2) & 0x0F);
3801   4                      // V015 System Patch Note (6) Modify 20100630 End
3802   4      
3803   4                      pData[5] = LOBYTE(usIVBoundary - 2);
3804   4      
3805   4                      CScalerSetBit(_SYNC_SELECT_47, ~_BIT0, _BIT0);   // Digital Mode Measure
3806   4                  }
3807   3                  else
3808   3                  {
3809   4                      CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT5, 0x00);
3810   4                      CModeResetMode();
3811   4                  }
3812   3              }
3813   2          }
3814   1      
3815   1          // Set Auto Function Horizontal & Vertical Boundary
3816   1          CScalerWrite(_H_BOUNDARY_H_70, 6, pData, _AUTOINC);
3817   1      
3818   1          // Get stModeInfo.IHStartPos & stModeInfo.IVStartPos
3819   1          if(((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)) && (GET_INTER
             -LACE_MODE()))
3820   1          {
3821   2              // Disable interlace compensation function
3822   2              CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT6, 0x00);
3823   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, 0x00);
3824   2              CScalerSetBit(_FS_DELAY_FINE_TUNING_43, ~_BIT1, 0x00);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 64  

3825   2      
3826   2              // Auto function only active when ODD signal is "0"
3827   2              CScalerSetBit(_AUTO_ADJ_CTRL0_7A, ~(_BIT7 | _BIT6 | _BIT1 | _BIT0), _BIT7);
3828   2      
3829   2              // Start Auto Function Tracking Function
3830   2              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~(_BIT7 | _BIT0), (_BIT7 | _BIT0));
3831   2      
3832   2              // Wait for finish:
3833   2              // Worst case: (1 / 50Hz = 20ms) x 4(Frames) = 80ms + 5ms Tolerance
3834   2              if(CTimerPollingEventProc(85, CMiscAutoMeasurePollingEvent))
3835   2              {
3836   3      
3837   3                  CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
3838   3      
3839   3                  CScalerPageSelect(_PAGE2);
3840   3                  // IDEN horizontal Start
3841   3                  stModeInfo.IHStartPos = ((((WORD)pData[3] & 0xf0) << 4) | (WORD)pData[4]) - ((CScalerGetBit(_P
             -2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7) ? 16 - 14 : 18 - 14);
3842   3      
3843   3                  // IDEN vertical Start
3844   3                  stModeInfo.IVStartPos = (((WORD)pData[0] & 0xf0) << 4) | (WORD)pData[1];
3845   3      
3846   3                  // IDEN vertical End
3847   3                  usIVEndPos = (((WORD)pData[0] & 0x0f) << 8) | (WORD)pData[2];
3848   3      
3849   3                  // IVHeight = IVEndPos  - IVStartPos
3850   3                  usIVHieghtEven = usIVEndPos - stModeInfo.IVStartPos;
3851   3              }
3852   2              else
3853   2              {
3854   3                  CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x00);
3855   3                  CModeResetMode();
3856   3              }
3857   2      
3858   2              // Auto function only active when ODD signal is "1"
3859   2              CScalerSetBit(_AUTO_ADJ_CTRL0_7A, ~(_BIT7 | _BIT6 | _BIT1 | _BIT0), (_BIT7 | _BIT6));
3860   2      
3861   2              // Start Auto Function Tracking Function
3862   2              CScalerSetBit(_AUTO_ADJ_CTRL1_7D, ~(_BIT7 | _BIT0), (_BIT7 | _BIT0));
3863   2      
3864   2              // Wait for finish:
3865   2              // Worst case: (1 / 50Hz = 20ms) x 4(Frames) = 80ms + 5ms Tolerance
3866   2              if(CTimerPollingEventProc(85, CMiscAutoMeasurePollingEvent))
3867   2              {
3868   3                  CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
3869   3      
3870   3                  // IDEN vertical Start
3871   3                  usIVStartPos = (((WORD)pData[0] & 0xf0) << 4) | (WORD)pData[1];
3872   3      
3873   3                  // IDEN vertical End
3874   3                  usIVEndPos = (((WORD)pData[0] & 0x0f) << 8) | (WORD)pData[2];
3875   3      
3876   3                  // IVHeight = IVEndPos  - IVStartPos
3877   3                  usIVHieghtOdd = usIVEndPos - usIVStartPos;
3878   3      
3879   3                  // Select min(stModeInfo.IVStartPos, usIVStartPos)
3880   3                  if(stModeInfo.IVStartPos > usIVStartPos) // 0x80 > 0xC0 -> delay one line & No invert
3881   3                  {
3882   4                      CScalerSetBit(_AUTO_ADJ_CTRL0_7A, ~(_BIT7 | _BIT6 | _BIT1 | _BIT0), (_BIT7 | _BIT6));
3883   4                      stModeInfo.IVStartPos = usIVStartPos;
3884   4                      g_bIVSDelayOneLine = _TRUE;
3885   4                      g_bIVSDelayOneLineInvert = _FALSE;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 65  

3886   4      
3887   4                  }
3888   3                  else if(stModeInfo.IVStartPos < usIVStartPos) // 0x80 < 0xC0 -> delay one line & Invert
3889   3                  {
3890   4                      CScalerSetBit(_AUTO_ADJ_CTRL0_7A, ~(_BIT7 | _BIT6 | _BIT1 | _BIT0), _BIT7);
3891   4                      g_bIVSDelayOneLine = _TRUE;
3892   4                      g_bIVSDelayOneLineInvert = _TRUE;
3893   4                  }
3894   3                  else // 0x80 = 0xC0 -> No need to delay one line
3895   3                  {
3896   4                      g_bIVSDelayOneLine = _FALSE;
3897   4                      g_bIVSDelayOneLineInvert = _FALSE;
3898   4                  }
3899   3      
3900   3                  // Select min(usIVHieght_1, usIVHieght_2)
3901   3                  if(usIVHieghtEven < usIVHieghtOdd)
3902   3                  {
3903   4                      stModeInfo.IVHeight = usIVHieghtEven + 1;
3904   4                  }
3905   3                  else if(usIVHieghtEven >= usIVHieghtOdd)
3906   3                  {
3907   4                      stModeInfo.IVHeight = usIVHieghtOdd + 1;
3908   4                  }
3909   3              }
3910   2              else
3911   2              {
3912   3                  CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x00);
3913   3                  CModeResetMode();
3914   3              }
3915   2          }
3916   1          else // Else of if(GET_INTERLACE_MODE())
3917   1          {
3918   2              // Measure Active Region H/V Start
3919   2              CModeMeasureHVActiveStart();
3920   2      
3921   2              if(g_bDoModeResetMode == _TRUE)
3922   2              {
3923   3                  CModeResetMode();
3924   3              }
3925   2          }
3926   1      
3927   1          /*
3928   1          if(CTimerPollingEventProc(50, CMiscAutoMeasurePollingEvent))
3929   1          {
3930   1              CScalerRead(_V_START_END_H_7E, 6, pData, _AUTOINC);
3931   1      
3932   1              // IDEN horizontal Start
3933   1              CScalerPageSelect(_PAGE2);
3934   1              stModeInfo.IHStartPos = ((((WORD)pData[3] & 0xf0) << 4) | (WORD)pData[4]) - ((CScalerGetBit(_P2_PO
             -WER_ON_OFF_CTRL_A7, _BIT7) == _BIT7) ? 16 - 14 : 18 - 14);
3935   1      
3936   1              // IDEN vertical Start
3937   1              stModeInfo.IVStartPos = (((WORD)pData[0] & 0xf0) << 4) | (WORD)pData[1];
3938   1          }
3939   1          else
3940   1          {
3941   1              CScalerSetByte(_AUTO_ADJ_CTRL1_7D, 0x00);
3942   1              CModeResetMode();
3943   1          }
3944   1          */
3945   1      // V013 TMDS Patch Note (16) 20100422 Modify End
3946   1      }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 66  

3947          #endif  // End of #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON)||(_DP_SUPPORT == _ON))
3948          
3949          //--------------------------------------------------
3950          // Description  : Get scaling information
3951          // Input Value  : None
3952          // Output Value : Scaling information
3953          //--------------------------------------------------
3954          BYTE CModeGetScaleSetting(void)
3955          {
3956   1          BYTE  option = 0;
3957   1          DWORD  ivheight;
3958   1      
3959   1      #if(_DISP_INFO_BY_MODE == _ON)
              
                  BYTE modetemp;
              
                  if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
                  {
                      modetemp = stModeInfo.ModeCurr;
                  }
                  else if(GET_MODE_SEARCH_TYPE() == _USER_MODE_TYPE)
                  {
                      CEepromLoadUserFIFOModeData((stModeInfo.ModeCurr / 4), pData);
              
                      modetemp = pData[(stModeInfo.ModeCurr % 4) * 4];
                  }
              
                  stDisplayInfo = tDISPLAY_PRESET_TABLE[modetemp];
              
              #else
3977   1      
3978   1          stDisplayInfo.DHWidth = _PANEL_DH_WIDTH;
3979   1          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
3980   1          stDisplayInfo.DHTotal = _PANEL_DH_TOTAL;
3981   1      
3982   1      // V012 Modify 20100316 Start
3983   1      // V012 Patch Note (2) : Overscan function update.
3984   1      /*
3985   1      #if (_HDMI_OVERSCAN == _ON)
3986   1      
3987   1          ucOverScanH = 0;
3988   1          ucOverScanV = 0;
3989   1      
3990   1          if ((GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI) ||
3991   1              (GET_INPUTSOURCE_TYPE() == _SOURCE_DVI) &&
3992   1              (CHdmiFormatDetect()))
3993   1          {
3994   1              // Decide V overscan
3995   1              if (stModeInfo.IVHeight == (480 / 2))
3996   1              {
3997   1                  ucOverScanV = 4;    // Just for example
3998   1              }
3999   1              else if (stModeInfo.IVHeight == (576 / 2))
4000   1              {
4001   1                  ucOverScanV = 5;    // Just for example
4002   1              }
4003   1              else if (stModeInfo.IVHeight == (480))
4004   1              {
4005   1                  ucOverScanV = 8;    // Just for example
4006   1              }
4007   1              else if (stModeInfo.IVHeight == (576))
4008   1              {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 67  

4009   1                  ucOverScanV = 10;   // Just for example
4010   1              }
4011   1              else if (stModeInfo.IVHeight == (720))
4012   1              {
4013   1                  ucOverScanV = 12;   // Just for example
4014   1              }
4015   1              else if (stModeInfo.IVHeight == (1080 / 2))
4016   1              {
4017   1                  ucOverScanV = 9;    // Just for example
4018   1              }
4019   1              else if (stModeInfo.IVHeight == (1080))
4020   1              {
4021   1                  ucOverScanV = 18;   // Just for example
4022   1              }
4023   1      
4024   1              // Decide H overscan
4025   1              if (stModeInfo.IHWidth == (720))
4026   1              {
4027   1                  ucOverScanH = 12;   // Just for example
4028   1              }
4029   1              else if (stModeInfo.IHWidth == (1280))
4030   1              {
4031   1                  ucOverScanH = 22;   // Just for example
4032   1              }
4033   1              else if (stModeInfo.IHWidth == (1440))
4034   1              {
4035   1                  ucOverScanH = 24;   // Just for example
4036   1              }
4037   1              else if (stModeInfo.IHWidth == (1920))
4038   1              {
4039   1                  ucOverScanH = 32;   // Just for example
4040   1              }
4041   1              else if (stModeInfo.IHWidth == (2880))
4042   1              {
4043   1                  ucOverScanH = 64;   // Just for example
4044   1              }
4045   1      
4046   1      #if(_MEMORY_WORK_TYPE != _OD_OFF_FRC_OFF)
4047   1              if(ucOverScanH % 8)
4048   1              {
4049   1                  ucOverScanH = ((ucOverScanH + 8) >> 3) << 3;
4050   1              }
4051   1      #endif
4052   1      
4053   1              // Code below is for checking if overscan setting is reasonable.
4054   1              // You can remove it if you have confidence that overscan setting is always suitable
4055   1              if (ucOverScanH > (stModeInfo.IHWidth / 32))
4056   1              {
4057   1                  ucOverScanH = stModeInfo.IHWidth / 32;
4058   1              }
4059   1              if (ucOverScanV > (stModeInfo.IVHeight / 32))
4060   1              {
4061   1                  ucOverScanV = stModeInfo.IVHeight / 32;
4062   1              }
4063   1      
4064   1              while (ucOverScanV != 0)
4065   1              {
4066   1                  ((DWORD *)pData)[0] = (DWORD)(stDisplayInfo.DHTotal) * (DWORD)stModeInfo.IHFreq * (DWORD)(stDi
             -splayInfo.DVHeight) / (stModeInfo.IVHeight - (2 * ucOverScanV)) / 10;
4067   1      
4068   1                  if (((DWORD *)pData)[0] >= (DWORD)_PANEL_PIXEL_CLOCK_MAX * 1000)
4069   1                  {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 68  

4070   1                      ucOverScanV -= 1;
4071   1                  }
4072   1                  else
4073   1                  {
4074   1                      break;
4075   1                  }
4076   1              }
4077   1              // End of checking
4078   1      
4079   1              stModeInfo.IHWidth  = stModeInfo.IHWidth - (2 * ucOverScanH);
4080   1              stModeInfo.IVHeight = stModeInfo.IVHeight - (2 * ucOverScanV);
4081   1          }
4082   1      #endif  // End of #if (_HDMI_OVERSCAN == _ON)
4083   1      */
4084   1      // V012 Modify 20100316 End
4085   1      
4086   1      #endif  // End of #if(_DISP_INFO_BY_MODE == _ON)
4087   1      
4088   1      
4089   1          CFrameSyncModifyDVStartPos(_DVSTART_POS_ADJUSTING);
4090   1      
4091   1          // Modify OSD Reference Position
4092   1          CScalerSetDataPortByte(_DISP_ACCESS_PORT_2A, _DISP_OSD_REFERENCE_DEN_21, stDisplayInfo.DVStartPos - 4)
             -;
4093   1      
4094   1      #if((_ASPECT_RATIO_SUPPORT == _OFF) && (_MEMORY_WORK_TYPE != _OD_OFF_FRC_OFF))
              
              #if(_FRC_SUPPORT == _ON)
                      CMemoryWorkingTypeDecide();
              #endif
              
              #elif((_ASPECT_RATIO_SUPPORT == _ON) && (_MEMORY_WORK_TYPE != _OD_OFF_FRC_OFF))
              
                      if (GET_DISP_RATIO() == DISP_ORIGINAL_SIZE)
                      {
                          if(stModeInfo.IHWidth < stDisplayInfo.DHWidth)
                          {
                              stDisplayInfo.DHWidth = stModeInfo.IHWidth;
                          }
              
                          if(GET_INTERLACE_MODE() && (stModeInfo.IVHeight < (stModeInfo.IHWidth / 2)))
                          {
                              if((stModeInfo.IVHeight * 2) < stDisplayInfo.DVHeight)
                              {
                                  stDisplayInfo.DVHeight = (stModeInfo.IVHeight * 2);
                              }
                              else if((stModeInfo.IVHeight * 1) < stDisplayInfo.DVHeight)
                              {
                                  stDisplayInfo.DVHeight = stModeInfo.IVHeight;
                              }
                          }
                          else
                          {
                              if((stModeInfo.IVHeight * 1) < stDisplayInfo.DVHeight)
                              {
                                  stDisplayInfo.DVHeight = stModeInfo.IVHeight;
                              }
                          }
                      }
                      else if (GET_DISP_RATIO() == DISP_FIXED_AR_IN)
                      {
                          ((DWORD *)pData)[0] = (DWORD)stModeInfo.IHWidth * _PANEL_DV_HEIGHT / stModeInfo.IVHeight;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 69  

                          ((DWORD *)pData)[1] = (DWORD)stModeInfo.IVHeight * _PANEL_DH_WIDTH / stModeInfo.IHWidth;
              
                          if(GET_INTERLACE_MODE() && (stModeInfo.IVHeight < (stModeInfo.IHWidth / 2)))
                          {
                              ((DWORD *)pData)[0] = ((DWORD *)pData)[0] / 2;
                              ((DWORD *)pData)[1] = ((DWORD *)pData)[1] * 2;
                          }
              
                          if (((DWORD *)pData)[0] <= _PANEL_DH_WIDTH)
                          {
                              // Screen is wider than image (FRC may be no need)
                              stDisplayInfo.DHWidth = ((DWORD *)pData)[0];
                              stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
              
                              stDisplayInfo.DHWidth &= 0xFFFE;   // For dual-port panel
                          }
                          else if (((DWORD *)pData)[1] <= _PANEL_DV_HEIGHT)
                          {
                              // Image is wider than screen (FRC needed)
                              stDisplayInfo.DHWidth = _PANEL_DH_WIDTH;
                              stDisplayInfo.DVHeight = ((DWORD *)pData)[1];
                          }
                          else
                          {
                              // Image is too big!!
                          }
                      }
              
              #if(_FRC_SUPPORT == _ON)
                      CMemoryWorkingTypeDecide();
              #endif
              
                      // Unable to do original-size-display, restore setting to full-screen-display
                      if ((stDisplayInfo.DVHeight < _PANEL_DV_HEIGHT) && (!GET_FRCSTATUS()))
                      {
                          stDisplayInfo.DHWidth = _PANEL_DH_WIDTH;
                          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
                      }
              
                      // Change DVStartPos to image V start position
                      if (stDisplayInfo.DVHeight < _PANEL_DV_HEIGHT)
                      {
                          stDisplayInfo.DVStartPos += (_PANEL_DV_HEIGHT - stDisplayInfo.DVHeight) / 2;
                      }
              
              #endif // End of #if((_ASPECT_RATIO_SUPPORT == _OFF) && (_MEMORY_WORK_TYPE != _OD_OFF_FRC_OFF))
4177   1      
4178   1      #if(_FIELD_MERGE_SUPPORT == _ON)
                      if(GET_FIELDMERGE_MODE())
                      {
                          ivheight = stModeInfo.IVHeight * 2;
                      }
                      else
                      {
                          ivheight = stModeInfo.IVHeight;
                      }
              #else
4188   1              ivheight = stModeInfo.IVHeight;
4189   1      #endif
4190   1      
4191   1      //    if(stModeInfo.IVHeight < stDisplayInfo.DVHeight)        option |= _BIT0;    // bit 0 : V scale-up
4192   1      //    if(stModeInfo.IVHeight > stDisplayInfo.DVHeight)        option |= _BIT1;    // bit 1 : V scale-down
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 70  

4193   1            if(ivheight < stDisplayInfo.DVHeight)
4194   1            {
4195   2                option |= _BIT0;    // bit 0 : V scale-up
4196   2            }
4197   1            if(ivheight > stDisplayInfo.DVHeight)
4198   1            {
4199   2                option |= _BIT1;    // bit 1 : V scale-down
4200   2            }
4201   1      
4202   1          if(stModeInfo.IHWidth < stDisplayInfo.DHWidth)
4203   1          {
4204   2              option |= _BIT2;    // bit 2 : H scale-up
4205   2          }
4206   1          if(stModeInfo.IHWidth > stDisplayInfo.DHWidth)
4207   1          {
4208   2              option |= _BIT3;    // bit 3 : H scale-down
4209   2          }
4210   1      
4211   1          return option;
4212   1      }
4213          
4214          //--------------------------------------------------
4215          // Description  : Set capture window
4216          // Input Value  : Scaling information
4217          // Output Value : None
4218          //--------------------------------------------------
4219          void CModeSetCaptureWindow(BYTE ucOption)
4220          {
4221   1          WORD usTemp = 0;
4222   1      
4223   1          // Calculate IHS delay and H Capture Start
4224   1          switch(GET_INPUTSOURCE_TYPE())
4225   1          {
4226   2              case _SOURCE_VGA:
4227   2      #if(_YPBPR_SUPPORT == _ON)
4228   2              case _SOURCE_YPBPR:
4229   2      #endif
4230   2                  // Cal H Capture Start as AdjustPhase
4231   2                  if(stModeUserCenterData.CenterHPos < (_IHS_START_BIAS * 4))
4232   2                  {
4233   3                      g_usHStartBias = (stModeUserCenterData.CenterHPos) / 2 - 2;
4234   3                      usTemp = (stModeUserCenterData.CenterHPos) / 2 + (stModeUserCenterData.CenterHPos % 2);
4235   3                  }
4236   2                  else
4237   2                  {
4238   3                      g_usHStartBias = _IHS_START_BIAS * 2;
4239   3                      usTemp = (stModeUserCenterData.CenterHPos - g_usHStartBias) - 2;
4240   3                  }
4241   2                  break;
4242   2      
4243   2              case _SOURCE_DVI:
4244   2              case _SOURCE_HDMI:
4245   2              case _SOURCE_DP:
4246   2              default:
4247   2                  g_usHStartBias = _IHS_START_BIAS;
4248   2                  usTemp = stModeInfo.IHStartPos + _CAPTURE_HDELAY - (g_usHStartBias + _PROGRAM_HDELAY);
4249   2      
4250   2                  // IHS delay must be less than IHS Start otherwise Input Hsync Error (CR[02]-Bit[5]) will be o
             -ccurred.
4251   2                  if(g_usHStartBias > (stModeInfo.IHStartPos + _CAPTURE_HDELAY - _PROGRAM_HDELAY - 16))
4252   2                  {
4253   3                      g_usHStartBias = (stModeInfo.IHStartPos + _CAPTURE_HDELAY - _PROGRAM_HDELAY - 16);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 71  

4254   3                  }
4255   2      
4256   2                  break;
4257   2          }
4258   1      
4259   1      #if(_FRC_SUPPORT == _ON)
              
                  // Get IVS delay
                  if(GET_FRCSTATUS())
                  {
                      g_ucVStartBias = stModeInfo.IVStartPos > (_PROGRAM_VDELAY + 4) ? stModeInfo.IVStartPos - (_PROGRAM
             -_VDELAY + 4) : 0;
                  }
                  else
                  {
                      g_ucVStartBias = 0;
                      g_ucVStartBias = CAdjustIVS2DVSDelay(ucOption);
                  }
              
              #else
4273   1      
4274   1          // Get IVS delay
4275   1          g_ucVStartBias = 0;
4276   1          g_ucVStartBias = CAdjustIVS2DVSDelay(ucOption);
4277   1      
4278   1      #endif  // End of #if(_FRC_SUPPORT == _ON)
4279   1      
4280   1          // IVS delay must be less than IVS Start otherwise Input Vsync Error (CR[02]-Bit[6]) will be occurred.
4281   1          if(g_ucVStartBias > stModeInfo.IVStartPos)
4282   1          {
4283   2              g_ucVStartBias = stModeInfo.IVStartPos;
4284   2          }
4285   1      
4286   1      #if(_SCALER_TYPE == _RTD2472D)
4287   1          // Set H Capture window
4288   1          CScalerSetBit(_IPH_ACT_STA_H_14, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(usTemp) & (_BIT2 | _BIT1 | _BIT0));
4289   1          CScalerSetByte(_IPH_ACT_STA_L_15, LOBYTE(usTemp));
4290   1          CScalerSetBit(_IPH_ACT_WID_H_16, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(stModeInfo.IHWidth) & (_BIT2 | _BIT1
             - | _BIT0));
4291   1          CScalerSetByte(_IPH_ACT_WID_L_17, LOBYTE(stModeInfo.IHWidth));
4292   1      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  // Set H Capture window
                  CScalerSetBit(_IPH_ACT_STA_H_14, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), HIBYTE(usTemp) & (_BIT3 | _BIT2 | _
             -BIT1 | _BIT0));
                  CScalerSetByte(_IPH_ACT_STA_L_15, LOBYTE(usTemp));
                  CScalerSetBit(_IPH_ACT_STA_H_14, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), (HIBYTE(stModeInfo.IHWidth) << 4));
                  CScalerSetByte(_IPH_ACT_WID_L_17, LOBYTE(stModeInfo.IHWidth));
              #else
                  No Setting !!
              #endif
4301   1      
4302   1          g_usCaptureStart = usTemp;
4303   1      
4304   1          // Calculate V Capture Start
4305   1          usTemp = stModeInfo.IVStartPos - (g_ucVStartBias + _PROGRAM_VDELAY);
4306   1      
4307   1          if((CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, _BIT0)) == _BIT0) // Capture Window Unlock
4308   1          {
4309   2              if((usTemp <= _ADJUST_APLL_STABLE_COUNT))
4310   2              {
4311   3                  if(g_ucVStartBias >= (_ADJUST_APLL_STABLE_COUNT + 1 - usTemp))
4312   3                  {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 72  

4313   4                      g_ucVStartBias = g_ucVStartBias - (_ADJUST_APLL_STABLE_COUNT + 1 - usTemp);
4314   4                      usTemp = stModeInfo.IVStartPos - (g_ucVStartBias + _PROGRAM_VDELAY);
4315   4                  }
4316   3              }
4317   2          }
4318   1      
4319   1      #if(_SCALER_TYPE == _RTD2472D)
4320   1          // Set V Capture window
4321   1          CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(usTemp) & (_BIT2 | _BIT1 | _BIT0));
4322   1          CScalerSetByte(_IPV_ACT_STA_L_19, LOBYTE(usTemp));
4323   1          CScalerSetBit(_IPV_ACT_LEN_H_1A, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(stModeInfo.IVHeight) & (_BIT2 | _BIT
             -1 | _BIT0));
4324   1          CScalerSetByte(_IPV_ACT_LEN_L_1B, LOBYTE(stModeInfo.IVHeight));
4325   1      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  // Set V Capture window
                  CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), HIBYTE(usTemp) & (_BIT3 | _BIT2 | _
             -BIT1 | _BIT0));
                  CScalerSetByte(_IPV_ACT_STA_L_19, LOBYTE(usTemp));
                  CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), (HIBYTE(stModeInfo.IVHeight) << 4))
             -;
                  CScalerSetByte(_IPV_ACT_LEN_L_1B, LOBYTE(stModeInfo.IVHeight));
              #endif
4332   1      
4333   1      // V012 Modify 20100316 Start
4334   1      // V012 Patch Note (2) : Overscan function update.
4335   1      #if(_OVERSCAN_SUPPORT == _ON)
4336   1          g_usCaptureStartV = usTemp;
4337   1      #endif
4338   1      // V012 Modify 20100316 End
4339   1      
4340   1          // Set internal input H sync delay
4341   1          CAdjustIHSDelay(g_usHStartBias + _PROGRAM_HDELAY);
4342   1      
4343   1          // Set internal input V sync delay
4344   1          CAdjustIVSDelay(g_ucVStartBias + _PROGRAM_VDELAY);
4345   1      
4346   1      }
4347          
4348          //--------------------------------------------------
4349          // Description  : Set scaling factor settings
4350          // Input Value  : Scaling information
4351          // Output Value : None
4352          //--------------------------------------------------
4353          void CModeSetScaling(BYTE ucOption)
4354          {
4355   1      
4356   1      #if(_FIELD_MERGE_SUPPORT == _ON)
                  if(GET_FIELDMERGE_MODE())
                  {
                      stModeInfo.IVHeight = stModeInfo.IVHeight * 2;
                  }
              #endif
4362   1      
4363   1          // Set window size before scale up
4364   1          if(ucOption & _BIT3)
4365   1          {
4366   2              // H scale-down
4367   2      #if(_SCALER_TYPE == _RTD2472D)
4368   2              pData[0] = (BYTE)((stDisplayInfo.DHWidth >> 4) & 0x70);
4369   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      pData[0] = (BYTE)((stDisplayInfo.DHWidth >> 4) & 0xF0);
              
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 73  

              #else
                  No Setting !!
              
              #endif// End of #if(_SCALER_TYPE == _RTD2472D)
4376   2      
4377   2              pData[1] = LOBYTE(stDisplayInfo.DHWidth);
4378   2          }
4379   1          else
4380   1          {
4381   2              // No H scale-down
4382   2      #if(_SCALER_TYPE == _RTD2472D)
4383   2              pData[0] = (BYTE)((stModeInfo.IHWidth >> 4) & 0x70);
4384   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      pData[0] = (BYTE)((stModeInfo.IHWidth >> 4) & 0xF0);
              
              #else
                  No Setting !!
              
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
4391   2              pData[1] = LOBYTE(stModeInfo.IHWidth);
4392   2          }
4393   1      
4394   1          if(ucOption & _BIT1)
4395   1          {
4396   2              // V scale-down
4397   2      #if(_SCALER_TYPE == _RTD2472D)
4398   2              pData[0] = pData[0] | (HIBYTE(stDisplayInfo.DVHeight) & 0x07);
4399   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      pData[0] = pData[0] | (HIBYTE(stDisplayInfo.DVHeight) & 0x0F);
              
              #else
                  No Setting !!
              
              #endif  // End of #if(_SCALER_TYPE == _RTD2472D)
4406   2              pData[2] = LOBYTE(stDisplayInfo.DVHeight);
4407   2          }
4408   1          else
4409   1          {
4410   2              // No V scale-down
4411   2      #if(_SCALER_TYPE == _RTD2472D)
4412   2              pData[0] = pData[0] | (HIBYTE(stModeInfo.IVHeight) & 0x07);
4413   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      pData[0] = pData[0] | (HIBYTE(stModeInfo.IVHeight) & 0x0F);
              
              #else
                  No Setting !!
              
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
4420   2              pData[2] = LOBYTE(stModeInfo.IVHeight);
4421   2          }
4422   1      
4423   1          CScalerSetByte(_FIFO_ACCESS_PORT_30, _FIFO_DWRWL_H_BSU_00);
4424   1          CScalerWrite(_FIFO_DATA_PORT_31, 3, pData, _NON_AUTOINC);
4425   1      
4426   1      #if(_FRC_SUPPORT == _ON)
                  ((WORD *)pData)[2] = ((pData[0] & 0xf0) << 4) | pData[1];
                  ((WORD *)pData)[3] = ((pData[0] & 0x0f) << 8) | pData[2];
              
                  if(GET_FRCSTATUS())
                  {
              #if(_FIELD_MERGE_SUPPORT == _ON)
                      if(GET_FIELDMERGE_MODE())
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 74  

                      {
                          CMemoryControlForFRC(((WORD *)pData)[2], ((WORD *)pData)[3] / 2);
                      }
                      else
                      {
                          CMemoryControlForFRC(((WORD *)pData)[2], ((WORD *)pData)[3]);
                      }
              #else
                      CMemoryControlForFRC(((WORD *)pData)[2], ((WORD *)pData)[3]);
              #endif
                  }
                  else
                  {
                      CScalerPageSelect(_PAGE5);
                      CScalerSetByte(_P5_SDRF_MN_PRERD_VST_H_BC, 0x00);
                      CScalerSetByte(_P5_SDRF_MN_PRERD_VST_L_BD, 0x00);
                      // Issac-03-30 (Very Important!!)
                      CScalerSetByte(_P5_SDRF_MN_PXL_NUM_H_BE, 0x00);
                      CScalerSetByte(_P5_SDRF_MN_PXL_NUM_L_BF, 0x00);
                  }
              #endif
4455   1      
4456   1          // Write sharpness coefficient for scale-up
4457   1          CAdjustSharpness(stOsdUserData.Sharpness);
4458   1      
4459   1          // Config scaling
4460   1          if(ucOption & _BIT1)
4461   1          {
4462   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT0, _BIT0);          // Turn on V scale-down
4463   2          }
4464   1          else
4465   1          {
4466   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT0, 0x00);           // Turn off V scale-down
4467   2          }
4468   1      
4469   1          if(ucOption & _BIT3)
4470   1          {
4471   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT1, _BIT1);          // Turn on H scale-down
4472   2          }
4473   1          else
4474   1          {
4475   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT1, 0x00);           // Turn off H scale-down
4476   2          }
4477   1      
4478   1          if(ucOption & _BIT0)
4479   1          {
4480   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT1, _BIT1);               // Turn on V scale-up
4481   2          }
4482   1          else
4483   1          {
4484   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT1, 0x00);                // Turn off V scale-up
4485   2          }
4486   1      
4487   1          if(ucOption & _BIT2)
4488   1          {
4489   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT0, _BIT0);               // Turn on H scale-up
4490   2          }
4491   1          else
4492   1          {
4493   2              CScalerSetBit(_SCALE_CTRL_32, ~_BIT0, 0x00);                // Turn off H scale-up
4494   2          }
4495   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 75  

4496   1      
4497   1      
4498   1       // Set scale-down coefficient for RTD2472D
4499   1          if(ucOption & _BIT3)    // H scale-down
4500   1          {
4501   2              // Data[12~15]
4502   2              ((DWORD *)pData)[3] = (DWORD)1 * 1048576 * stModeInfo.IHWidth;
4503   2              ((DWORD *)pData)[3] = (((DWORD *)pData)[3] % stDisplayInfo.DHWidth) ? ((((DWORD *)pData)[3] / stDi
             -splayInfo.DHWidth) + 1) : (((DWORD *)pData)[3] / stDisplayInfo.DHWidth);
4504   2      
4505   2              // H scale-down factor
4506   2              pData[4] = ((((DWORD *)pData)[3] * 16 / 1048576 - 16) & 0x3f);
4507   2              pData[5] = ((((DWORD *)pData)[3] >> 16) & 0xff);
4508   2              pData[6] = ((((DWORD *)pData)[3] >> 8) & 0xff);
4509   2              pData[7] = ((((DWORD *)pData)[3]) & 0xff);
4510   2      
4511   2          }
4512   1          else
4513   1          {
4514   2              pData[4] = 0x00;
4515   2              pData[5] = 0x10;
4516   2              pData[6] = 0x00;
4517   2              pData[7] = 0x00;
4518   2          }
4519   1      
4520   1          if(ucOption & _BIT1)    // V scale-down
4521   1          {
4522   2              // Data[12~15]
4523   2              ((DWORD *)pData)[3] = (DWORD)2 * 131072 * stModeInfo.IVHeight / stDisplayInfo.DVHeight;
4524   2              ((DWORD *)pData)[3] = (((DWORD *)pData)[3] >> 1) + (((DWORD *)pData)[3] & 0x01);
4525   2      
4526   2              // V scale-down factor
4527   2              pData[0] = ((((DWORD *)pData)[3] * 16 / 131072 - 16) & 0x3f);
4528   2              pData[1] = ((((DWORD *)pData)[3] >> 16) & 0x07);
4529   2              pData[2] = ((((DWORD *)pData)[3] >> 8) & 0xff);
4530   2              pData[3] = ((((DWORD *)pData)[3]) & 0xff);
4531   2      
4532   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT2, 0x00);    // Diable V scale-down compensation
4533   2          }
4534   1          else
4535   1          {
4536   2              pData[0] = 0x00;
4537   2              pData[1] = 0x02;
4538   2              pData[2] = 0x00;
4539   2              pData[3] = 0x00;
4540   2      
4541   2              CScalerSetBit(_SCALE_DOWN_CTRL_23, ~_BIT2, 0x00);    // Diable V scale-down compensation
4542   2          }
4543   1      
4544   1          CScalerSetByte(_SD_ACCESS_PORT_24, 0x80);
4545   1          CScalerWrite(_SD_DATA_PORT_25, 8, pData, _NON_AUTOINC);
4546   1          CScalerSetByte(_SD_ACCESS_PORT_24, 0x00);
4547   1      
4548   1      
4549   1          // Set scale-up coefficient
4550   1          if(ucOption & _BIT2)    // H scale-up
4551   1          {
4552   2              // Data[12~15]
4553   2              ((DWORD *)pData)[3] = (DWORD)2 * 1048576 * stModeInfo.IHWidth / stDisplayInfo.DHWidth;
4554   2              ((DWORD *)pData)[3] = (((DWORD *)pData)[3] >> 1) + (((DWORD *)pData)[3] & 0x01);
4555   2      
4556   2              pData[0] = ((((DWORD *)pData)[3] >> 16) & 0x0f);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 76  

4557   2              pData[1] = ((((DWORD *)pData)[3] >> 8) & 0xff);
4558   2              pData[2] = ((((DWORD *)pData)[3]) & 0xff);
4559   2          }
4560   1          else
4561   1          {
4562   2              pData[0] = 0x0f;
4563   2              pData[1] = 0xff;
4564   2              pData[2] = 0xff;
4565   2          }
4566   1      
4567   1          if(ucOption & _BIT0)    // V scale-up
4568   1          {
4569   2              // Data[12~15]
4570   2              ((DWORD *)pData)[3] = (DWORD)2 * 1048576 * stModeInfo.IVHeight / stDisplayInfo.DVHeight;
4571   2              ((DWORD *)pData)[3] = (((DWORD *)pData)[3] >> 1) + (((DWORD *)pData)[3] & 0x01);
4572   2      
4573   2              pData[3] = ((((DWORD *)pData)[3] >> 16) & 0x0f);
4574   2              pData[4] = ((((DWORD *)pData)[3] >> 8) & 0xff);
4575   2              pData[5] = ((((DWORD *)pData)[3]) & 0xff);
4576   2          }
4577   1          else
4578   1          {
4579   2              pData[3] = 0x0f;
4580   2              pData[4] = 0xff;
4581   2              pData[5] = 0xff;
4582   2          }
4583   1      
4584   1          CScalerSetByte(_SU_ACCESS_PORT_33, 0x80);
4585   1          CScalerWrite(_SU_DATA_PORT_34, 6, pData, _NON_AUTOINC);
4586   1          CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
4587   1      
4588   1      
4589   1      #if(_NON_LINEAR_SCALING_FUCTION == _ON)
              
                  CScalerDisableNonlinearScaleUp();
              
                  if(GET_NON_LINEAR_SCALING_STATUS())
                  {
                      CTimerWaitForEvent(_EVENT_DEN_STOP);
                      CScalerNonlinearScaleUp();
                  }
              
              #endif
4600   1      
4601   1          CScalerPageSelect(_PAGE0);
4602   1      }
4603          
4604          //--------------------------------------------------
4605          // Description  : Set display
4606          // Input Value  : Scaling information
4607          // Output Value : None
4608          //--------------------------------------------------
4609          void CModeSetDisplay(BYTE ucOption)
4610          {
4611   1          DWORD ulFreq;
4612   1          // Disable spread spectrum
4613   1          CAdjustDclkSpreadSpectrumRange(0);
4614   1      
4615   1          // Calculate and set display clock frequency for frame sync mode
4616   1          ((DWORD *)pData)[0] = (DWORD)(stDisplayInfo.DHTotal) * (DWORD)stModeInfo.IHFreq * (DWORD)(stDisplayInf
             -o.DVHeight) / stModeInfo.IVHeight / 10;
4617   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 77  

4618   1      
4619   1      
4620   1      #if(_FRC_SUPPORT == _ON)
                  if(GET_FRCSTATUS())
                  {
                      // Calculate and set display clock frequency for FRC mode
                      ((DWORD *)pData)[0] = (DWORD)(stDisplayInfo.DHTotal) * (DWORD)stModeInfo.IHFreq * (DWORD)(_PANEL_D
             -V_TOTAL) / stModeInfo.IVTotal / 10;
              
                      if(stModeInfo.IVFreq > _PANEL_MAX_FRAME_RATE)
                      {
                          // Issac-04-16 Begin
                          WORD usDisplayRate;
              
                          //((DWORD *)pData)[0] = (DWORD)(_PANEL_DH_TOTAL) * (_PANEL_DV_TOTAL) * (_PANEL_MAX_FRAME_RATE 
             -/ 10) / 1000;
              
                          //The 1440x900_75Hz mode is failed when doing Auto function in FRC mode.
                          /*
                          usDisplayRate = (((DWORD)_MEMORY_SPEED * 1000000 / stModeInfo.IHWidth / 24 * _MEMORY_BUS_WIDTH
             - / 10 * 84)
                                        - ((DWORD)stModeInfo.IVFreq * stModeInfo.IVTotal))
                                        / _PANEL_DV_TOTAL * stDisplayInfo.DVHeight / stModeInfo.IVHeight;
                          */
                          usDisplayRate = (((DWORD)_MEMORY_SPEED * 1000000 / stModeInfo.IHWidth / 24 * _MEMORY_BUS_WIDTH
             - / 10 * 83)
                                        - ((DWORD)stModeInfo.IVFreq * stModeInfo.IVTotal))
                                        / _PANEL_DV_TOTAL * stDisplayInfo.DVHeight / stModeInfo.IVHeight;
              
                          if (usDisplayRate >= _PANEL_MAX_FRAME_RATE)
                          {
                              usDisplayRate = _PANEL_MAX_FRAME_RATE;
                          }
              
                          ((DWORD *)pData)[0] = (DWORD)(_PANEL_DH_TOTAL) * (_PANEL_DV_TOTAL) * (usDisplayRate / 10) / 10
             -00;
                          // Issac-04-16 End
              
                          CAdjustPLL(_DPLL, ((DWORD *)pData)[0]);
                      }
                      else if(((DWORD *)pData)[0] >= (DWORD)_PANEL_PIXEL_CLOCK_MAX * 1000)
                      {
                          ((DWORD *)pData)[0] = (DWORD)_PANEL_PIXEL_CLOCK_MAX * 1000;
                          CAdjustPLL(_DPLL, (DWORD)_PANEL_PIXEL_CLOCK_MAX * 1000);
                      }
                      else
                      {
                         ((DWORD *)pData)[0] -= 100;
                          CAdjustPLL(_DPLL, ((DWORD *)pData)[0] - 100);
                      }
                  }
                  else if(ucCurrState == _NOSUPPORT_STATE)
                  {
              //        CAdjustPLL(_DPLL, (DWORD)_PANEL_PIXEL_CLOCK_MAX * 1000);
                      CAdjustPLL(_DPLL, (DWORD)_PANEL_PIXEL_CLOCK * 1000);
                  }
                  else
                  {
                      CAdjustPLL(_DPLL, ((DWORD *)pData)[0]);
                  }
              #else
4674   1          CAdjustPLL(_DPLL, ((DWORD *)pData)[0]);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 78  

4675   1      #endif
4676   1          ulFreq = ((DWORD *)pData)[0];
4677   1      #if _DEBUG_MESSAGE_SUPPORT
4678   1      //CDebugMessage(" ulFreq==", ulFreq);
4679   1      //CDebugMessage(" stDisplayInfo.DHTotal==", stDisplayInfo.DHTotal);
4680   1      ///CDebugMessage(" stDisplayInfo.DHWidth==", stDisplayInfo.DHWidth);
4681   1      //CDebugMessage(" stDisplayInfo.DVHeight==", stDisplayInfo.DVHeight);
4682   1      //CDebugMessage(" stDisplayInfo.DVHeight==", stDisplayInfo.DVStartPos);
4683   1      #endif
4684   1          // Set DH_TOTAL
4685   1          pData[0] = (HIBYTE(stDisplayInfo.DHTotal - 4) & 0x0f);
4686   1          pData[1] = (LOBYTE(stDisplayInfo.DHTotal - 4));
4687   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DH_TOTAL_H_00);
4688   1          CScalerWrite(_DISP_DATA_PORT_2B, 2, pData, _NON_AUTOINC);
4689   1      
4690   1          // Calculate DV_TOTAL setting for watchdog
4691   1      #if(_FRC_SUPPORT == _ON)
                  if(GET_FRCSTATUS())
                  {
                      ((WORD *)pData)[2] = _PANEL_DV_TOTAL + 64;
                  }
                  else
              #endif
4698   1              ((WORD *)pData)[2] = (DWORD)stModeInfo.IVTotal * (DWORD)(stDisplayInfo.DVHeight) / stModeInfo.IVHe
             -ight + 64;
4699   1      
4700   1          pData[0] = (HIBYTE(((WORD *)pData)[2]) & 0x0f);
4701   1          pData[1] = (LOBYTE(((WORD *)pData)[2]));
4702   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DV_TOTAL_H_0B);
4703   1          CScalerWrite(_DISP_DATA_PORT_2B, 2, pData, _NON_AUTOINC);
4704   1      
4705   1          // Display horizontal start/end
4706   1          ((WORD *)pData)[4] = (_PANEL_DH_WIDTH - stDisplayInfo.DHWidth) / 2 + _PANEL_DH_START;
4707   1          ((WORD *)pData)[5] = ((WORD *)pData)[4] + stDisplayInfo.DHWidth;
4708   1      
4709   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DH_ACT_STA_H_05);
4710   1          CScalerWrite(_DISP_DATA_PORT_2B, 4, &pData[8], _NON_AUTOINC);
4711   1      
4712   1          // Display vertical
4713   1          ((WORD *)pData)[0] = stDisplayInfo.DVStartPos - ((_PANEL_DV_HEIGHT - stDisplayInfo.DVHeight) / 2);
4714   1          ((WORD *)pData)[1] = stDisplayInfo.DVStartPos;
4715   1          ((WORD *)pData)[2] = ((WORD *)pData)[1] + stDisplayInfo.DVHeight;
4716   1          ((WORD *)pData)[3] = ((WORD *)pData)[0] + _PANEL_DV_HEIGHT;
4717   1      
4718   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, (0x80 | _DISP_DV_BKGD_STA_H_0E));
4719   1          CScalerWrite(_DISP_DATA_PORT_2B, 8, pData, _NON_AUTOINC);
4720   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, 0x00);
4721   1      
4722   1          // Turn off full-line buffer
4723   1          CScalerSetBit(_SCALE_CTRL_32, ~_BIT4, 0x00);
4724   1      
4725   1      #if(_FRC_SUPPORT == _ON)
                  if(GET_FRCSTATUS())
                  {
                      // Enable display timing
                      if(GET_FRCDOUBLEFRAME())
                      {
                          CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5 | _BIT3 | _BIT1 | _BIT0), (_BIT5 | _BIT1 | _BIT0));
                      }
                      else
                      {
                          CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5 | _BIT3 | _BIT1 | _BIT0), (_BIT5 | _BIT3 | _BIT1 | _BIT0
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 79  

             -));//Anderson 080422 to Solve Frame Tear
                      }
              
              
                      // Enable the spread spectrum function
                      CAdjustDclkSpreadSpectrumRange(_DCLK_SPREAD_RANGE);
                      CMemoryAdjustIVS2DVSDelay(ulFreq);
                  }
                  else
              #endif
4745   1          {
4746   2              CAdjustIVS2DVSDelay(ucOption);
4747   2              // Enable display timing
4748   2              CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5 | _BIT3 | _BIT1 | _BIT0), (_BIT5 | _BIT3 | _BIT1 | _BIT0));
4749   2          }
4750   1          CMiscClearStatusRegister();
4751   1      }
4752          
4753          //----------------------------------------------------------------------------------------------------
4754          // Other Mode Functions
4755          //----------------------------------------------------------------------------------------------------
4756          
4757          //--------------------------------------------------
4758          // Description  : Reset scalar setting before show OSD at no signal
4759          // Input Value  : None
4760          // Output Value : None
4761          //--------------------------------------------------
4762          #if(_SWITCH_INPUT_SOURCE_OSD == _ON)
4763          void CModeResetShowOSD(void)
4764          {
4765   1          CScalerSetBit(_HOST_CTRL_01, ~_BIT1, 0x00);
4766   1      
4767   1          CModeSetFreeRun();
4768   1      
4769   1          CScalerEnableDisplayTiming();
4770   1      }
4771          #endif
4772          
4773          //--------------------------------------------------
4774          // Description  : Reset mode
4775          // Input Value  : None
4776          // Output Value : None
4777          //--------------------------------------------------
4778          void CModeResetMode(void)
4779          {
4780   1          // V014 System Patch Note (9) Modify 20100604 Start
4781   1          // Patch Reason : Turn off the backlight at the very beginning of mode reset procedure to avoid showin
             -g garbage.
4782   1          /////////////////////////////////////////////////////////////////////////////////
4783   1          // Please make sure turning off the backlight is the first step of mode reset. //
4784   1          /////////////////////////////////////////////////////////////////////////////////
4785   1          CPowerLightPowerOff();
4786   1          // V014 System Patch Note (9) Modify 20100604 End
4787   1      
4788   1      // V013 TMDS Patch Note (16) 20100422 Modify Start
4789   1      // Patch Reason : Solve DVI Interlace Issue.
4790   1          g_bDoModeResetMode = _FALSE;
4791   1      // V013 TMDS Patch Note (16) 20100422 Modify End
4792   1      
4793   1      #if(_DP_SUPPORT == _ON)
              
                  g_bDpDisplayPass = _FALSE;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 80  

              
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DP_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1
             -_DP_PORT))
                  {
                      CDpSinkStatusSet(_FALSE);    //! Sink out of sync
              
              #if(_DP_POWER_MANAGEMENT == _ON)
                      if((g_ucDpPowerStatus != _DP_POWER_DOWN) && (CDpLinkStatusCheck() == _TRUE))
                      {
              
              
                          g_ucDisplayPortLtPreStatus = _TRAINING_PATTERN_END;
                          g_bDpSearchTimesReset = 1;
                      }
                      else if(g_ucDpPowerStatus == _DP_POWER_DOWN)
                      {
                          g_ucDisplayPortLtPreStatus = _TRAINING_PATTERN_NONE;
                      }
              #else
                      g_ucDisplayPortLtPreStatus = _TRAINING_PATTERN_END;
                      g_bDpSearchTimesReset = 1;
              #endif
              
                      }
              #endif
4820   1      
4821   1          // V014 System Patch Note (9) Modify 20100604 Start
4822   1          // Patch Reason : Turn off the backlight at the very beginning of mode reset procedure to avoid showin
             -g garbage.
4823   1          /*
4824   1          CPowerLightPowerOff();
4825   1          */
4826   1          // V014 System Patch Note (9) Modify 20100604 End
4827   1      
4828   1      #if (_PANEL_TYPE == _CMO_LVDS_22_WSXGA_PLUS)
                  CPowerPanelOff();
              #endif
4831   1      
4832   1          CAdjustDisableWatchDog(_WD_ALL);
4833   1      
4834   1      #if(_HDMI_SUPPORT == _ON)
                  CScalerPageSelect(_PAGE2);
                  CAdjustDisableHDMIWatchDog(_WD_AUDIO_FOR_TMDS_CLOCK | _WD_PACKET_VARIATION);
              
                  //cyc:For 2880 input width.
              //    CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VCR_50, 0xf0, 0x00);
              //    CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_ACRCR_51, ~_BIT2, 0x00);
              
              #if((_SCALER_TYPE == _RTD2472D))
                  CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_AOCR_62, 0x00);//Disable SPDIF/I2S Output
              #endif
              
                  SET_VIDEOMODECHANGE();
              #endif
4848   1      
4849   1          if(ucCurrState == _SLEEP_STATE)
4850   1          {
4851   2              if(CScalerGetBit(_HOST_CTRL_01, _BIT1))
4852   2              {
4853   3                  CScalerSetBit(_HOST_CTRL_01, ~_BIT1, 0x00);
4854   3                  CTimerDelayXms(2); // wait for H/W stable
4855   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 81  

4856   2      
4857   2      #if(_MCU_TYPE == _REALTEK_EMBEDDED)
4858   2              CMcuSelectFlashClk(_FLASH_CLK);
4859   2      #endif
4860   2          }
4861   1      
4862   1          CScalerResetProcess();
4863   1      
4864   1      #if(_SCALER_TYPE == _RTD2545LR)
              
              #if((_HDCP_SUPPORT == _ON) && (_EMBEDDED_HDCP_KEY == _ON))
                      CScalerPageSelect(_PAGE2);
                      CScalerSetByte(_P2_HDCP_CTRL_C0, 0x06);
              
                      CAdjustWriteHDCPKey(_P2_DEVICE_KEY_ACCESS_PORT_C1, 1, _NON_AUTOINC);
              
                      CTimerDelayXms(30);
                      CScalerSetByte(_P2_HDCP_CTRL_C0, 0x01);
              #endif
              
              #endif
4877   1      
4878   1      #if(_OD_SUPPORT == _ON)
                  CMemorySetODOnOff(_OFF);
              #endif
4881   1          CModeSetFreeRun();
4882   1      
4883   1          if(GET_PANELPOWERSTATUS() == _OFF)
4884   1          {
4885   2              CScalerEnableDisplayTiming();
4886   2          }
4887   1      
4888   1          COsdFxDisableOsd();
4889   1          CModeAutoMeasureOff();
4890   1          CAdjustTMDSErrorCorrectionOn();
4891   1          CPowerPWMOn();
4892   1          CMiscClearStatusRegister();
4893   1      
4894   1          CTimerCancelTimerEvent(CMiscCheckToActiveEvent);
4895   1      
4896   1          CTimerCancelTimerEvent(CModeNoSignalEvent);
4897   1          CTimerCancelTimerEvent(CModeNoCableEvent);
4898   1          CTimerCancelTimerEvent(CModeNoSupportEvent);
4899   1          CTimerCancelTimerEvent(CModePowerSavingEvent);
4900   1          COsdBankSwitchCancelTimer();
4901   1      
4902   1      #if(_DCR_MODE == _DCR_TYPE_3)
                  g_usDCR5MinTimer = 0;
                  CLR_DCR_ULTRA_MIN();
              #endif
4906   1      
4907   1      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2472D))
4908   1          // do nothing
4909   1      #else
                  g_usTMDSFreq = 0;
              #endif
4912   1      
4913   1          CLR_FIRST_ADCCLOCK();
4914   1          CLR_USE_TRANSITION_RESULT();
4915   1          CLR_FRAMESYNCSTATUS();
4916   1          CLR_MODESTABLE();
4917   1          CLR_INTERLACE_MODE();
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 82  

4918   1      #if(_FRC_SUPPORT == _ON)
                  CLR_FRCSTATUS();
                  CLR_FRC422STATUS();
              #if(_FIELD_MERGE_SUPPORT == _ON)
                  CLR_FIELDMERGE_MODE();
              #endif
              #endif
4925   1      //avoid abnormal OD state on screen.
4926   1      #if(_OD_SUPPORT == _ON)
                  CLR_READYFORDISPLAY();
              #endif
4929   1      
4930   1      #if(_HDMI_SUPPORT == _ON)
                  CLR_HDMIINPUT();
              
              #if((_SCALER_TYPE == _RTD2472D))
                  CLR_AUDIOPLLLOCKREADY();
                  CLR_AVRESUME();
                  CLR_AUDIOWAITINGTIMEOUT();
              #endif
              
                  CLR_DEEPCOLORMODE();
              #endif
4941   1      
4942   1      #if(_AUDIO_SUPPORT == _ON)
                  CAdjustAudioControl(_DISABLE);
              #endif
4945   1      
4946   1      #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RTD2545LR))
              #if((_HDMI_SUPPORT == _ON) && (_AUDIO_SUPPORT == _ON))
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
                  {
              
                      CScalerPageSelect(_PAGE2);
              
                      // Disable SPDIF/I2S Output
                      CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_AOCR_62, 0x00);
              
                      // Disable N & CTS Tracking, FIFO Trend/boundary
                      CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_PSCR_15, 0x00);
              
                      // Update Double Buffer
                      CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_CMCR_10, ~_BIT4, _BIT4);
              
                      // Disable PLL
                      CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_DPCR0_38, 0x80);
              
                      g_usHDMILockedFreq = 0;
                      SET_HDMIAUDIOUNTRACKED();
                      CLR_HDMIAUDIOTRACKED();
              
                  }
              #endif
              #endif  // End of #if((_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD) || (_SCALER_TYPE == _RT
             -D2545LR))
4972   1      
4973   1          CSourceInitialConnect();
4974   1      
4975   1      #if(_OVERSCAN_SUPPORT == _ON)
4976   1          CLR_OVERSCAN_STATUS();
4977   1          CLR_OVERSCAN_SUCCESS_STATUS();
4978   1          CLR_OVERSCAN_CAPTURE_BACKUP_VALUE();
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 83  

4979   1          CLR_OVERSCAN_IV2DVDELAY_BACKUP_VALUE();
4980   1          g_ucOverScanH = 0;
4981   1          g_ucOverScanV = 0;
4982   1          g_usCaptureStartH = 0;
4983   1          g_usCaptureStartV = 0;
4984   1          g_usOldIHWidth = 0;
4985   1          g_usOldIVHeight = 0;
4986   1          g_ucUserModeCurr = 0;
4987   1          g_ucIv2DvModify = 0;
4988   1      #endif
4989   1      
4990   1          stModeInfo.ModeCurr = _MODE_NOSIGNAL;
4991   1          ucModeFound = _MODE_FIRST;
4992   1          ucEvent0 = _INACTIVE_COUNTDOWN_EVENT;
4993   1          ucEvent1 = _INACTIVE_COUNTDOWN_EVENT;
4994   1          ucOsdState = _MENU_NONE;
4995   1          ucOsdEventMsg = _NONE_MSG;
4996   1      
4997   1          stModeInfo.Polarity = 0;
4998   1          stModeInfo.IHCount = 0;
4999   1          stModeInfo.IHFreq = 0;
5000   1          stModeInfo.IVTotal = 0;
5001   1          stModeInfo.IVFreq = 0;
5002   1          stModeInfo.IHWidth = 0;
5003   1          stModeInfo.IVHeight = 0;
5004   1          stModeInfo.IHSyncPulseCount = 0;
5005   1      
5006   1          // V013 System Patch Note (3) 20100429 Modify Start
5007   1          // Patch Reason : Initial stModeInfo XDATA variables.
5008   1          stModeInfo.IHStartPos = 0;
5009   1          stModeInfo.IHTotal = 0;
5010   1          // V013 System Patch Note (3) 20100429 Modify End
5011   1      
5012   1          // V013 TMDS Patch Note (16) 20100422 Modify Start
5013   1          // Patch Reason : Solve DVI Interlace Issue.
5014   1          stModeInfo.IVStartPos = 0;
5015   1          // V013 TMDS Patch Note (16) 20100422 Modify End
5016   1      
5017   1          stModeInfo.IVSyncPulseCount = 0;
5018   1          g_usAdcClockLimit = _PIXEL_WIDTH_LIMIT;
5019   1          g_usCaptureStart = 0;
5020   1      
5021   1          g_usVTotalTemp = 0;
5022   1          g_ucVSyncPulseWidthTemp = 0;
5023   1      
5024   1          // V012 Modify 20100402 Start
5025   1          // V012 Patch Note (29) : Fix the inaccurate Vfreq in OSD with SOG HORV/HEORV sync type.
5026   1          g_ucCoastLineCnt = 0;
5027   1          // V012 Modify 20100402 End
5028   1      
5029   1          // V012 Modify 20100331 Start
5030   1          // V012 Patch Note (30) : Use mode search incorrect flag to skip SOD clock seeking in the auto stage t
             -o avoid one missing vertical line at the edge of the picture.
5031   1          g_bModeSearchIncorrectFlag = _FALSE;
5032   1          // V012 Modify 20100331 Start
5033   1      
5034   1          // V013 VGA Patch Note (10) 20100416 Modify Start
5035   1          // Patch Reason : Support Auto Config For Yuv Color.
5036   1      #if(_YUV_AUTO_CONFIG_SUPPORT == _ON)
5037   1          g_bYuvRgbFlag = _FALSE;
5038   1      #endif
5039   1          // V013 VGA Patch Note (10) 20100416 Modify End
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 84  

5040   1      
5041   1          if(ucCurrState != _SEARCH_STATE)
5042   1          {
5043   2              g_ucSearchIndex = stSystemData.SearchIndex;
5044   2      #if _DEBUG_MESSAGE_SUPPORT
5045   2           CDebugMessage("stSystemData.SearchIndex_modereset", stSystemData.SearchIndex) ;
5046   2      #endif
5047   2              g_ucSearchTimes = GET_INPUTPORT_SEARCH_TIMES(g_ucSearchIndex);
5048   2              g_ucSearchFinish = 0;
5049   2      
5050   2              CLR_SEARCH_FINISH();
5051   2      
5052   2              SET_SEARCH_INITIAL();
5053   2      
5054   2      #if(_SWITCH_INPUT_SOURCE == _ON)
                      if(GET_SOURCE_STATE() == _SWITCH_INPUT_SOURCE_STATE)
                      {
                          SET_SOURCE_STATE(_SOURCE_AUTO_CHANGE_STATE);
                      }
              #endif
5060   2              if((GET_INPUT_SOURCE_SEARCH() == _FALSE) && (GET_SOURCE_STATE() == _SOURCE_AUTO_CHANGE_STATE))
5061   2              {
5062   3                  SET_FIRST_INPUT_PORT_SEARCH();
5063   3              }
5064   2      
5065   2              if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) =
             -= _A1_VGA_PORT))
5066   2              {
5067   3                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
5068   3                  {
5069   4                      if(ucCurrState == _ACTIVE_STATE)
5070   4                      {
5071   5                          g_ucSearchTimes = g_ucSearchTimes + 60;
5072   5                      }
5073   4                      else
5074   4                      {
5075   5                          g_ucSearchTimes = g_ucSearchTimes + 5;
5076   5                      }
5077   4                  }
5078   3              }
5079   2          }
5080   1      
5081   1          g_bCheckHDCP = 0;
5082   1      
5083   1          ucCurrState = _SEARCH_STATE;
5084   1          SET_INPUTSOURCE_TYPE(_SOURCE_NONE);
5085   1          SET_MODE_SEARCH_TYPE(_PRESET_MODE_TYPE);
5086   1      
5087   1      }
5088          
5089          //--------------------------------------------------
5090          // Description  : Free run mode setting
5091          // Input Value  : None
5092          // Output Value : None
5093          //--------------------------------------------------
5094          void CModeSetFreeRun(void)
5095          {
5096   1      
5097   1          CMiscDisableDoubleBuffer();
5098   1      
5099   1      #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
              
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 85  

                  CAdjustPLL(_MPLL, (DWORD)_MEMORY_SPEED * 1000); // Enable MPLL
                  CAdjustOdFrcPerformance(); //Set MCLK spread spectrum range & SDRAM Phase
              
              #endif //End of #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD2
             -48xRD))
5105   1      
5106   1          CAdjustPLL(_DPLL, (DWORD)_PANEL_PIXEL_CLOCK * 1000);
5107   1      
5108   1          CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5 | _BIT3 | _BIT1 | _BIT0), (_BIT5 | _BIT1 | _BIT0));
5109   1      
5110   1          pData[0] = (HIBYTE(_PANEL_DH_TOTAL - 4) & 0x0f);
5111   1          pData[1] = (LOBYTE(_PANEL_DH_TOTAL - 4));
5112   1          pData[2] = (_PANEL_DH_SYNC_WIDTH);
5113   1          pData[3] = (HIBYTE(_PANEL_DH_START) & 0x0f);
5114   1          pData[4] = (LOBYTE(_PANEL_DH_START));
5115   1          pData[5] = (HIBYTE(_PANEL_DH_START) & 0x0f);
5116   1          pData[6] = (LOBYTE(_PANEL_DH_START));
5117   1          pData[7] = (HIBYTE(_PANEL_DH_END) & 0x0f);
5118   1          pData[8] = (LOBYTE(_PANEL_DH_END));
5119   1          pData[9] = (HIBYTE(_PANEL_DH_END) & 0x0f);
5120   1          pData[10] = (LOBYTE(_PANEL_DH_END));
5121   1      
5122   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DH_TOTAL_H_00);
5123   1          CScalerWrite(_DISP_DATA_PORT_2B, 11, pData, _NON_AUTOINC);
5124   1      
5125   1          pData[0] = (HIBYTE(_PANEL_DV_TOTAL) & 0x0f);
5126   1          pData[1] = (LOBYTE(_PANEL_DV_TOTAL));
5127   1          pData[2] = (_PANEL_DV_SYNC_HEIGHT);
5128   1          pData[3] = (HIBYTE(_PANEL_DV_START) & 0x0f);
5129   1          pData[4] = (LOBYTE(_PANEL_DV_START));
5130   1          pData[5] = (HIBYTE(_PANEL_DV_START) & 0x0f);
5131   1          pData[6] = (LOBYTE(_PANEL_DV_START));
5132   1          pData[7] = (HIBYTE(_PANEL_DV_END) & 0x0f);
5133   1          pData[8] = (LOBYTE(_PANEL_DV_END));
5134   1          pData[9] = (HIBYTE(_PANEL_DV_END) & 0x0f);
5135   1          pData[10] = (LOBYTE(_PANEL_DV_END));
5136   1      
5137   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DV_TOTAL_H_0B);
5138   1          CScalerWrite(_DISP_DATA_PORT_2B, 11, pData, _NON_AUTOINC);
5139   1      
5140   1          // V015 VGA Patch Note (9) Modify 20100623 Start
5141   1          // Patch Reason : Correct OSD Reference DEN for Free Run Mode.
5142   1          pData[0] = (_PANEL_DV_START <= 6) ? 6 : _PANEL_DV_START;
5143   1          CScalerSetDataPortByte(_DISP_ACCESS_PORT_2A, _DISP_OSD_REFERENCE_DEN_21, pData[0] - 4);
5144   1          // V015 VGA Patch Note (9) Modify 20100623 End
5145   1      
5146   1          pData[0] = ((_PANEL_DH_TOTAL >> 4) & 0xf0) | (HIBYTE(_PANEL_DV_TOTAL) & 0x0f);
5147   1          pData[1] = LOBYTE(_PANEL_DV_TOTAL);
5148   1          pData[2] = LOBYTE(_PANEL_DH_TOTAL);
5149   1      
5150   1          CScalerPageSelect(_PAGE1);
5151   1          CScalerWrite(_P1_EVEN_FIX_LASTLINE_DVTOTAL_M_C7, 3, pData, _AUTOINC);
5152   1          stDisplayInfo.DHWidth = _PANEL_DH_END - _PANEL_DH_START;
5153   1          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT - _PANEL_DV_START;
5154   1      
5155   1      }
5156          
5157          //--------------------------------------------------
5158          // Description  : Check if the connector status is changed
5159          // Input Value  : None
5160          // Output Value : Return _TRUE if the connector status changed
5161          //--------------------------------------------------
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 86  

5162          bit CModeConnectIsChange(void)
5163          {
5164   1      #if(_CABLE_CONNECT_CHECK)
5165   1      
5166   1          bit status = 0;
5167   1      
5168   1          switch(GET_INPUTPORT_TYPE(g_ucSearchIndex))
5169   1          {
5170   2      #if(_A0_INPUT_PORT_TYPE != _A0_NO_PORT)
5171   2      
5172   2      #ifdef _A0_PORT
5173   2              case _A0_INPUT_PORT_TYPE:
5174   2                  if(bA0_CONNECT != GET_PRE_A0_CONNECT())
5175   2                  {
5176   3                      SET_PRE_A0_CONNECT(bA0_CONNECT);
5177   3                      status = 1;
5178   3                  }
5179   2      
5180   2                  SET_PRE_A0_CONNECT(bA0_CONNECT);
5181   2                  break;
5182   2      #endif
5183   2      
5184   2      #endif // End of #if(_A1_INPUT_PORT_TYPE != _A1_NO_PORT)
5185   2      
5186   2      #if(_A1_INPUT_PORT_TYPE != _A1_NO_PORT)
              
              #ifdef _A1_PORT
                      case _A1_INPUT_PORT_TYPE:
                          if(bA1_CONNECT != GET_PRE_A1_CONNECT())
                          {
                              SET_PRE_A1_CONNECT(bA1_CONNECT);
                              status = 1;
                          }
              
                          SET_PRE_A1_CONNECT(bA1_CONNECT);
                          break;
              #endif
              
              #endif // End of #if(_A1_INPUT_PORT_TYPE != _A1_NO_PORT)
5201   2      
5202   2      #if((_HDMI_SUPPORT == _ON) || (_TMDS_SUPPORT == _ON))
5203   2      
5204   2      #if(_D0_INPUT_PORT_TYPE != _D0_NO_PORT)
5205   2      
5206   2      #ifdef _D0_PORT
5207   2      
5208   2      #if(_PCB_TYPE == _RTD2472RD_DEMO_PCB)
                      case _D0_INPUT_PORT_TYPE:
                          if(CDpAuxPinCableConnect() != GET_PRE_D0_CONNECT())
                          {
                              SET_PRE_D0_CONNECT(CDpAuxPinCableConnect());
                              status = 1;
                          }
              
                          SET_PRE_D0_CONNECT(CDpAuxPinCableConnect());
                          break;
              
              #else
5220   2              case _D0_INPUT_PORT_TYPE:
5221   2                  if(bD0_CONNECT != GET_PRE_D0_CONNECT())
5222   2                  {
5223   3                      SET_PRE_D0_CONNECT(bD0_CONNECT);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 87  

5224   3                      status = 1;
5225   3                  }
5226   2      
5227   2                  SET_PRE_D0_CONNECT(bD0_CONNECT);
5228   2                  break;
5229   2      #endif
5230   2      
5231   2      #endif
5232   2      
5233   2      #endif // End of #if(_D0_INPUT_PORT_TYPE != _D0_NO_PORT)
5234   2      
5235   2      #if(_D1_INPUT_PORT_TYPE != _D1_NO_PORT)
              
              #ifdef _D1_PORT
                      case _D1_INPUT_PORT_TYPE:
                          if(bD1_CONNECT != GET_PRE_D1_CONNECT())
                          {
                              SET_PRE_D1_CONNECT(bD1_CONNECT);
                              status = 1;
                          }
              
                          SET_PRE_D1_CONNECT(bD1_CONNECT);
                          break;
              #endif
              
              #endif // End of #if(_D1_INPUT_PORT_TYPE != _D1_NO_PORT)
5250   2      
5251   2      #endif  // End of #if((_HDMI_SUPPORT == _ON) || (_TMDS_SUPPORT == _ON))
5252   2          }
5253   1      
5254   1          if(status)
5255   1          {
5256   2              return _TRUE;
5257   2          }
5258   1          else
5259   1          {
5260   2              return _FALSE;
5261   2          }
5262   1      #else
                      return _FALSE;
              
              #endif
5266   1      }
5267          
5268          //--------------------------------------------------
5269          // Description  : Enable online measure
5270          // Input Value  : None
5271          // Output Value : None
5272          //--------------------------------------------------
5273          void CModeAutoMeasureOn(void)
5274          {
5275   1          CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT7, _BIT7);
5276   1          CTimerPollingEventProc(60, CMiscModeMeasurePollingEvent);
5277   1      }
5278          
5279          //--------------------------------------------------
5280          // Description  : Disable online measure
5281          // Input Value  : None
5282          // Output Value : None
5283          //--------------------------------------------------
5284          void CModeAutoMeasureOff(void)
5285          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 88  

5286   1          CScalerSetBit(_MEAS_HS_PERIOD_H_52, ~_BIT7, 0x00);
5287   1      }
5288          
5289          //----------------------------------------------------------------------------------------------------
5290          // Mode Events
5291          //----------------------------------------------------------------------------------------------------
5292          
5293          //--------------------------------------------------
5294          // Description  : No signal timeout count down event
5295          // Input Value  : None
5296          // Output Value : None
5297          //--------------------------------------------------
5298          void CModeSyncTimeoutCountDownEvent(void)
5299          {
5300   1          ucCurrState = _NOSIGNAL_STATE;
5301   1          stModeInfo.ModeCurr = _MODE_NOSIGNAL;
5302   1          SET_READYFORDISPLAY();
5303   1      }
5304          
5305          //--------------------------------------------------
5306          // Description  : Mode stable count down event
5307          // Input Value  : None
5308          // Output Value : None
5309          //--------------------------------------------------
5310          void CModeStableCountDownEvent(void)
5311          {
5312   1          SET_MODESTABLE();
5313   1      }
5314          
5315          //--------------------------------------------------
5316          // Description  : No signal event
5317          // Input Value  : None
5318          // Output Value : None
5319          //--------------------------------------------------
5320          void CModeNoSignalEvent(void)
5321          {
5322   1          ucOsdEventMsg = _SHOW_NOSIGNAL_MSG;
5323   1      }
5324          
5325          //--------------------------------------------------
5326          // Description  : No cable event
5327          // Input Value  : None
5328          // Output Value : None
5329          //--------------------------------------------------
5330          void CModeNoCableEvent(void)
5331          {
5332   1          ucOsdEventMsg = _SHOW_NOCABLE_MSG;
5333   1      }
5334          
5335          //--------------------------------------------------
5336          // Description  : No support event
5337          // Input Value  : None
5338          // Output Value : None
5339          //--------------------------------------------------
5340          void CModeNoSupportEvent(void)
5341          {
5342   1          ucOsdEventMsg = _SHOW_NOSUPPORT_MSG;
5343   1      }
5344          
5345          //--------------------------------------------------
5346          // Description  : Display timing and input source event
5347          // Input Value  : None
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 89  

5348          // Output Value : None
5349          //--------------------------------------------------
5350          void CModeOsdDisplayTimingAndInputEvent(void)
5351          {
5352   1         ucOsdEventMsg = _SHOW_TIMINGINPUT_MSG;
5353   1      }
5354          
5355          //--------------------------------------------------
5356          // Description  : Power saving event
5357          // Input Value  : None
5358          // Output Value : None
5359          //--------------------------------------------------
5360          void CModePowerSavingEvent(void)
5361          {
5362   1          CScalerPageSelect(_PAGE2);
5363   1      
5364   1          CScalerSetBit(_P2_POWER_ON_OFF_CTRL_A7, ~(_BIT4 | _BIT3 | _BIT2 | _BIT1 | _BIT0), _BIT4);
5365   1          CScalerSetBit(_P2_TMDS_OUTPUT_CTRL_A6, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4 | _BIT3), _BIT7);
5366   1      
5367   1          // Audio PLL power down when power saving
5368   1          CScalerSetBit(_P2_HDMI_APC_C8, ~_BIT0, 0x00);
5369   1          CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_DPCR0_38, ~_BIT7, _BIT7);
5370   1      #if(_AUDIO_SUPPORT == _ON)
                  CAdjustAudioControl(_DISABLE);
              #endif
5373   1          CPowerPanelOff();
5374   1          CScalerSetBit(_VDISP_CTRL_28, ~(_BIT3 | _BIT0), 0x00);
5375   1      
5376   1          CPowerADCAPLLOff();
5377   1          CPowerLVDSOff();
5378   1          CPowerDPLLOff();
5379   1      
5380   1          CPowerPWMOff();
5381   1      
5382   1      #if(_MCU_TYPE == _REALTEK_EMBEDDED)
5383   1          CMcuSelectFlashClk(_XTAL_CLK);
5384   1          CTimerDelayXms(10);
5385   1      #endif
5386   1      
5387   1          CPowerM2PLLOff();
5388   1      #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                  CPowerMPLLOff();
              #endif
5391   1      
5392   1          CScalerDisableDisplayTiming();
5393   1          CScalerSetBit(_HOST_CTRL_01, ~_BIT1, _BIT1);
5394   1      
5395   1      #if(_DP_SUPPORT == _ON)
              
              #if(_SOURCE_SEARCH_TYPE_BY_OSD == _ON)
                  if(GET_SOURCE_SEARCH_AUTO() == _TRUE)   // for Auto Source
                  {
              
              
                      CScalerPageSelect(_PAGEB);
                      CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x08);
              
                      CScalerPageSelect(_PAGEC);
                      CScalerSetByte(_PC_DP_CTL_A1, 0x20);
              
                      // Turn off output CLK
                      CScalerSetBit(_PC_DP_OUTPUT_CTL_A2, ~_BIT4, 0x00);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 90  

              
                      // Turn off SCLK PLL
                      CScalerSetDataPortBit(_PC_DP_ACCESS_PORT_B3, 0x70, ~_BIT7, _BIT7);
                  }
                  else                                    // for Single Source
              #endif
                  {
                      if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DP_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) ==
             - _D1_DP_PORT)) //DP
                      {
                          if(((g_ucDpPowerStatus == _DP_POWER_DOWN) || (g_bDpPowerDown == _TRUE)) && (g_ucDisplayPortLtP
             -reStatus == _TRAINING_PATTERN_NONE))
                          {
              
              
                              CScalerPageSelect(_PAGEB);
                              CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x08);
              
                              CScalerPageSelect(_PAGEC);
                              CScalerSetByte(_PC_DP_CTL_A1, 0x20);
              
                              // Turn off output CLK
                              CScalerSetBit(_PC_DP_OUTPUT_CTL_A2, ~_BIT4, 0x00);
              
                              // Turn off SCLK PLL
                              CScalerSetDataPortBit(_PC_DP_ACCESS_PORT_B3, 0x70, ~_BIT7, _BIT7);
                          }
                          else
                          {
                              //do nothing
                          }
                      }
                      else //HDMI/DVI/VGA
                      {
                          CScalerPageSelect(_PAGEB);
                          CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x08);
              
                          CScalerPageSelect(_PAGEC);
                          CScalerSetByte(_PC_DP_CTL_A1, 0x20);
              
                          // Turn off output CLK
                          CScalerSetBit(_PC_DP_OUTPUT_CTL_A2, ~_BIT4, 0x00);
              
                          // Turn off SCLK PLL
                          CScalerSetDataPortBit(_PC_DP_ACCESS_PORT_B3, 0x70, ~_BIT7, _BIT7);
                      }
                  }
              #else
5456   1      
5457   1          CScalerPageSelect(_PAGEB);
5458   1          CScalerSetByte(_PB_DP_PWR_CTL_B4, 0x08);
5459   1      #endif
5460   1      
5461   1          CScalerPageSelect(_PAGE1);
5462   1          CScalerSetByte(_P1_BB_POWER0_F0, 0x00);
5463   1          CScalerSetByte(_P1_BB_POWER1_F1, 0x00);
5464   1      
5465   1          ucCurrState = _SLEEP_STATE;
5466   1      }
5467          
5468          
5469          #if(_HDMI_SUPPORT == _ON)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 91  

              //--------------------------------------------------
              // Description  : Check HDMI Input Status
              // Input Value  : None
              // Output Value : return _FALSE if it will do CModeResetMode
              //--------------------------------------------------
              bit CModeHdmiStablePolling(void)
              {
              #if(_HDMI_FROM_DVI_CONNECT == _OFF)
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) != _D0_HDMI_PORT) && (GET_INPUTPORT_TYPE(g_ucSearchIndex) != _
             -D1_HDMI_PORT))
              #else
                  if(0)
              #endif
                  {
                      if(CHdmiFormatDetect())
                      {
                          return _FALSE;
                      }
                  }
              #if(_HDMI_FROM_DVI_CONNECT == _OFF)
                  else if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex)
             - == _D1_HDMI_PORT))
              #else
                  else if(1)
              #endif
                  {
                      if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)//ming080221
                      {
                          if(CHdmiFormatDetect())//Input source is the HDMI format.
                          {
                              if(GET_READYFORDISPLAY())
                              {
                                  CHdmiVideoSetting();
                              }
              
                              if(!GET_HDMIINPUT())
                              {
                                  return _FALSE;
                              }
              
              #if(_AUDIO_SUPPORT == _ON)
              #if((_SCALER_TYPE == _RTD2472D))
                              else
                              {
                                  if(GET_AUDIOWAITINGTIMEOUT())
                                  {
                                      CHdmiEnableAudioOutput();
                                  }
              #if(_AUDIO_OUTPUT_TYPE == _I2S)
                                  CScalerPageSelect(_PAGE2);
                                  CScalerRead(_P2_HDMI_SR_CB, 1, pData, _NON_AUTOINC);
                                  CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_AOCR_62, 1, &pData[1], _NON_AUT
             -OINC); //Read I2S Output
                                  if((pData[0] & 0x16) == 0x00) //LPCM & no overflow/underflow in Audio FIFO
                                  {
                                      if((pData[1] & 0x0f) != 0x0f)
                                      {
                                          CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_AOCR_62, 0x0f);//Enable
             - I2S Output
                                      }
                                  }
                                  else
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 92  

                                  {
                                      if((pData[1] & 0x0F) != 0x00)
                                      {
                                          CScalerSetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_AOCR_62, 0x00);//Disabl
             -e I2S Output
                                      }
                                  }
              #endif
                              }
              #endif
              #endif  // End of #if(_AUDIO_SUPPORT == _ON)
                          }
                          else
                          {
                              if(GET_HDMIINPUT())
                              {
                                  return _FALSE;
                              }
                          }
                      }
                  }
              
                  return _TRUE;
              }
              #endif
5552          
5553          //--------------------------------------------------
5554          // Description  : Check input signal for interlace mode
5555          // Input Value  : None
5556          // Output Value : None
5557          //--------------------------------------------------
5558          void CModeInterlaceCheck(void)
5559          {
5560   1          switch(GET_INPUTSOURCE_TYPE())
5561   1          {
5562   2              case _SOURCE_VGA:
5563   2      #if(_YPBPR_SUPPORT == _ON)
5564   2              case _SOURCE_YPBPR:
5565   2      #endif
5566   2                  CLR_INTERLACE_MODE();
5567   2      
5568   2                  /// for generate clk to interlace flag toggle
5569   2                  //stModeInfo.IHTotal = 1000;
5570   2                  //CAdjustAdcClock(stModeInfo.IHTotal,0);
5571   2                  CScalerPageSelect(_PAGE1);
5572   2                  CScalerSetByte(_P1_PLL_WD_AF, 0x08);
5573   2      
5574   2      
5575   2                  CScalerSetBit(_VGIP_CTRL_10, ~(_BIT3 | _BIT2 | _BIT1), 0);
5576   2      
5577   2                  CScalerSetBit(_IPV_ACT_LEN_H_1A, ~_BIT5, _BIT5);
5578   2                  CTimerDelayXms(80);
5579   2                  CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
5580   2                  if(pData[0] & 0x20)
5581   2                  {
5582   3                      SET_INTERLACE_MODE();
5583   3                  }
5584   2      
5585   2      
5586   2                  break;
5587   2      
5588   2      #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON) || (_VIDEO_SUPPORT == _ON) || (_DP_SUPPORT))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 93  

5589   2      
5590   2      #if(_VIDEO_SUPPORT == _ON)
                      case _SOURCE_VIDEO8:
                          CScalerSetByte(_STATUS0_02, 0x00);                      // Clear Status
                          CTimerDelayXms(80);
                          CScalerRead(_STATUS0_02, 1, pData, _NON_AUTOINC);       // Read status
                          if (pData[0] & 0x10)
                          {
                              SET_INTERLACE_MODE();
                          }
                          else
                          {
                              CLR_INTERLACE_MODE();
                          }
              
                          break;
              #endif
5606   2      
5607   2      #if((_TMDS_SUPPORT == _ON) || (_HDMI_SUPPORT == _ON))
5608   2              case _SOURCE_DVI:
5609   2              case _SOURCE_HDMI:
5610   2      #endif
5611   2      // V013 TMDS Patch Note (16) 20100422 Modify Start
5612   2      // Patch Reason : Solve DVI Interlace Issue.
5613   2                  CScalerPageSelect(_PAGE2);
5614   2                  if(CScalerGetBit(_P2_POWER_ON_OFF_CTRL_A7, _BIT7) == _BIT7)
5615   2                  {
5616   3                      // Internal ODD Signal Selection: Internal Field Detection ODD Signal
5617   3                      CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT0, _BIT0);
5618   3      
5619   3                      // Input pixel format: Embeded TMDS
5620   3                      CScalerSetBit(_VGIP_CTRL_10, ~(_BIT3 | _BIT2), _BIT2);
5621   3      
5622   3                      // Clear "Internal Fiel Detection ODD Toggle Happened" flag
5623   3                      CScalerSetBit(_IPV_ACT_LEN_H_1A, ~_BIT5, _BIT5);
5624   3      
5625   3                      // Wait even/odd toggle
5626   3                      CTimerWaitForEvent(_EVENT_IVS);
5627   3                      CTimerWaitForEvent(_EVENT_IVS);
5628   3                      CTimerWaitForEvent(_EVENT_IVS);
5629   3                      CTimerWaitForEvent(_EVENT_IVS);
5630   3      
5631   3                      // Detect "Internal Fiel Detection ODD Toggle Happened" flag
5632   3                      CScalerRead(_IPV_ACT_LEN_H_1A, 1, pData, _NON_AUTOINC);
5633   3      
5634   3                      if((pData[0] & 0x20) == 0x20)
5635   3                      {
5636   4                          SET_INTERLACE_MODE();
5637   4                      }
5638   3                      else
5639   3                      {
5640   4                          CLR_INTERLACE_MODE();
5641   4                      }
5642   3                  }
5643   2                  else
5644   2                  {
5645   3                      CScalerPageSelect(_PAGE2);
5646   3                      CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VCR_50, ~_BIT6, _BIT6);
5647   3      
5648   3                      // Wait even/odd toggle
5649   3                      CTimerWaitForEvent(_EVENT_IVS);
5650   3                      CTimerDelayXms(5);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 94  

5651   3      
5652   3                      CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VCR_50, 1, pData, _NON_AUTOINC);
5653   3                      if((pData[0] & 0x40) == 0x40)
5654   3                      {
5655   4                          SET_INTERLACE_MODE();
5656   4                      }
5657   3                      else
5658   3                      {
5659   4                          CLR_INTERLACE_MODE();
5660   4                      }
5661   3                  }
5662   2      
5663   2                  /*
5664   2                  CScalerPageSelect(_PAGE2);
5665   2                  CScalerSetDataPortBit(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VCR_50, ~_BIT6, _BIT6);
5666   2                  */
5667   2      
5668   2                  /*
5669   2                  CTimerWaitForEvent(_EVENT_IVS);
5670   2                  CTimerDelayXms(5);
5671   2                  */
5672   2      
5673   2                  /*
5674   2                  CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_VCR_50, 1, pData, _NON_AUTOINC);
5675   2                  if((pData[0] & 0x40) == 0x40)
5676   2                  {
5677   2                      SET_INTERLACE_MODE();
5678   2                  }
5679   2                  else
5680   2                  {
5681   2                      CLR_INTERLACE_MODE();
5682   2                  }
5683   2                  */
5684   2      // V013 TMDS Patch Note (16) 20100422 Modify End
5685   2      
5686   2                  break;
5687   2      
5688   2      #if(_DP_SUPPORT == _ON)
                      case _SOURCE_DP:
              
                          CScalerPageSelect(_PAGEC);
                          CScalerGetDataPortByte(_PC_DP_ACCESS_PORT_B3, 0x01, 1, pData, _NON_AUTOINC);
                          if((pData[0]&0x04) == 0x04)
                          {
                              SET_INTERLACE_MODE();
                          }
                          else
                          {
                              CLR_INTERLACE_MODE();
                          }
              
                          break;
              #endif
5704   2      
5705   2      #endif
5706   2          }
5707   1      }
5708          //--------------------------------------------------
5709          // Description  : Display FIFO Setting for Frame Sync Mode
5710          // Input Value  : None
5711          // Output Value : None
5712          //--------------------------------------------------
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 95  

5713          #if(_FRC_SUPPORT == _ON)
              void CModeSetFIFOForFrameSync(void)
              {
                  CScalerPageSelect(_PAGE5);
                  CScalerSetByte(_P5_SDRF_MN_DISP_CTRL_CF, 0x05);
                  CTimerDelayXms(100);
                  CScalerSetByte(_P5_SDRF_MN_SDR_STATUS_D0, 0x10);
              }
              #endif
5722          
5723          
5724          #if(_NON_LINEAR_SCALING_FUCTION == _ON)
              //--------------------------------------------------
              // Description  : None
              // Input Value  : None
              // Output Value : None
              //--------------------------------------------------
              void CScalerNonlinearScaleUp(void)
              {
                  BYTE FlatSuFac = 0;
                  BYTE InitSuFac = 0;
                  WORD w1;            // segment1 pixel
                  WORD w2;            // segment2 pixel
                  WORD w3;            // segment3 pixel
                  BYTE SU_Waighting;  //range from 35 ~ 45
              
                  w1 = stDisplayInfo.DHWidth / 5 + 71;
                  w2 = w1 - 71; //w2
                  w3 = stDisplayInfo.DHWidth - SHL(w1, 1) - SHL(w2, 1); //w3
              
                  SU_Waighting = 35 + 4; //+ GET_NONLINEAR_VALUE();
              
                  //Set the initial scale up factor equal to average scale up factor * 0.2
                  //Calculate the scaling factor normalize to 255
                  ((DWORD*)pData)[0] = (DWORD)255 * stModeInfo.IHWidth / stDisplayInfo.DHWidth;
                  InitSuFac = SHR(((DWORD*)pData)[0]*3, 2);
              
                  //Fsu > Csu
                  //Fsu - Csu > 0
                  //Fsu - [Xm - Su(w1 + 1) - Fsu(1 + w2 + w3)]/(w1 + w2) > 0
                  //Fsu(w1 + w2) - [Xm - Su(w1 + 1) - Fsu(1 + w2 + w3)] > 0
                  //Fsu(1 + w1 + 2w2 + w3) - Xm + Su(w1 + 1) > 0
                  //Fsu > [Xm - Su(w1 + 1)]/(1 + w1 + 2w2 + w3)
              
                  ((DWORD*)pData)[3] = 255 * ((DWORD)(stModeInfo.IHWidth - 1) - (DWORD)w1 * InitSuFac / 255) / (w1 + SHL
             -(w2, 1) + w3 - 8);
                  if (((DWORD*)pData)[3] > 254)
                  {
                      return;
                  }
                  else
                  {
                      //FlatSuFac = (SHR(((DWORD*)pData)[0] * 3, 1) > 255) ? 255 : SHR(((DWORD*)pData)[0] * 3, 1);
                      FlatSuFac = (SHR(((DWORD*)pData)[0] * SU_Waighting, 5) > 255) ? 255 : SHR(((DWORD*)pData)[0] * SU_
             -Waighting, 5);
                  }
              
                  //((DWORD *) pData)[3] = 16777216 * (DWORD) InitSuFac / 255 + 0x00000008;
                  ((DWORD *) pData)[3] = 1048576 * (DWORD) InitSuFac / 255;
              
                  CTimerWaitForEvent(_EVENT_DEN_STOP);
                  pData[0] = ((((DWORD *) pData)[3] >> 16) & 0x0f);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 96  

                  pData[1] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                  pData[2] = ((((DWORD *) pData)[3]) & 0xff);
              
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x80); //don't remove this code thus the value can be fill in regis
             -ter
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x80);
                  CScalerWrite(_SU_DATA_PORT_34, 3, pData, _NON_AUTOINC);
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
              
                  //Calculate Csu = (Xm - Su(w1 + 1) - Fsu(1 + w2 + w3))/(w1 + w2)
                  ((DWORD*)pData)[2] = 1048576 * ((DWORD)stModeInfo.IHWidth -
                  (DWORD)InitSuFac * w1 / 255 -
                  (DWORD)FlatSuFac * (w2 + w3 - 1) / 255) / (w1 + w2 - 2);
              
                  //Calculate SU
                  ((DWORD*)pData)[3] = SHR((2097152 * (DWORD)InitSuFac / 255) + 1, 1);
              
                  if (((unsigned long *)pData)[3] > ((unsigned long *) pData)[2])
                  {
                      ((unsigned long *) pData)[3] = 0 - (((unsigned long *) pData)[3] - ((unsigned long *) pData)[2]) /
             - (DWORD)w1; //The MSB is sign bit
                  }
                  else
                  {
                      if (((unsigned long *)pData)[3] > ((unsigned long *) pData)[2])
                      {
                          ((unsigned long *) pData)[3] = 0 - (((unsigned long *) pData)[3] - ((unsigned long *) pData)[2
             -]) / (DWORD)w1; //The MSB is sign bit
                      }
                      else
                      {
                          //Calculate d1
                          ((DWORD*) pData)[3] = (((DWORD*)pData)[2] - ((DWORD*)pData)[3]) / (DWORD)w1;
                      }
              
                      pData[6] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                      pData[7] = (((DWORD *) pData)[3]  & 0xff);
              
                      //Calculate Fsu
                      ((DWORD*)pData)[3] = SHR((2097152 * (DWORD)FlatSuFac / 255) + 1, 1);
              
                      if (((unsigned long *) pData)[3] > ((unsigned long *) pData)[2])
                      {
                          ((DWORD*)pData)[3] = (((DWORD*)pData)[3] - ((DWORD*)pData)[2]) / (DWORD)w2;
                      }
                      else
                      {
                          ((unsigned long *) pData)[3] = 0 - (((unsigned long *) pData)[2] - ((unsigned long *) pData)[3
             -]) / (DWORD)w2;
                      }
                  }
              
                  pData[8] = ((((DWORD *) pData)[3] >> 8) & 0xff);
                  pData[9] = (((DWORD *) pData)[3] & 0xff);
              
                  w1 -= 1;
                  w2 -= 1;
                  w3 -= 1;
              
                  pData[0] = AND(HIBYTE(w1), 0x07);
                  pData[1] = LOBYTE(w1);
                  pData[2] = AND(HIBYTE(w2), 0x07);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 97  

                  pData[3] = LOBYTE(w2);
                  pData[4] = AND(HIBYTE(w3), 0x07);
                  pData[5] = LOBYTE(w3);
              
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x86);  //don't remove this code thus the value can be fill in regi
             -ster
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x86);
                  CScalerWrite(_SU_DATA_PORT_34, 10, pData, _NON_AUTOINC);
                  CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
                  CTimerDelayXms(120);
                  CScalerSetByte(_STATUS0_02, 0x00);
              
              }
              
              #endif  //#if(_NON_LINEAR_SCALING_FUCTION == _ON)
5845          
5846          
5847          
5848          #if((_ASPECT_RATIO_SUPPORT == _ON) && (_MEMORY_WORK_TYPE == _OD_OFF_FRC_OFF))
5849          //--------------------------------------------------
5850          // Description  : Set DHWidth to display
5851          // Input Value  : DHWidth
5852          // Output Value : Return _TRUE if sucess
5853          //--------------------------------------------------
5854          bit CModeSetDHWidthToDisplay(void)
5855          {
5856   1          BYTE option = 0;
5857   1          WORD usDHWidth = 0;
5858   1      
5859   1      // V012 Modify 20100316 Start
5860   1      // V012 Patch Note (2) : Overscan function update.
5861   1      #if(_OVERSCAN_SUPPORT == _ON)
5862   1          stModeInfo.IHWidth = g_usOldIHWidth - (2 * g_ucOverScanH);
5863   1          stModeInfo.IVHeight = g_usOldIVHeight - (2 * g_ucOverScanV);
5864   1      #endif
5865   1      // V012 Modify 20100316 End
5866   1      
5867   1          if(GET_DISP_RATIO() == _ON)
5868   1          {
5869   2             usDHWidth = (DWORD)stModeInfo.IHWidth * _PANEL_DV_HEIGHT / stModeInfo.IVHeight;
5870   2          }
5871   1          else
5872   1          {
5873   2             usDHWidth = _PANEL_DH_WIDTH;
5874   2          }
5875   1      
5876   1          if(usDHWidth <= _PANEL_DH_WIDTH)
5877   1          {
5878   2              CAdjustDisableWatchDog(_WD_ALL);
5879   2              CMiscDisableDoubleBuffer();
5880   2      
5881   2              stDisplayInfo.DHWidth = usDHWidth;
5882   2      
5883   2              if(stModeInfo.IVHeight < stDisplayInfo.DVHeight)
5884   2              {
5885   3                  option |= _BIT0;    // bit 0 : V scale-up
5886   3              }
5887   2              if(stModeInfo.IVHeight > stDisplayInfo.DVHeight)
5888   2              {
5889   3                  option |= _BIT1;    // bit 1 : V scale-down
5890   3              }
5891   2              if(stModeInfo.IHWidth < stDisplayInfo.DHWidth)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 98  

5892   2              {
5893   3                  option |= _BIT2;    // bit 2 : H scale-up
5894   3              }
5895   2              if(stModeInfo.IHWidth > stDisplayInfo.DHWidth)
5896   2              {
5897   3                  option |= _BIT3;    // bit 3 : H scale-down
5898   3              }
5899   2      
5900   2              // Scaling setup
5901   2              CModeSetScaling(option);
5902   2      
5903   2              if(usDHWidth < _PANEL_DH_WIDTH)
5904   2              {
5905   3                  ((WORD *)pData)[0] = ((_PANEL_DH_WIDTH - stDisplayInfo.DHWidth) / 2 + _PANEL_DH_START);
5906   3                  ((WORD *)pData)[1] = (((WORD *)pData)[0] + stDisplayInfo.DHWidth);
5907   3              }
5908   2              else
5909   2              {
5910   3                  ((WORD *)pData)[0] = (_PANEL_DH_START & 0x0fff);
5911   3                  ((WORD *)pData)[1] = (_PANEL_DH_END & 0x0fff);
5912   3              }
5913   2      
5914   2              CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DH_ACT_STA_H_05);
5915   2              CScalerWrite(_DISP_DATA_PORT_2B, 4, pData, _NON_AUTOINC);
5916   2      
5917   2      
5918   2              CTimerWaitForEvent(_EVENT_DVS);
5919   2              CMiscClearStatusRegister();
5920   2              CScalerRead(_STATUS0_02, 1, pData, _NON_AUTOINC);
5921   2              if((pData[0] & 0x03) != 0)
5922   2              {
5923   3                  pData[0] = CFrameSyncDo();
5924   3                  if(pData[0] == 2)
5925   3                  {
5926   4                      CModeResetMode();
5927   4                      return _FALSE;
5928   4                  }
5929   3      
5930   3                  CScalerRead(_STATUS0_02, 1, pData, _NON_AUTOINC);
5931   3                  if((pData[0] & 0x03) != 0)
5932   3                  {
5933   4                      return _FALSE;
5934   4                  }
5935   3              }
5936   2      
5937   2              CMiscEnableDoubleBuffer();
5938   2              CAdjustEnableWatchDog(_WD_ALL);
5939   2          }
5940   1      
5941   1      // V012 Modify 20100316 Start
5942   1      // V012 Patch Note (2) : Overscan function update.
5943   1      #if(_OVERSCAN_SUPPORT == _ON)
5944   1          stModeInfo.IHWidth = g_usOldIHWidth;
5945   1          stModeInfo.IVHeight = g_usOldIVHeight;
5946   1      #endif
5947   1      // V012 Modify 20100316 End
5948   1      
5949   1          return _TRUE;
5950   1      }
5951          
5952          //--------------------------------------------------
5953          // Description  : None
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 99  

5954          // Input Value  : None
5955          // Output Value : None
5956          //--------------------------------------------------
5957          void CScalerDisableNonlinearScaleUp(void)
5958          {
5959   1          ((DWORD*) pData)[0] = 0; //Disable non linear scale up first
5960   1      
5961   1          CScalerSetByte(_SU_ACCESS_PORT_33, 0x8c);
5962   1          CScalerSetByte(_SU_ACCESS_PORT_33, 0x8c);
5963   1          CScalerWrite(_SU_DATA_PORT_34, 4, pData, _NON_AUTOINC);
5964   1          CScalerSetByte(_SU_ACCESS_PORT_33, 0x00);
5965   1      }
5966          
5967          #endif // End of #if((_ASPECT_RATIO_SUPPORT==_ON) && (_MEMORY_WORK_TYPE == _OD_OFF_FRC_OFF))
5968          
5969          
5970          //--------------------------------------------------
5971          // Description  : Mode Stable Detect
5972          // Input Value  : None
5973          // Output Value : return _FALSE if it will do CModeResetMode
5974          //--------------------------------------------------
5975          bit CModeStableDetect(void)
5976          {
5977   1          if(CFrameSyncDetect())
5978   1          {
5979   2              return _FALSE;
5980   2          }
5981   1      
5982   1          if(CModeIsChange())
5983   1          {
5984   2              return _FALSE;
5985   2          }
5986   1      
5987   1      #if(_DP_SUPPORT == _ON)
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DP_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1
             -_DP_PORT))
                  {
                      //Sink CRC Test
                      CDpCRCTest();
              
                      if(CDpActiveCheckFail() == _TRUE)
                      {
                          return _FALSE;
                      }
                  }
              #endif
5999   1      
6000   1      #if(_HDMI_SUPPORT == _ON)
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _
             -D1_HDMI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_DV
             -I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D0_DVI_I_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _D1_DVI_I_
             -PORT))
                  {
                      if(CModeHdmiStablePolling() == _FALSE)
                      {
                          return _FALSE;
                      }
                  }
              #endif
6009   1      
6010   1          return _TRUE;
6011   1      }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 100 

6012          
6013          
6014          #if(_LOW_FRAME_RATE_SUPPORT == _ON)
              
              #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
              //--------------------------------------------------
              // Description  : Check Low Frame Rate
              // Input Value  : None
              // Output Value : return _TRUE if it is low frame rate
              //--------------------------------------------------
              bit CModeCheckLowFrameRate(void)
              {
                  bit bOrgM2PLLState = 0;
                  BYTE ucSyncType = 0;
                  BYTE ucStatus1 = 0xFF;
                  BYTE ucStatus2 = 0xFF;
              
              #if(_MCU_TYPE == _REALTEK_EMBEDDED)
                  CMcuSelectFlashClk(_XTAL_CLK);
              #endif
              
                  CScalerPageSelect(_PAGE1);
              
                  // Record M2PLL State
                  if((bit)CScalerGetBit(_P1_M2PLL_WD_E5, _BIT0))
                  {
                      CScalerSetBit(_P1_M2PLL_WD_E5, ~_BIT0, 0x00);
                      bOrgM2PLLState = _TRUE;
                  }
              
                  // Switch to M2PLL Frequency
                  CScalerSetByte(_P1_M2PLL_M_E0, 0x59);
                  CScalerSetByte(_P1_M2PLL_N_E1, 0x13);
                  CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, _BIT2);
              
                  // Delay for M2PLL stable
                  CTimerDelayXms(50);
              
              #if(_MCU_TYPE == _REALTEK_EMBEDDED)
                  CMcuSelectFlashClk(_FLASH_CLK);
              #endif
              
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_YPBPR_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_YPBPR_PORT))
                  {
                      // Enable Hsync Type Detection Auto Run
                      CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, 0x00);
                      CScalerSetBit(_SYNC_SELECT_47, ~(_BIT6 | _BIT5), 0x00);
                      CScalerSetBit(_SYNC_SELECT_47, ~_BIT6, _BIT6);
              
                      // V012 Modify 20100329 Start
                      // V012 Patch Note (19) : Adjust polling time of Auto Run Typer according to different Crystal fre
             -quency.
                      /*
                      // Check the result of Auto Run
                      if(CTimerPollingEventProc(180, CMiscHsyncTypeAutoRunFlagPollingEvent))
                      */
                      // Check the result of Auto Run
                      if(CTimerPollingFlagProc(_SP_AUTORUN_TIME_OUT, _PAGE_COMMON, _VSYNC_COUNTER_LEVEL_MSB_4C, _BIT7, _
             -TRUE) == _TRUE)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 101 

                      // V012 Modify 20100329 End
                      {
                          ucSyncType = (CScalerGetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, 0xff) & 0x70) >> 4;
              
                          if((ucSyncType != _NO_SIGNAL) && (ucSyncType != _NOT_SUPPORT) && (ucSyncType != _HSYNC_WITHOUT
             -_VS))
                          {
                              // Read measurement status bit
                              if(CModeMeasureReady())
                              {
                                  CScalerRead(_MEAS_HS_PERIOD_H_52, 1, &ucStatus1, _NON_AUTOINC);
                                  CScalerRead(_MEAS_VS_PERIOD_H_54, 1, &ucStatus2, _NON_AUTOINC);
                              }
                          }
                      }
                  }
                  else
                  {
                      // Read measurement status bit
                      if(CModeMeasureReady())
                      {
                          CScalerRead(_MEAS_HS_PERIOD_H_52, 1, &ucStatus1, _NON_AUTOINC);
                          CScalerRead(_MEAS_VS_PERIOD_H_54, 1, &ucStatus2, _NON_AUTOINC);
                      }
              
                  }   // End of if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
              
              #if(_MCU_TYPE == _REALTEK_EMBEDDED)
                  CMcuSelectFlashClk(_XTAL_CLK);
              #endif
              
                  // Switch to Xtal Frequency
                  CScalerPageSelect(_PAGE1);
              
                  // V012 Modify 20100331 Start
                  // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock with
             - M2PLL.
                  /*
                  CScalerSetByte(_P1_M2PLL_M_E0, 0x69);
                  CScalerSetByte(_P1_M2PLL_N_E1, 0x13);
                  CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, 0x00);
                  */
                  CScalerSetByte(_P1_M2PLL_M_E0, (_M2PLL_PLL_M-2));
                  CScalerSetByte(_P1_M2PLL_N_E1, (((_M2PLL_PLL_O >> 1) << 4) | (_M2PLL_PLL_N-2)));
              
                  // V013 VGA Patch Note (6) Modify 20100428 Start
                  // Patch Reason : Update V012 Patch Note (21) use m2pll/10 as internal clock just in analog source.
                  /*
                  CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, _INTERNAL_CLK_FLAG);
                  */
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A
             -0_YPBPR_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT) || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A
             -1_YPBPR_PORT))
                  {
              
                      if(bOrgM2PLLState)
                      {
                          CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, 0x00);
                      }
                      else
                      {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 102 

                          CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, _INTERNAL_CLK_FLAG);
                      }
                      // V013 VGA Patch Note (6) Modify 20100428 End
                  }
                  else
                  {
                      CScalerSetBit(_FIFO_FREQUENCY_22, ~_BIT2, 0x00);
                  }
                  // V013 VGA Patch Note (6) Modify 20100428 End
              
                  // V012 Modify 20100331 End
              
                  // Reset M2PLL State
                  if(bOrgM2PLLState == _TRUE)
                  {
                      CScalerSetBit(_P1_M2PLL_WD_E5, ~_BIT0, _BIT0);
                  }
              
                  // Delay for M2PLL stable
                  CTimerDelayXms(50);
              
              #if(_MCU_TYPE == _REALTEK_EMBEDDED)
                  CMcuSelectFlashClk(_FLASH_CLK);
              #endif
              
                  // Reset Sync Processor Auto Run
                  if((GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_VGA_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_VGA_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A0_YPBPR_PORT)
                  || (GET_INPUTPORT_TYPE(g_ucSearchIndex) == _A1_YPBPR_PORT))
                  {
                      // Enable Hsync Type Detection Auto Run
                      CScalerSetBit(_STABLE_MEASURE_4F, ~_BIT0, 0x00);
                      CScalerSetBit(_SYNC_SELECT_47, ~(_BIT6 | _BIT5), 0x00);
                      CScalerSetBit(_SYNC_SELECT_47, ~_BIT6, _BIT6);
              
                      // V016 VGA Patch Note (14) Modify 20100831 Start
                      // Patch Reason : Wait for 0x4C-bit7 after start Auto Run.
                      CTimerPollingFlagProc(_SP_AUTORUN_TIME_OUT, _PAGE_COMMON, _VSYNC_COUNTER_LEVEL_MSB_4C, _BIT7, _TRU
             -E);
                      // V016 VGA Patch Note (14) Modify 20100831 End
              
                      // Clear Hsync Type Detection Flag
                      CScalerSetByte(_HSYNC_TYPE_DETECTION_FLAG_4E, 0xFF);
                  }
              
                  // Check Vsync Time Out Flag
                  if((bit)(ucStatus1 & _BIT4) || (bit)(ucStatus2 & _BIT4) || (bit)(ucStatus2 & _BIT5))
                  {
                      return _FALSE;
                  }
              
                  return _TRUE;
              }
              #endif  // End of #if((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RT
             -D248xRD))
              
              #endif  // End of #if(_LOW_FRAME_RATE_SUPPORT == _ON)
6186          
6187          
6188          //--------------------------------------------------
6189          // Description  : Check if the picked mode frame sync
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 103 

6190          // Input Value  : Mode table information
6191          // Output Value : _TRUE, Frame Sync OK
6192          //                _FALSE, Frame Sync NG
6193          //--------------------------------------------------
6194          BYTE CModeCheckModeVGA(BYTE ucModeIndex)
6195          {
6196   1          if(ucModeIndex >= _MAX_PRESET_MODE)
6197   1          {
6198   2              return _CHECK_MODE_INDEX_ERROR;
6199   2          }
6200   1      
6201   1          // Check IHTotal due to ADC Clock Limit
6202   1          if(tINPUTMODE_PRESET_TABLE[ucModeIndex].IHTotal > g_usAdcClockLimit)
6203   1          {
6204   2              return _CHECK_MODE_ADC_SPEED_ERROR;
6205   2          }
6206   1      
6207   1          if(tINPUTMODE_PRESET_TABLE[ucModeIndex].IHTotal < (tINPUTMODE_PRESET_TABLE[ucModeIndex].IHStartPos + t
             -INPUTMODE_PRESET_TABLE[ucModeIndex].IHWidth))
6208   1          {
6209   2              return _CHECK_MODE_TABLE_INFO_ERROR;
6210   2          }
6211   1      
6212   1      #if(_FRC_SUPPORT == _OFF)
6213   1      
6214   1          stModeInfo.IVStartPos = tINPUTMODE_PRESET_TABLE[ucModeIndex].IVStartPos;
6215   1          stModeInfo.IVHeight = tINPUTMODE_PRESET_TABLE[ucModeIndex].IVHeight;
6216   1          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
6217   1      
6218   1          CFrameSyncModifyDVStartPos(_DVSTART_POS_ADJUSTING);
6219   1      
6220   1          // Calculate DVStart due to display ratio
6221   1          ((DWORD *)pData)[3] = (DWORD)stDisplayInfo.DVStartPos * 10 * stModeInfo.IVHeight / stDisplayInfo.DVHei
             -ght;
6222   1      
6223   1          // Check Frame Sync Formula : IVToDVdelay = IVStart + 2.5 - DVStart > 1
6224   1          if((stModeInfo.IVStartPos * 10 + 15) < ((DWORD *)pData)[3])
6225   1          {
6226   2              return _CHECK_MODE_FRAME_SYNC_ERROR;
6227   2          }
6228   1      
6229   1          // New IVStart = Original IVStart - IVToDVdelay => DVStart - 2.5
6230   1          // Measured IVTotal must be greater than (New IVStart + IVHeight)
6231   1          if((stModeInfo.IVTotal * 10) < ((((DWORD *)pData)[3] - 25) + (stModeInfo.IVHeight * 10)))
6232   1          {
6233   2              return _CHECK_MODE_FRAME_SYNC_ERROR;
6234   2          }
6235   1      
6236   1      #endif
6237   1      
6238   1          return _CHECK_MODE_SUCCESS;
6239   1      }
6240          
6241          //--------------------------------------------------
6242          // Description  : Additional Search after acceptive
6243          //                search with result checking.
6244          // Input Value  : Mode Table Count
6245          // Output Value : Mode Index
6246          //--------------------------------------------------
6247          BYTE CModeAdditionalSearch(BYTE ucModeIndex)
6248          {
6249   1          BYTE ucModeCnt = 0;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 104 

6250   1          BYTE ucResult = 0xFF;
6251   1          WORD usIHWidth = 0;
6252   1          WORD usIVHeight = 0;
6253   1      
6254   1          ucResult = CModeCheckModeVGA(ucModeIndex);
6255   1      
6256   1          if((g_usCurrIVHeight > tINPUTMODE_PRESET_TABLE[ucModeIndex].IVHeight)
6257   1          || ((ucResult != _CHECK_MODE_SUCCESS) && (ucResult != _CHECK_MODE_ADC_SPEED_ERROR)))
6258   1          {
6259   2              ucModeIndex = _MODE_NOSUPPORT;
6260   2      
6261   2              for(ucModeCnt = 0; ucModeCnt < _MAX_PRESET_MODE; ucModeCnt++)
6262   2              {
6263   3                  if(tINPUTMODE_PRESET_TABLE[ucModeCnt].IVHeight >= g_usCurrIVHeight)
6264   3                  {
6265   4                      if(CModeCheckModeVGA(ucModeCnt) == _CHECK_MODE_SUCCESS)
6266   4                      {
6267   5                          if(stModeInfo.IVHeight >= usIVHeight)
6268   5                          {
6269   6                              if(tINPUTMODE_PRESET_TABLE[ucModeCnt].IHWidth >= usIHWidth)
6270   6                              {
6271   7                                  usIHWidth = tINPUTMODE_PRESET_TABLE[ucModeCnt].IHWidth;
6272   7                                  usIVHeight = stModeInfo.IVHeight;
6273   7                                  ucModeIndex = ucModeCnt;
6274   7                              }
6275   6                          }
6276   5                      }
6277   4                  }
6278   3              }
6279   2          }
6280   1          else if(ucResult == _CHECK_MODE_ADC_SPEED_ERROR)
6281   1          {
6282   2              usIVHeight = tINPUTMODE_PRESET_TABLE[ucModeIndex].IVHeight;
6283   2              ucModeIndex = _MODE_NOSUPPORT;
6284   2      
6285   2              for(ucModeCnt = 0; ucModeCnt < _MAX_PRESET_MODE; ucModeCnt++)
6286   2              {
6287   3                  if(tINPUTMODE_PRESET_TABLE[ucModeCnt].IVHeight == usIVHeight)
6288   3                  {
6289   4                      if(CModeCheckModeVGA(ucModeCnt) == _CHECK_MODE_SUCCESS)
6290   4                      {
6291   5                          if(tINPUTMODE_PRESET_TABLE[ucModeCnt].IHWidth >= usIHWidth)
6292   5                          {
6293   6                              usIHWidth = tINPUTMODE_PRESET_TABLE[ucModeCnt].IHWidth;
6294   6                              ucModeIndex = ucModeCnt;
6295   6                          }
6296   5                      }
6297   4                  }
6298   3              }
6299   2          }
6300   1      
6301   1          return ucModeIndex;
6302   1      }
6303          
6304          //--------------------------------------------------
6305          // Description  : VGA Initial Setting
6306          // Input Value  : None
6307          // Output Value : None
6308          //--------------------------------------------------
6309          void CModeInitialVGA(void)
6310          {
6311   1          // V014 VGA Patch Note (6) Modify 20100527 Start
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 105 

6312   1          // Patch Reason : Modify Video Mode Can't Light On
6313   1          /*
6314   1          // V013 VGA Patch Note (23) Modify 20100513 Start
6315   1          // Patch Reason : For Video Mode Clamp Position Setting Flow
6316   1          bit bVideoModeFlg = _FALSE;
6317   1          // V013 VGA Patch Note (23) Modify 20100513 End
6318   1          */
6319   1          // V014 VGA Patch Note (6) Modify 20100527 End
6320   1      
6321   1          if(GET_VGA_INITIAL() == _TRUE)
6322   1          {
6323   2              // Calculate IH Frequency
6324   2              CScalerRead(_STABLE_PERIOD_H_50, 2, pData, _AUTOINC);
6325   2              stModeInfo.IHCount = ((pData[0] & 0x07) << 8) | pData[1];
6326   2      
6327   2              // V012 Modify 20100331 Start
6328   2              // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock 
             -with M2PLL.
6329   2              /*
6330   2              stModeInfo.IHFreq = (WORD)((DWORD)_RTD_XTAL * 10 * 2 / stModeInfo.IHCount);
6331   2              */
6332   2              stModeInfo.IHFreq = (WORD)((DWORD)_INTERNAL_SYSTEM_CLK * 10 * 2 / stModeInfo.IHCount);
6333   2              // V012 Modify 20100331 End
6334   2      
6335   2              stModeInfo.IHFreq = (stModeInfo.IHFreq >> 1) + (stModeInfo.IHFreq & 0x01);
6336   2      
6337   2              // Calculate ADC Clock by Frequency
6338   2              g_usAdcClockLimit = (WORD)(((DWORD)_ADC_SAMPLE_CLOCK_LIMIT / stModeInfo.IHFreq / 4) * 4);
6339   2      
6340   2              // Check ADC Clock Limit
6341   2              if(g_usAdcClockLimit > _PIXEL_WIDTH_LIMIT)
6342   2              {
6343   3                  g_usAdcClockLimit = _PIXEL_WIDTH_LIMIT;
6344   3              }
6345   2      
6346   2              // V014 VGA Patch Note (6) Modify 20100527 Start
6347   2              // Patch Reason : Modify Video Mode Can't Light On
6348   2              /*
6349   2              // V013 VGA Patch Note (23) Modify 20100513 Start
6350   2              // Patch Reason : For Video Mode Clamp Position Setting Flow
6351   2              if(stModeInfo.ModeCurr < _MAX_YPBPR_MODE) // Current Mode Is Video Mode
6352   2              {
6353   2                  bVideoModeFlg = _TRUE;
6354   2                  // Update Video Mode Clamp Position
6355   2                  CYPbPrModeClampPositionSetting();
6356   2              }
6357   2              else
6358   2              {
6359   2                  bVideoModeFlg = _FALSE;
6360   2                  stModeInfo.ModeCurr = 0;
6361   2              }
6362   2              // V013 VGA Patch Note (23) Modify 20100513 End
6363   2              */
6364   2              // V014 VGA Patch Note (6) Modify 20100527 End
6365   2      
6366   2      #if(_YPBPR_SUPPORT == _ON)
6367   2              if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
6368   2              {
6369   3                  stModeUserData.Clock = tYPBPR_MODE_TABLE[stModeInfo.ModeCurr].IHTotal;
6370   3                  CAdjustAdcClock(stModeUserData.Clock);
6371   3              }
6372   2              else
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 106 

6373   2      #endif
6374   2              {
6375   3                  // V014 VGA Patch Note (6) Modify 20100527 Start
6376   3                  // Patch Reason : Modify Video Mode Can't Light On
6377   3                  /*
6378   3                  // V013 VGA Patch Note (23) Modify 20100513 Start
6379   3                  // Patch Reason : For Video Mode Clamp Position Setting Flow
6380   3                  /*
6381   3                  stModeUserData.Clock = g_usAdcClockLimit;
6382   3                  * /
6383   3                  if(bVideoModeFlg == _TRUE)
6384   3                  {
6385   3                      stModeUserData.Clock = tYPBPR_MODE_TABLE[stModeInfo.ModeCurr].IHTotal;
6386   3                  }
6387   3                  else
6388   3                  {
6389   3                      stModeUserData.Clock = g_usAdcClockLimit;
6390   3                  }
6391   3                  // V013 VGA Patch Note (23) Modify 20100513 End
6392   3                  */
6393   3                  stModeUserData.Clock = g_usAdcClockLimit;
6394   3                  // V014 VGA Patch Note (6) Modify 20100527 End
6395   3      
6396   3                  CAdjustAdcClock(stModeUserData.Clock);
6397   3              }
6398   2      
6399   2              // Adjust ADC Setting (Include Clamp Enable)
6400   2              CAdjustADCSetting();
6401   2      
6402   2              // bit3~bit2: Set input pixel format, bit1: select analog or digtal input
6403   2              CScalerSetBit(_VGIP_CTRL_10, ~(_BIT3 | _BIT2 | _BIT1), 0);
6404   2      
6405   2              CScalerPageSelect(_PAGE0);
6406   2      
6407   2              if(((bit)CScalerGetBit(_STABLE_PERIOD_H_50, _BIT6) ^ (bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3)) =
             -= _TRUE)
6408   2              {
6409   3                  // As negative HS,we must clear CR[P0_F4] BIT6 and set schmitt trigger by high level to avoid 
             -noise
6410   3                  CScalerSetBit(_P0_HS_SCHMITT_TRIGGER_CTRL_F4, ~_BIT6, 0x00);
6411   3              }
6412   2              else
6413   2              {
6414   3                  CScalerSetBit(_P0_HS_SCHMITT_TRIGGER_CTRL_F4, ~_BIT6, _BIT6);
6415   3              }
6416   2      
6417   2              // Wait for ADC clamp stable and interlace flag update
6418   2              CTimerWaitForEvent(_EVENT_IVS);
6419   2              CTimerWaitForEvent(_EVENT_IVS);
6420   2              CTimerWaitForEvent(_EVENT_IVS);
6421   2      
6422   2              if(CScalerGetBit(_HSYNC_TYPE_DETECTION_FLAG_4E, _BIT0) == _BIT0)
6423   2              {
6424   3                  // Select Hsync Measure Source to ADC_HS
6425   3                  CScalerSetBit(_SYNC_CTRL_49, ~_BIT2, 0x00);
6426   3              }
6427   2      
6428   2              CLR_VGA_INITIAL();
6429   2          }
6430   1      }
6431          
6432          //--------------------------------------------------
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 107 

6433          // Description  : Check if the height measured is OK
6434          //                This function also modify the height if
6435          //                the measured height is abnormal.
6436          // Input Value  : Measured Height
6437          // Output Value : Verified Height
6438          //--------------------------------------------------
6439          WORD CModeIVHeightVerify(WORD usIVHeight)
6440          {
6441   1          BYTE i = 0;
6442   1      
6443   1          ((WORD *)pData)[0] = 0; // Reference height to get from the mode table
6444   1          ((WORD *)pData)[1] = 0xFFFF; // Min difference value for recording
6445   1          ((WORD *)pData)[2] = (WORD)((DWORD)stModeInfo.IVTotal * _MAX_IVHEIGHT_RATIO / 1000); // IVHeight limit
6446   1      
6447   1          for(i = 0; i < _MAX_PRESET_MODE; i++)
6448   1          {
6449   2              if((tINPUTMODE_PRESET_TABLE[i].IVHeight < ((WORD *)pData)[2]) && (abs(usIVHeight - tINPUTMODE_PRES
             -ET_TABLE[i].IVHeight) < ((WORD *)pData)[1]))
6450   2              {
6451   3                  ((WORD *)pData)[1] = abs(usIVHeight - tINPUTMODE_PRESET_TABLE[i].IVHeight);
6452   3                  ((WORD *)pData)[0] = tINPUTMODE_PRESET_TABLE[i].IVHeight;
6453   3              }
6454   2          }
6455   1      
6456   1          if(usIVHeight < ((WORD *)pData)[2])
6457   1          {
6458   2              if(abs(usIVHeight - ((WORD *)pData)[0]) > _MODE_IVHEIGHT_TOLERANCE)
6459   2              {
6460   3                  return usIVHeight;
6461   3              }
6462   2              else
6463   2              {
6464   3                  return ((WORD *)pData)[0];
6465   3              }
6466   2          }
6467   1      
6468   1          return ((WORD *)pData)[0];
6469   1      }
6470          
6471          //--------------------------------------------------
6472          // Description  : Check stored user data for frame sync
6473          //                Reset user data and centered data if frame sync failed
6474          // Input Value  : None
6475          // Output Value : None
6476          //--------------------------------------------------
6477          void CModeCheckUserData(void)
6478          {
6479   1          BYTE ucModeTemp = 0;
6480   1      
6481   1          if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
6482   1          {
6483   2              ucModeTemp = stModeInfo.ModeCurr;
6484   2          }
6485   1          else if(GET_MODE_SEARCH_TYPE() == _USER_MODE_TYPE)
6486   1          {
6487   2              CEepromLoadUserFIFOModeData((stModeInfo.ModeCurr / 4), pData);
6488   2              ucModeTemp = pData[(stModeInfo.ModeCurr % 4) * 4];
6489   2          }
6490   1      
6491   1          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
6492   1      
6493   1          CFrameSyncModifyDVStartPos(_DVSTART_POS_ADJUSTING);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 108 

6494   1      
6495   1          // Calculate DVStart due to display ratio
6496   1          ((DWORD *)pData)[3] = (DWORD)stDisplayInfo.DVStartPos * 10 * tINPUTMODE_PRESET_TABLE[ucModeTemp].IVHei
             -ght / stDisplayInfo.DVHeight;
6497   1      
6498   1          if((stModeUserCenterData.CenterClock > g_usAdcClockLimit) ||
6499   1             (stModeUserData.Clock > g_usAdcClockLimit) ||
6500   1             (CAutoCheckCaptureStart(stModeUserCenterData.CenterHPos, stModeUserData.Clock) == _FALSE) ||
6501   1             (CAutoCheckCaptureStart(stModeUserCenterData.CenterHPos, stModeUserCenterData.CenterClock) == _FALS
             -E) ||
6502   1      
6503   1             // V013 VGA Patch Note (26) Modify 20100517 Start
6504   1             // Patch Reason : Fix if clock is too large and causes over large picture.
6505   1             // As the timing table lists, all the modes have stModeInfo.IHWidth / stModeUserData.Clock > 70%.
6506   1      
6507   1             // V014 VGA Patch Note (3) Modify 20100526 Start
6508   1             // Patch Reason : Change the compare ratio to 60%, as 720p50 was found to have about 65% of width/H
             -Total ratio.
6509   1             /*
6510   1             ((DWORD)stModeUserData.Clock * 7 > (DWORD)stModeInfo.IHWidth * 10) ||
6511   1             ((DWORD)stModeUserCenterData.CenterClock * 7 > (DWORD)stModeInfo.IHWidth * 10) ||
6512   1              */
6513   1             ((DWORD)stModeUserData.Clock * 6 > (DWORD)stModeInfo.IHWidth * 10) ||
6514   1             ((DWORD)stModeUserCenterData.CenterClock * 6 > (DWORD)stModeInfo.IHWidth * 10) ||
6515   1             // V014 VGA Patch Note (3) Modify 20100526 End
6516   1      
6517   1             // V013 VGA Patch Note (26) Modify 20100517 End
6518   1      
6519   1             ((stModeUserData.VPosition * 10 + 15) < ((DWORD *)pData)[3])) // Check Frame Sync Formula : IVToDVd
             -elay = IVStart + 2.5 - DVStart > 1
6520   1          {
6521   2              // Load default user data
6522   2              CLR_AUTO_FLAG();
6523   2              CLR_AUTO_FAIL_COUNT();
6524   2      
6525   2      // V014 VGA Patch Note (6) Modify 20100527 Start
6526   2      // Patch Reason : Modify Video Mode Can't Light On
6527   2      #if(_COLOR_FORMAT_CONVERT == _ON)
6528   2              CLR_MODE_COLOR_FORMAT_FLAG();
6529   2      #endif
6530   2      // V014 VGA Patch Note (6) Modify 20100527 End
6531   2      
6532   2              stModeUserData.HPosition = tINPUTMODE_PRESET_TABLE[ucModeTemp].IHStartPos;
6533   2              stModeUserData.VPosition = tINPUTMODE_PRESET_TABLE[ucModeTemp].IVStartPos;
6534   2              stModeUserData.Clock = tINPUTMODE_PRESET_TABLE[ucModeTemp].IHTotal;
6535   2              stModeUserData.Phase = 0;
6536   2              CEepromSaveModeData(stModeInfo.ModeCurr);
6537   2      
6538   2              // Load default center data
6539   2              stModeUserCenterData.CenterClock = tINPUTMODE_PRESET_TABLE[ucModeTemp].IHTotal;
6540   2              stModeUserCenterData.CenterHPos = tINPUTMODE_PRESET_TABLE[ucModeTemp].IHStartPos;
6541   2              stModeUserCenterData.CenterVPos = tINPUTMODE_PRESET_TABLE[ucModeTemp].IVStartPos;
6542   2              stModeUserCenterData.CenterPhase = 0;
6543   2              CEepromSaveCenterModeData(stModeInfo.ModeCurr);
6544   2          }
6545   1      }
6546          
6547          // V012 Modify 20100304 Start
6548          // V012 Patch Note (1) : Add RGB/YUV color space convert function.
6549          #if(_COLOR_FORMAT_CONVERT == _ON)
6550          //--------------------------------------------------
6551          // Description  : Color Format Convert for RGB/YUV
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 109 

6552          // Input Value  : None
6553          // Output Value : None
6554          //--------------------------------------------------
6555          void CModeColorFormatConvert(void)
6556          {
6557   1          // V013 VGA Patch Note (2) 20100407 Modify Start
6558   1          // Patch Reason : Load ADC Gain/Offset value as color space conversion
6559   1          BYTE ucTemp = 0;
6560   1          // V013 VGA Patch Note (2) 20100407 Modify End
6561   1      
6562   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR) || (GET_INPUTSOURCE_TYPE() == _SOURCE_VGA))
6563   1          {
6564   2              if(GET_COLOR_FORMAT_STATUS() == g_bColorFormatStatus)
6565   2              {
6566   3                  return;
6567   3              }
6568   2      
6569   2              if(GET_COLOR_FORMAT_STATUS() == _YUV_COLOR_FORMAT)
6570   2              {
6571   3                  CModeSetRGBToYUV();
6572   3      
6573   3                  // V013 VGA Patch Note (2) 20100407 Modify Start
6574   3                  // Patch Reason : Load ADC Gain/Offset value as color space conversion
6575   3                  ucTemp = GET_INPUTSOURCE_TYPE();
6576   3                  SET_INPUTSOURCE_TYPE(_SOURCE_YPBPR);
6577   3                  // V013 VGA Patch Note (2) 20100407 Modify End
6578   3              }
6579   2              else
6580   2              {
6581   3                  CModeSetYUVToRGB();
6582   3      
6583   3                  // V013 VGA Patch Note (2) 20100407 Modify Start
6584   3                  // Patch Reason : Load ADC Gain/Offset value as color space conversion
6585   3                  ucTemp = GET_INPUTSOURCE_TYPE();
6586   3                  SET_INPUTSOURCE_TYPE(_SOURCE_VGA);
6587   3                  // V013 VGA Patch Note (2) 20100407 Modify End
6588   3              }
6589   2      
6590   2              // V013 VGA Patch Note (2) 20100407 Modify Start
6591   2              // Patch Reason : Load ADC Gain/Offset value as color space conversion
6592   2              CEepromLoadAdcData();
6593   2              SET_INPUTSOURCE_TYPE(ucTemp);
6594   2              CAdjustAdcGain();
6595   2              CAdjustAdcOffset();
6596   2      #if _DEBUG_MESSAGE_SUPPORT
6597   2                      
6598   2                      CDebugMessage("CModeColorFormatConvert", 0);
6599   2                      CDebugMessage("stAdcData.AdcGain.[_RED]",stAdcData.AdcGain[_RED]);
6600   2                      CDebugMessage("stAdcData.AdcGain.[_GREEN]",stAdcData.AdcGain[_GREEN]);
6601   2                      CDebugMessage("stAdcData.AdcGain.[_BLUE]",stAdcData.AdcGain[_BLUE]);
6602   2                      
6603   2                      CDebugMessage("stAdcData.AdcOffset.[_RED]",stAdcData.AdcOffset[_RED]);
6604   2                      CDebugMessage("stAdcData.AdcOffset.[_GREEN]",stAdcData.AdcOffset[_GREEN]);
6605   2                      CDebugMessage("stAdcData.AdcOffset.[_BLUE]",stAdcData.AdcOffset[_BLUE]);
6606   2                      
6607   2                      
6608   2                      
6609   2                      
6610   2                      
6611   2      #endif
6612   2              // V013 VGA Patch Note (2) 20100407 Modify End
6613   2      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 110 

6614   2              g_bColorFormatStatus = GET_COLOR_FORMAT_STATUS();
6615   2          }
6616   1      }
6617          
6618          //--------------------------------------------------
6619          // Description  : RGB to YUV Setting
6620          // Input Value  : None
6621          // Output Value : None
6622          //--------------------------------------------------
6623          void CModeSetRGBToYUV()
6624          {
6625   1          CScalerCodeW(tYPBPR_TABLE_SET_SCALER);
6626   1          CAdjustBrightness(stConBriData.Brightness);
6627   1          CAdjustContrast(stConBriData.Contrast);
6628   1      }
6629          
6630          //--------------------------------------------------
6631          // Description  : YUV to RGB Setting
6632          // Input Value  : None
6633          // Output Value : None
6634          //--------------------------------------------------
6635          void CModeSetYUVToRGB()
6636          {
6637   1      #if(_SCALER_TYPE == _RTD2472D)
6638   1      
6639   1          CScalerSetByte(_YUV2RGB_CTRL_9C, 0x02);
6640   1          CScalerSetByte(_YUV_RGB_ACCESS_9D, 0x00);
6641   1          CScalerSetByte(_YUV2RGB_CTRL_9C, 0x00);
6642   1      
6643   1      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
              
                  CScalerPageSelect(_PAGE7);
                  CScalerSetByte(_P7_YUV2RGB_CTRL_BF, 0x02);
                  CScalerSetByte(_P7_YUV2RGB_ACCESS_C0, 0x00);
                  CScalerSetByte(_P7_YUV2RGB_CTRL_BF, 0x00);
              
              #endif
6651   1      
6652   1          CScalerPageSelect(_PAGE0);
6653   1          CScalerSetByte(_P0_ADC_V_BIAS1_CD, 0x09);
6654   1      
6655   1          // V015 VGA Patch Note (1) Modify 20100607 Start
6656   1          // Patch Reason : Write register by set bit method
6657   1          /*
6658   1          CScalerSetByte(_P0_ADC_RED_CTL_CF, 0x40);
6659   1          CScalerSetByte(_P0_ADC_GREEN_CTL_D0, 0x40);
6660   1          CScalerSetByte(_P0_ADC_BLUE_CTL_D1, 0x40);
6661   1          */
6662   1          CScalerSetBit(_P0_ADC_RED_CTL_CF, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6663   1          CScalerSetBit(_P0_ADC_GREEN_CTL_D0, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6664   1          CScalerSetBit(_P0_ADC_BLUE_CTL_D1, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6665   1          // V015 VGA Patch Note (1) Modify 20100607 End
6666   1      }
6667          
6668          // V014 VGA Patch Note (6) Modify 20100527 Start
6669          // Patch Reason : Modify Video Mode Can't Light On
6670          //--------------------------------------------------
6671          // Description  : Color Format Convert for RGB/YUV By User Setting Last Time
6672          // Input Value  : None
6673          // Output Value : None
6674          //--------------------------------------------------
6675          void CModeGetCurrentModeColorFormat(void)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 111 

6676          {
6677   1          // V016 VGA Patch Note (11) Modify 20100830 Start
6678   1          // Patch Reason : Modify Color Space Load Data Position For OverScan.
6679   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR) || (GET_INPUTSOURCE_TYPE() == _SOURCE_VGA))
6680   1          {
6681   2              if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
6682   2              {
6683   3                  g_bColorFormatStatus = _YUV_COLOR_FORMAT;
6684   3              }
6685   2              else
6686   2              {
6687   3                  g_bColorFormatStatus = _RGB_COLOR_FORMAT;
6688   3              }
6689   2          }
6690   1          // V016 VGA Patch Note (11) Modify 20100830 End
6691   1      
6692   1          // Check current mode color format
6693   1          if(GET_MODE_COLOR_FORMAT_FLAG() == _YUV_COLOR_FORMAT)
6694   1          {
6695   2              SET_COLOR_FORMAT_STATUS(_YUV_COLOR_FORMAT);
6696   2          }
6697   1          else
6698   1          {
6699   2              SET_COLOR_FORMAT_STATUS(_RGB_COLOR_FORMAT);
6700   2          }
6701   1      }
6702          // V014 VGA Patch Note (6) Modify 20100527 End
6703          
6704          #endif  // End of #if(_COLOR_FORMAT_CONVERT == _ON)
6705          // V012 Modify 20100304 End
6706          
6707          // V013 VGA Patch Note (10) 20100416 Modify Start
6708          // Patch Reason : Support Auto Config For Yuv Color.
6709          //--------------------------------------------------
6710          // Description  : Switch Yuv to Rgb For Auto
6711          // Input Value  : Color Space Type
6712          // Output Value : None
6713          //--------------------------------------------------
6714          #if(_YUV_AUTO_CONFIG_SUPPORT == _ON)
6715          void CModeYuvRgbSwitch(BYTE ucColorType)
6716          {
6717   1          BYTE ucSourceTemp = _SOURCE_NONE;
6718   1      
6719   1      #if(_YPBPR_SUPPORT == _ON)
6720   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
6721   1      #else
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
              #endif
6724   1          {
6725   2              if(ucColorType == _RGB_COLOR_FORMAT)
6726   2              {
6727   3                  if(CModeGetColorSpaceType() == _YUV_COLOR_FORMAT)
6728   3                  {
6729   4                      // Switch to RGB Color Type
6730   4                      CScalerPageSelect(_PAGE0);
6731   4      
6732   4                      // V015 VGA Patch Note (1) Modify 20100607 Start
6733   4                      // Patch Reason : Write register by set bit method
6734   4                      /*
6735   4                      CScalerSetByte(_P0_ADC_RED_CTL_CF, _BIT6);
6736   4                      CScalerSetByte(_P0_ADC_GREEN_CTL_D0, _BIT6);
6737   4                      CScalerSetByte(_P0_ADC_BLUE_CTL_D1, _BIT6);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 112 

6738   4                      */
6739   4                      CScalerSetBit(_P0_ADC_RED_CTL_CF, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6740   4                      CScalerSetBit(_P0_ADC_GREEN_CTL_D0, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6741   4                      CScalerSetBit(_P0_ADC_BLUE_CTL_D1, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6742   4                      // V015 VGA Patch Note (1) Modify 20100607 End
6743   4      
6744   4                      // Adjust RGB Gain And Offset
6745   4                      ucSourceTemp = GET_INPUTSOURCE_TYPE();
6746   4                      SET_INPUTSOURCE_TYPE(_SOURCE_VGA);
6747   4                      CEepromLoadAdcData();
6748   4                      SET_INPUTSOURCE_TYPE(ucSourceTemp);
6749   4                      CAdjustAdcGain();
6750   4                      CAdjustAdcOffset();
6751   4      
6752   4                      g_bYuvRgbFlag = _TRUE;
6753   4                  }
6754   3                  else
6755   3                  {
6756   4                      g_bYuvRgbFlag = _FALSE;
6757   4                  }
6758   3              }
6759   2              else
6760   2              {
6761   3                  if(g_bYuvRgbFlag == _TRUE)
6762   3                  {
6763   4                      // Switch to YUV Color Type
6764   4                      CScalerPageSelect(_PAGE0);
6765   4      
6766   4                      // V015 VGA Patch Note (1) Modify 20100607 Start
6767   4                      // Patch Reason : Write register by set bit method
6768   4                      /*
6769   4                      CScalerSetByte(_P0_ADC_RED_CTL_CF, _BIT6 | _BIT7);
6770   4                      CScalerSetByte(_P0_ADC_GREEN_CTL_D0, _BIT6);
6771   4                      CScalerSetByte(_P0_ADC_BLUE_CTL_D1, _BIT6 | _BIT7);
6772   4                      */
6773   4                      CScalerSetBit(_P0_ADC_RED_CTL_CF, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6 | _BIT7);
6774   4                      CScalerSetBit(_P0_ADC_GREEN_CTL_D0, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6);
6775   4                      CScalerSetBit(_P0_ADC_BLUE_CTL_D1, ~(_BIT7 | _BIT6 | _BIT5 | _BIT4), _BIT6 | _BIT7);
6776   4                      // V015 VGA Patch Note (1) Modify 20100607 End
6777   4      
6778   4                      // Adjust RGB Gain And Offset
6779   4                      ucSourceTemp = GET_INPUTSOURCE_TYPE();
6780   4                      SET_INPUTSOURCE_TYPE(_SOURCE_YPBPR);
6781   4                      CEepromLoadAdcData();
6782   4                      SET_INPUTSOURCE_TYPE(ucSourceTemp);
6783   4                      CAdjustAdcGain();
6784   4                      CAdjustAdcOffset();
6785   4      
6786   4                      g_bYuvRgbFlag = _FALSE;
6787   4                  }
6788   3              }
6789   2          }
6790   1      }
6791          
6792          //--------------------------------------------------
6793          // Description  : Get Color Space Type
6794          // Input Value  : None
6795          // Output Value : _TRUE/_FALSE
6796          //--------------------------------------------------
6797          BYTE CModeGetColorSpaceType(void)
6798          {
6799   1          CScalerPageSelect(_PAGE0);
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 113 

6800   1          CScalerRead(_P0_ADC_RED_CTL_CF, 1, pData, _NON_AUTOINC);
6801   1      
6802   1          if((pData[0] & _BIT7) == _BIT7)
6803   1          {
6804   2              return _YUV_COLOR_FORMAT; // YUV Color Space
6805   2          }
6806   1          else
6807   1          {
6808   2              return _RGB_COLOR_FORMAT; // RGB Color Space
6809   2          }
6810   1      }
6811          #endif
6812          // V013 VGA Patch Note (10) 20100416 Modify End
6813          
6814          // V012 Modify 20100322 Start
6815          // V012 Patch Note (8) : Add OOR Table to indicate in which modes the display could show OOR directly.
6816          //--------------------------------------------------
6817          // Description  : Search fit OOR Mode
6818          // Input Value  : OOR Input Mode Table Index
6819          // Output Value : _TRUE : is OOR Mode
6820          //                _FALSE: not OOR Mode
6821          //--------------------------------------------------
6822          bit CModeSearchOORModeVGA(BYTE ucModeCnt)
6823          {
6824   1          if(abs(stModeInfo.IHFreq - tOORINPUT_MODE_TABLE[ucModeCnt].IHFreq) > _HFREQ_TOLERANCE)
6825   1          {
6826   2              return _FALSE;
6827   2          }
6828   1      
6829   1          if(abs(stModeInfo.IVFreq - tOORINPUT_MODE_TABLE[ucModeCnt].IVFreq) > _VFREQ_TOLERANCE)
6830   1          {
6831   2              return _FALSE;
6832   2          }
6833   1      
6834   1          if(abs(stModeInfo.IVTotal - tOORINPUT_MODE_TABLE[ucModeCnt].IVTotal) > 1)
6835   1          {
6836   2              return _FALSE;
6837   2          }
6838   1      
6839   1          if(abs(stModeInfo.IVSyncPulseCount - tOORINPUT_MODE_TABLE[ucModeCnt].IVSyncPulse) > 1)
6840   1          {
6841   2              return _FALSE;
6842   2          }
6843   1      
6844   1          return _TRUE;
6845   1      }
6846          // V012 Modify 20100322 End
6847          
6848          // V012 Modify 20100324 Start
6849          // V012 Patch Note (3) : Modify mode table and mode search according to SQE testing items, and to sync wit
             -h Dell case.
6850          //--------------------------------------------------
6851          // Description  : None
6852          // Input Value  : None
6853          // Output Value : Mode number
6854          //--------------------------------------------------
6855          BYTE CModeSearchAcceptivePresetModeVGA(BYTE ucModeCnt)
6856          {
6857   1          BYTE ucPolarity = 0;
6858   1          BYTE ucPolaritTtemp = 0;
6859   1          WORD usIHSyncpulseCnt = 0;
6860   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 114 

6861   1          // V012 Modify 20100331 Start
6862   1          // V012 Patch Note (21) : Fix the sync processor compatibility problem. Replace slower XTAL clock with
             - M2PLL.
6863   1          /*
6864   1          usIHSyncpulseCnt = stModeInfo.IHSyncPulseCount;
6865   1          */
6866   1          usIHSyncpulseCnt = (DWORD)stModeInfo.IHSyncPulseCount * _XTAL27000K / _INTERNAL_SYSTEM_CLK;
6867   1          // V012 Modify 20100331 End
6868   1      
6869   1      #if(_HSYNC_DETECTION == _AUTO_RUN)
6870   1          ucPolarity = ((stModeInfo.Polarity & ~_BIT0) | ( ! (((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00
             - : _BIT0) ^ ((bit)CScalerGetBit(_STABLE_PERIOD_H_50, _BIT6) ? 0x00 : _BIT0))));
6871   1      #else
                  ucPolarity = ((stModeInfo.Polarity & ~_BIT0) | ((bit)CScalerGetBit(_SYNC_INVERT_48, _BIT3) ? 0x00 : _B
             -IT0));
              #endif
6874   1      
6875   1          if((bit)(ucPolarity & _BIT0))
6876   1          {
6877   2              if((bit)(ucPolarity & _BIT1))
6878   2              {
6879   3                  ucPolaritTtemp = _SYNC_HP_VP;
6880   3              }
6881   2              else
6882   2              {
6883   3                  ucPolaritTtemp = _SYNC_HP_VN;
6884   3              }
6885   2          }
6886   1          else
6887   1          {
6888   2              if((bit)(ucPolarity & _BIT1))
6889   2              {
6890   3                  ucPolaritTtemp = _SYNC_HN_VP;
6891   3              }
6892   2              else
6893   2              {
6894   3                  ucPolaritTtemp = _SYNC_HN_VN;
6895   3              }
6896   2          }
6897   1      
6898   1          // V013 VGA Patch Note (24) Modify 20100514 Start
6899   1          // Patch Reason : Mode search updates.
6900   1          /*
6901   1          if((ucModeCnt == _MODE_640x350_70HZ) && (ucPolaritTtemp == _SYNC_HN_VP))
6902   1          {
6903   1              ucModeCnt = _MODE_720x400_70HZ;
6904   1          }
6905   1          else if((ucModeCnt == _MODE_1024x768_75HZ) && (ucPolaritTtemp == _SYNC_HN_VP))
6906   1          */
6907   1      
6908   1          // V016 VGA Patch Note (3) Modify 20100730 Start
6909   1          // Patch Reason : Modify 640x350_70 Timing to show blank on top and buttom.
6910   1          /*
6911   1          if((ucModeCnt == _MODE_640x350_70HZ))
6912   1          {
6913   1              if(CScalerGetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, (_BIT6 | _BIT5 | _BIT4)) == 0x60) // SS Sync Type
6914   1              {
6915   1                  if(ucPolaritTtemp == _SYNC_HN_VP)
6916   1                  {
6917   1                      ucModeCnt = _MODE_720x400_70HZ;
6918   1                  }
6919   1              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 115 

6920   1              else
6921   1              {
6922   1                  // V015 VGA Patch Note (8) Modiy 20100624 Start
6923   1                  // Patch Reason : Mode search updates.
6924   1                  / *
6925   1                  if(g_usCurrIVHeight > 350)
6926   1                  {
6927   1                      ucModeCnt = _MODE_720x400_70HZ;
6928   1                  }
6929   1                  * /
6930   1                  // As height decision dependes on the picture content, which would probably make SQE confuse.
6931   1                  // Always use 720x400@70 for the CS/SOG situation.
6932   1                  ucModeCnt = _MODE_720x400_70HZ;
6933   1                  // V015 VGA Patch Note (8) Modiy 20100624 End
6934   1              }
6935   1          }
6936   1          else if((ucModeCnt == _MODE_1024x768_75HZ) && (stModeInfo.IVSyncPulseCount > 5))
6937   1          */
6938   1          if((ucModeCnt == _MODE_1024x768_75HZ) && (stModeInfo.IVSyncPulseCount > 5))
6939   1          // V016 VGA Patch Note (3) Modify 20100730 End
6940   1      
6941   1          // V013 VGA Patch Note (24) Modify 20100514 End
6942   1          {
6943   2              ucModeCnt = _MODE_1280x768_75HZ;
6944   2          }
6945   1      
6946   1          // V013 VGA Patch Note (24) Modify 20100514 Start
6947   1          // Patch Reason : Mode search updates.
6948   1          /*
6949   1          else if((ucModeCnt == _MODE_1280x768_60HZ) && (ucPolaritTtemp == _SYNC_HP_VP))
6950   1          {
6951   1              if(stModeInfo.IVSyncPulseCount < 5)
6952   1              {
6953   1                  ucModeCnt = _MODE_1366x768_60HZ;
6954   1              }
6955   1              else if(stModeInfo.IVSyncPulseCount < 7)
6956   1              {
6957   1                  ucModeCnt = _MODE_1360x768_60HZ;
6958   1              }
6959   1          }
6960   1          */
6961   1          else if(ucModeCnt == _MODE_1280x768_60HZ)
6962   1          {
6963   2              if(stModeInfo.IVSyncPulseCount < 5)
6964   2              {
6965   3                  ucModeCnt = _MODE_1366x768_60HZ;
6966   3              }
6967   2              else if(stModeInfo.IVTotal <= 796)
6968   2              {
6969   3                  ucModeCnt = _MODE_1360x768_60HZ;
6970   3              }
6971   2          }
6972   1          // V013 VGA Patch Note (24) Modify 20100514 End
6973   1      
6974   1          // V013 VGA Patch Note (24) Modify 20100514 Start
6975   1          // Patch Reason : Mode search updates.
6976   1          /*
6977   1          else if((ucModeCnt == _MODE_720x400_85HZ) && (ucPolaritTtemp == _SYNC_HP_VN))
6978   1          {
6979   1              ucModeCnt = _MODE_640x350_85HZ;
6980   1          }
6981   1          else if((ucModeCnt == _MODE_1024x768_85HZ) && (ucPolaritTtemp == _SYNC_HN_VP))
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 116 

6982   1          {
6983   1              ucModeCnt = _MODE_1280x768_85HZ;
6984   1          }
6985   1          */
6986   1          // V013 VGA Patch Note (24) Modify 20100514 End
6987   1      
6988   1          // V013 VGA Patch Note (24) Modify 20100514 Start
6989   1          // Patch Reason : Mode search updates.
6990   1          else if((ucModeCnt == _MODE_640x480_75HZ) && (stModeInfo.IVTotal > 501))
6991   1          {
6992   2              ucModeCnt = _MODE_848x480_75HZ;
6993   2          }
6994   1          // V013 VGA Patch Note (24) Modify 20100514 End
6995   1      
6996   1          if((ucModeCnt == _MODE_640x480_60HZ) && (stModeInfo.IVSyncPulseCount > 4))
6997   1          {
6998   2              ucModeCnt = _MODE_720x480p_60HZ;
6999   2          }
7000   1          else if((ucModeCnt == _MODE_640x480_60HZ) && (abs(usIHSyncpulseCnt - 59) <= 4))
7001   1          {
7002   2              ucModeCnt = _MODE_720x480_60HZ_GTF;
7003   2          }
7004   1      
7005   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7006   1          // Patch Reason : Mode search updates.
7007   1          /*
7008   1          else if((ucModeCnt == _MODE_1280x768_60HZ) && (abs(usIHSyncpulseCnt - 15) <= 10))
7009   1          */
7010   1          else if((ucModeCnt == _MODE_1280x768_60HZ) && (usIHSyncpulseCnt <= 28))
7011   1          // V013 VGA Patch Note (24) Modify 20100514 End
7012   1      
7013   1          {
7014   2              ucModeCnt = _MODE_1280x768_60HZ_RB;
7015   2          }
7016   1          else if((ucModeCnt == _MODE_1024x768_60HZ_MAC) && (abs(usIHSyncpulseCnt - 36) <= 1))
7017   1          {
7018   2              ucModeCnt = _MODE_1360x768_60HZ;
7019   2          }
7020   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7021   1          // Patch Reason : Mode search updates.
7022   1          /*
7023   1          else if((ucModeCnt == _MODE_1280x768_60HZ_RB) && (usIHSyncpulseCnt >= 27))
7024   1          {
7025   1              ucModeCnt = _MODE_1280x768_60HZ;
7026   1          }
7027   1          */
7028   1          // V013 VGA Patch Note (24) Modify 20100514 End
7029   1      
7030   1          // V015 VGA Patch Note (8) Modiy 20100624 Start
7031   1          // Patch Reason : Mode search updates.
7032   1          /*
7033   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7034   1          // Patch Reason : Mode search updates.
7035   1          else if((ucModeCnt == _MODE_1920x1200_60HZ) && (stModeInfo.IVSyncPulseCount < 5))
7036   1          {
7037   1              ucModeCnt = _MODE_1600x1200_60HZ;
7038   1          }
7039   1          // V013 VGA Patch Note (24) Modify 20100514 End
7040   1          */
7041   1          else if((ucModeCnt == _MODE_1920x1200_60HZ) && (stModeInfo.IVSyncPulseCount < 5) && (stModeInfo.IVTota
             -l < 1240))
7042   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 117 

7043   2              ucModeCnt = _MODE_1600x1200_60HZ;
7044   2          }
7045   1          // V015 VGA Patch Note (8) Modiy 20100624 End
7046   1      
7047   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7048   1          // Patch Reason : Mode search updates.
7049   1          /*
7050   1          else if((ucModeCnt == _MODE_1920x1200_60HZ) && (usIHSyncpulseCnt <= 12))
7051   1          */
7052   1      
7053   1          else if((ucModeCnt == _MODE_1920x1200_60HZ) && (usIHSyncpulseCnt <= 16))
7054   1          // V013 VGA Patch Note (24) Modify 20100514 End
7055   1      
7056   1          {
7057   2              ucModeCnt = _MODE_1920x1200_60HZ_RB;
7058   2          }
7059   1      
7060   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7061   1          // Patch Reason : Mode search updates.
7062   1          /*
7063   1          else if((ucModeCnt == _MODE_1600x1200_60HZ_RB) && (stModeInfo.IVSyncPulseCount >= 5))
7064   1          {
7065   1              ucModeCnt = _MODE_1920x1200_60HZ_RB;
7066   1          }
7067   1          else if((ucModeCnt == _MODE_1920x1080_60HZ_XBOX) && (stModeInfo.IVSyncPulseCount <= 5))
7068   1          {
7069   1              ucModeCnt = _MODE_1920x1080_60HZ_RB;
7070   1          }
7071   1          */
7072   1          else if((ucModeCnt == _MODE_1600x1200_60HZ_RB) && (stModeInfo.IVSyncPulseCount > 5))
7073   1          {
7074   2              ucModeCnt = _MODE_1920x1200_60HZ_RB;
7075   2          }
7076   1          // V013 VGA Patch Note (24) Modify 20100514 End
7077   1      
7078   1          else if(ucModeCnt == _MODE_640x400_70HZ)
7079   1          {
7080   2              ucModeCnt = _MODE_720x400_70HZ;
7081   2          }
7082   1      
7083   1          // V014 VGA Patch Note (2) Modify 20100526 Start
7084   1          // Patch Reason : Use width/HTotal ratio to distinguish mode _MODE_1440x900_60HZ_RB and _MODE_1600x900
             -_60HZ_CVR.
7085   1          /*
7086   1          else if((ucModeCnt == _MODE_1440x900_60HZ_RB) && (stModeInfo.IVSyncPulseCount <= 5))
7087   1          {
7088   1              ucModeCnt = _MODE_1600x900_60HZ_CVR;
7089   1          }
7090   1          */
7091   1          else if(ucModeCnt == _MODE_1440x900_60HZ_RB)
7092   1          {
7093   2              if(labs((DWORD)(g_usHEndPos + 1 - g_usHStartPos) * tINPUTMODE_PRESET_TABLE[_MODE_1600x900_60HZ_CVR
             -].IHTotal - (DWORD)tINPUTMODE_PRESET_TABLE[_MODE_1600x900_60HZ_CVR].IHWidth * stModeUserData.Clock) < (DWORD)5 * stModeU
             -serData.Clock * tINPUTMODE_PRESET_TABLE[_MODE_1600x900_60HZ_CVR].IHTotal / 1000)
7094   2              {
7095   3                  ucModeCnt = _MODE_1600x900_60HZ_CVR;
7096   3              }
7097   2              else if(labs((DWORD)(g_usHEndPos + 1 - g_usHStartPos) * tINPUTMODE_PRESET_TABLE[_MODE_1440x900_60H
             -Z_RB].IHTotal - (DWORD)tINPUTMODE_PRESET_TABLE[_MODE_1440x900_60HZ].IHWidth * stModeUserData.Clock) < (DWORD)5 * stModeU
             -serData.Clock * tINPUTMODE_PRESET_TABLE[_MODE_1440x900_60HZ].IHTotal / 1000)
7098   2              {
7099   3                  ucModeCnt = _MODE_1440x900_60HZ_RB;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 118 

7100   3              }
7101   2              else if(stModeInfo.IVSyncPulseCount <= 5)
7102   2              {
7103   3                  ucModeCnt = _MODE_1600x900_60HZ_CVR;
7104   3              }
7105   2          }
7106   1         // V014 VGA Patch Note (2) Modify 20100526 End
7107   1      
7108   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7109   1          // Patch Reason : Mode search updates.
7110   1          /*
7111   1          else if((ucModeCnt == _MODE_1280x720p_60HZ) && (usIHSyncpulseCnt > 32))
7112   1          */
7113   1          else if((ucModeCnt == _MODE_1280x720p_60HZ) && (usIHSyncpulseCnt >= 30))
7114   1          // V013 VGA Patch Note (24) Modify 20100514 End
7115   1      
7116   1          {
7117   2              ucModeCnt = _MODE_1280x720_60HZ_2;
7118   2          }
7119   1      
7120   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7121   1          // Patch Reason : Mode search updates.
7122   1          /*
7123   1          else if((ucModeCnt == _MODE_1280x960_60HZ) && (usIHSyncpulseCnt <= 24))
7124   1          */
7125   1          else if((ucModeCnt == _MODE_1280x960_60HZ) && (usIHSyncpulseCnt <= 23))
7126   1      
7127   1          // V013 VGA Patch Note (24) Modify 20100514 End
7128   1      
7129   1          {
7130   2              ucModeCnt = _MODE_1600x900_60HZ_RB;
7131   2          }
7132   1          else if((ucModeCnt == _MODE_1024x768_75HZ) && (stModeInfo.IVSyncPulseCount > 5))
7133   1          {
7134   2              ucModeCnt = _MODE_1280x768_75HZ;
7135   2          }
7136   1          else if((ucModeCnt == _MODE_1440x900_75HZ) && (stModeInfo.IHFreq > 712))
7137   1          {
7138   2              ucModeCnt = _MODE_1152x900_76HZ;
7139   2          }
7140   1      
7141   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7142   1          // Patch Reason : Mode search updates.
7143   1          /*
7144   1          else if((ucModeCnt == _MODE_720x576p_50Hz) && (stModeInfo.IVSyncPulseCount > 12))
7145   1          {
7146   1              ucModeCnt = _MODE_1920x1080i_50HZ_2;
7147   1          }
7148   1          */
7149   1          else if((ucModeCnt == _MODE_720x576p_50Hz) && (GET_INTERLACE_MODE() == 1))
7150   1          {
7151   2              ucModeCnt = _MODE_1920x1080i_50HZ_2;
7152   2          }
7153   1          // V013 VGA Patch Note (24) Modify 20100514 End
7154   1      
7155   1          // V013 VGA Patch Note (24) Modify 20100514 Start
7156   1          // Patch Reason : Mode search updates.
7157   1          // _MODE_1600x900_60HZ is a non-RB mode, suggested by Y.C., which could solve
7158   1          // Graphic Card issue.
7159   1          else if((ucModeCnt == _MODE_1440x900_60HZ) && (stModeInfo.IVSyncPulseCount < 5))
7160   1          {
7161   2              ucModeCnt = _MODE_1600x900_60HZ;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 119 

7162   2          }
7163   1          // V013 VGA Patch Note (24) Modify 20100514 End
7164   1      
7165   1          // V016 VGA Patch Note (6) Modify 20100806 Start
7166   1          // Patch Reason : Solve Intel G43(VOSTRO) catpure 1280x768x75 timing mode error to 1024x768x75 timing 
             -mode
7167   1          else if((ucModeCnt == _MODE_1024x768_75HZ) && (stModeInfo.IVTotal > 801) && (stModeInfo.IVTotal < 803)
             -)
7168   1          {
7169   2              ucModeCnt = _MODE_1280x768_75HZ;
7170   2          }
7171   1          // V016 VGA Patch Note (6) Modify 20100806 End
7172   1      
7173   1          // V016 VGA Patch Note (16) Modify 20100901 Start
7174   1          // Patch Reason : Solve Chroma2233B at 1360x768x60 error to 1280x768x60_RB timing mode
7175   1          if((ucModeCnt == _MODE_1280x768_60HZ_RB) && (stModeInfo.IVTotal > 792) && (stModeInfo.IVTotal < 794) &
             -& (usIHSyncpulseCnt) > 30)
7176   1          {
7177   2              ucModeCnt = _MODE_1360x768_60HZ;
7178   2          }
7179   1          // V016 VGA Patch Note (16) Modify 20100901 End
7180   1      
7181   1          // V012 Modify 20100331 Start
7182   1          // V012 Patch Note (30) : Use mode search incorrect flag to skip SOD clock seeking in the auto stage t
             -o avoid one missing vertical line at the edge of the picture.
7183   1          // Use this flag to tell auto clock never to do the SOD clock seeking if a 1400x1050 is searched as 16
             -80x1050 (SQE requires 1400x1050 is searched as 1680x1050.
7184   1          if(((ucModeCnt == _MODE_1680x1050_60HZ) || (ucModeCnt == _MODE_1680x1050_60HZ_RB) || (ucModeCnt == _MO
             -DE_1680x1050_75HZ)) && (stModeInfo.IVSyncPulseCount < 5))
7185   1          {
7186   2              g_bModeSearchIncorrectFlag = _TRUE;
7187   2          }
7188   1          // V012 Modify 20100331 End
7189   1      
7190   1          return ucModeCnt;
7191   1      }
7192          // V012 Modify 20100324 End
7193          
7194          // V012 Modify 20100316 Start
7195          // V012 Patch Note (2) : Overscan function update.
7196          #if(_OVERSCAN_SUPPORT == _ON)
7197          //--------------------------------------------------
7198          // Description  : Overscan Setting
7199          // Input Value  : None
7200          // Output Value : None
7201          //--------------------------------------------------
7202          void CModeOverScanSelect(void)
7203          {
7204   1          CLR_OVERSCAN_STATUS();
7205   1          CLR_OVERSCAN_SUCCESS_STATUS();
7206   1      
7207   1          g_ucOverScanH = 0;
7208   1          g_ucOverScanV = 0;
7209   1      
7210   1          if(GET_OVERSCAN_CAPTURE_BACKUP_VALUE() == _FALSE)
7211   1          {
7212   2              g_usOldIHWidth = stModeInfo.IHWidth;
7213   2              g_usOldIVHeight = stModeInfo.IVHeight;
7214   2              SET_OVERSCAN_CAPTURE_BACKUP_VALUE();
7215   2          }
7216   1      
7217   1          if(CModeOverScanSourceSelect() == _FALSE)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 120 

7218   1          {
7219   2              return;
7220   2          }
7221   1      
7222   1      // V016 System Patch Note (25) Modify 20100831 Start
7223   1      // Patch Reason : Modify Overscan Effect Condition.
7224   1      /*
7225   1          if(CModeOverScanTimingSelect() == _TRUE)
7226   1      */
7227   1          if(CModeOverScanConditionSwitch() == _TRUE)
7228   1      // V016 System Patch Note (25) Modify 20100831 End
7229   1          {
7230   2              CModeDecideOverScanValue();
7231   2          }
7232   1      
7233   1          stModeInfo.IHWidth = g_usOldIHWidth - (2 * g_ucOverScanH);
7234   1          stModeInfo.IVHeight = g_usOldIVHeight - (2 * g_ucOverScanV);
7235   1      
7236   1          if(CModeOverScanCheckCaptureWindow() == _FALSE)
7237   1          {
7238   2              stModeInfo.IHWidth = g_usOldIHWidth;
7239   2              stModeInfo.IVHeight = g_usOldIVHeight;
7240   2              return;
7241   2          }
7242   1      
7243   1          SET_OVERSCAN_STATUS();
7244   1          SET_OVERSCAN_SUCCESS_STATUS();
7245   1      }
7246          
7247          //--------------------------------------------------
7248          // Description  : Overscan Adjust Pos Setting
7249          // Input Value  : None
7250          // Output Value : None
7251          //--------------------------------------------------
7252          void CModeOverScanAdjustPos(void)
7253          {
7254   1           // Backup IVS2DVS Delay Value By g_ucIv2DvModify
7255   1          if(GET_OVERSCAN_IV2DVDELAY_BACKUP_VALUE() == _FALSE)
7256   1          {
7257   2              CScalerRead(_IVS2DVS_DELAY_LINES_40, 1, &g_ucIv2DvModify, _NON_AUTOINC);
7258   2              SET_OVERSCAN_IV2DVDELAY_BACKUP_VALUE();
7259   2          }
7260   1      
7261   1          if(GET_OVERSCAN_STATUS() == _FALSE)
7262   1          {
7263   2              return;
7264   2          }
7265   1          else
7266   1          {
7267   2              CLR_OVERSCAN_STATUS();
7268   2          }
7269   1      
7270   1          CModeOverScanSetCaptureStart();
7271   1      
7272   1          if((g_ucOverScanH == 0) || (g_ucOverScanV == 0))
7273   1          {
7274   2              CLR_OVERSCAN_SUCCESS_STATUS();
7275   2          }
7276   1      
7277   1          stModeInfo.IHWidth = g_usOldIHWidth;
7278   1          stModeInfo.IVHeight = g_usOldIVHeight;
7279   1      }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 121 

7280          
7281          //--------------------------------------------------
7282          // Description  : Decide Overscan Value
7283          // Input Value  : None
7284          // Output Value : None
7285          //--------------------------------------------------
7286          void CModeDecideOverScanValue(void)
7287          {
7288   1          BYTE cnt = 0;
7289   1          BYTE ucModeIndex = 0;
7290   1      
7291   1          g_ucOverScanH = 0;
7292   1          g_ucOverScanV = 0;
7293   1      
7294   1          if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
7295   1          {
7296   2              ucModeIndex = stModeInfo.ModeCurr;
7297   2          }
7298   1          else
7299   1          {
7300   2              ucModeIndex = g_ucUserModeCurr;
7301   2          }
7302   1      
7303   1          stDisplayInfo.DVHeight = _PANEL_DV_HEIGHT;
7304   1          stDisplayInfo.DHTotal = _PANEL_DH_TOTAL;
7305   1      
7306   1          ((DWORD *)pData)[0] = ((DWORD)stDisplayInfo.DHTotal * stModeInfo.IHFreq * stDisplayInfo.DVHeight);
7307   1      
7308   1          // ((DWORD *)pData)[1] is the minimal result of IVHeight for over scan
7309   1          //  D clock = DHTotal * IHFreq * DVHeight / IVHeight
7310   1          if((((DWORD *)pData)[0] % ((DWORD)_PANEL_PIXEL_CLOCK_MAX * 10000)) != 0)
7311   1          {
7312   2              ((DWORD *)pData)[1] = ((DWORD *)pData)[0] / ((DWORD)_PANEL_PIXEL_CLOCK_MAX * 10000) + 1;
7313   2          }
7314   1          else
7315   1          {
7316   2              ((DWORD *)pData)[1] = ((DWORD *)pData)[0] / ((DWORD)_PANEL_PIXEL_CLOCK_MAX * 10000);
7317   2          }
7318   1      
7319   1          if(stModeInfo.IVHeight <= ((DWORD *)pData)[1])
7320   1          {
7321   2              return;
7322   2          }
7323   1      
7324   1          // The max value of OverScanV is bigger than 255
7325   1          if((stModeInfo.IVHeight - ((DWORD *)pData)[1]) >= (0xFF * 2))
7326   1          {
7327   2              pData[15] = 0xFC; // Max OverScanV Value for BYTE type
7328   2          }
7329   1          else
7330   1          {
7331   2              pData[15] = ((stModeInfo.IVHeight - ((DWORD *)pData)[1]) / 2) & 0xFC; // Max OverScanV Value
7332   2          }
7333   1      
7334   1      #if(_TMDS_SUPPORT == _ON)
7335   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7336   1          || (GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
7337   1      
7338   1      #if(_HDMI_SUPPORT == _ON)
                  || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
              #endif
7341   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 122 

7342   1      #if(_DP_SUPPORT == _ON)
                  || (GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
              #endif
7345   1          )
7346   1      #else // Else #if(_TMDS_SUPPORT == _ON)
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
              #endif // End of #if(_TMDS_SUPPORT == _ON)
7349   1          {
7350   2              do
7351   2              {
7352   3                  if(tOVERSCAN_DISPLAY_TABLE[cnt].ucModeIndex == ucModeIndex)
7353   3                  {
7354   4                      g_ucOverScanH = ((BYTE)((DWORD)stModeInfo.IHWidth * tOVERSCAN_DISPLAY_TABLE[cnt].usIHWidth
             -Ratio / 1000));
7355   4                      g_ucOverScanV = ((BYTE)((DWORD)stModeInfo.IVHeight * tOVERSCAN_DISPLAY_TABLE[cnt].usIVHeig
             -htRatio / 1000));
7356   4                      ucModeIndex = 0xFE; // UcModeIndex = 0xFE means a mode was found, as this variable was not
             - initialized to 0xFE
7357   4                      break;
7358   4                  }
7359   3      
7360   3                  cnt++;
7361   3              }
7362   2              while((tOVERSCAN_DISPLAY_TABLE[cnt].ucModeIndex != 0xFF) && (cnt < _MAX_PRESET_MODE));
7363   2      
7364   2              if(ucModeIndex != 0xFE) // Not Find a mode from tOVERSCAN_DISPLAY_TABLE
7365   2              {
7366   3                  g_ucOverScanH = ((BYTE)((DWORD)stModeInfo.IHWidth * _OVERSCAN_RATIO / 1000));
7367   3                  g_ucOverScanV = ((BYTE)((DWORD)stModeInfo.IVHeight * _OVERSCAN_RATIO / 1000));
7368   3              }
7369   2          }
7370   1      
7371   1      #if(_YPBPR_SUPPORT == _ON)
7372   1          else if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
7373   1          {
7374   2              do
7375   2              {
7376   3                  if(tOVERSCAN_YPBPR_DISPLAY_TABLE[cnt].ucModeIndex == ucModeIndex)
7377   3                  {
7378   4                      g_ucOverScanH = ((BYTE)((DWORD)stModeInfo.IHWidth * tOVERSCAN_YPBPR_DISPLAY_TABLE[cnt].usI
             -HWidthRatio / 1000));
7379   4                      g_ucOverScanV = ((BYTE)((DWORD)stModeInfo.IVHeight * tOVERSCAN_YPBPR_DISPLAY_TABLE[cnt].us
             -IVHeightRatio / 1000));
7380   4                      ucModeIndex = 0xFE; // UcModeIndex = 0xFE means a mode was found, as this variable was not
             - initialized to 0xFE
7381   4                      break;
7382   4                  }
7383   3      
7384   3                  cnt++;
7385   3              }
7386   2              while((tOVERSCAN_YPBPR_DISPLAY_TABLE[cnt].ucModeIndex != 0xFF) && (cnt < _MAX_YPBPR_MODE));
7387   2      
7388   2              if(ucModeIndex != 0xFE) // Not Find a mode from tOVERSCAN_YPBPR_DISPLAY_TABLE
7389   2              {
7390   3                  g_ucOverScanH = ((BYTE)((DWORD)stModeInfo.IHWidth * _OVERSCAN_RATIO / 1000));
7391   3                  g_ucOverScanV = ((BYTE)((DWORD)stModeInfo.IVHeight * _OVERSCAN_RATIO / 1000));
7392   3              }
7393   2          }
7394   1      #endif
7395   1      
7396   1          if((g_ucOverScanH % 4) != 0)
7397   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 123 

7398   2              g_ucOverScanH = ((g_ucOverScanH + 2) >> 2) << 2;
7399   2          }
7400   1      
7401   1          if((g_ucOverScanV % 4) != 0)
7402   1          {
7403   2              g_ucOverScanV = ((g_ucOverScanV + 2) >> 2) << 2;
7404   2          }
7405   1      
7406   1          // OverScanV is bigger than max value
7407   1          if(g_ucOverScanV > pData[15])
7408   1          {
7409   2              g_ucOverScanV = pData[15];
7410   2          }
7411   1      
7412   1          if((g_ucOverScanH == 0) || (g_ucOverScanV == 0))
7413   1          {
7414   2              g_ucOverScanH = 0;
7415   2              g_ucOverScanV = 0;
7416   2          }
7417   1      }
7418          
7419          
7420          // V016 System Patch Note (25) Modify 20100831 Start
7421          // Patch Reason : Modify Overscan Effect Condition.
7422          /*
7423          //--------------------------------------------------
7424          // Description  : Check Mode Number for using Overscan
7425          // Input Value  : None
7426          // Output Value : return _TRUE if video mode
7427          //--------------------------------------------------
7428          bit CModeOverScanTimingSelect()
7429          {
7430              BYTE ucMode = 0;
7431          
7432          #if(_YPBPR_SUPPORT == _ON)
7433              if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
7434              {
7435                  return _TRUE;
7436              }
7437          #endif
7438          
7439              if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
7440              {
7441                  ucMode = stModeInfo.ModeCurr;
7442              }
7443              else
7444              {
7445                  ucMode = g_ucUserModeCurr;
7446              }
7447          
7448              if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7449              {
7450                  switch(ucMode)
7451                  {
7452                      // V013 VGA Patch Note (24) Modify 20100514 Start
7453                      // Patch Reason : Mode search updates.
7454                      /*
7455                      case _MODE_720x480i_60Hz:
7456                      case _MODE_720x576i_50Hz:
7457                      * /
7458                      case _MODE_1440x480i_60HZ:
7459                      case _MODE_1440x576i_50Hz:
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 124 

7460                      // V013 VGA Patch Note (24) Modify 20100514 End
7461          
7462                      case _MODE_1920x1080i_50Hz:
7463                      case _MODE_1920x1080i_60HZ:
7464                          return _TRUE;
7465                          break;
7466          
7467                      case _MODE_640x480_60HZ:
7468                      case _MODE_720x480p_60HZ:
7469                      case _MODE_720x576p_50Hz:
7470                      case _MODE_1280x720p_50HZ:
7471                      case _MODE_1280x720p_60HZ:
7472                      case _MODE_1920x1080p_50Hz:
7473                      case _MODE_1920x1080p_60HZ:
7474          
7475          #if(_COLOR_FORMAT_CONVERT == _ON)
7476                          if(GET_COLOR_FORMAT_STATUS() != _YUV_COLOR_FORMAT)
7477                          {
7478                              return _FALSE;
7479                          }
7480          #endif
7481                          return _TRUE;
7482                          break;
7483          
7484                      default:
7485                          return _FALSE;
7486                          break;
7487                  }
7488              }   // End of if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7489          
7490          #if(_TMDS_SUPPORT == _ON)
7491              if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
7492          
7493          #if(_HDMI_SUPPORT == _ON)
7494              || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
7495          #endif
7496          
7497          #if(_DP_SUPPORT == _ON)
7498              || (GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
7499          #endif
7500              )
7501              {
7502                  switch(ucMode)
7503                  {
7504                      // V013 VGA Patch Note (24) Modify 20100514 Start
7505                      // Patch Reason : Mode search updates.
7506                      /*
7507                      case _MODE_720x480i_60Hz:
7508                      case _MODE_720x576i_50Hz:
7509                      * /
7510                      case _MODE_1440x480i_60HZ:
7511                      case _MODE_1440x576i_50Hz:
7512                      // V013 VGA Patch Note (24) Modify 20100514 End
7513          
7514                      case _MODE_1920x1080i_50Hz:
7515                      case _MODE_1920x1080i_60HZ:
7516                      case _MODE_640x480_60HZ:
7517                      case _MODE_1280x720p_60HZ:
7518                      case _MODE_720x480p_60HZ:
7519                      case _MODE_720x576p_50Hz:
7520                      case _MODE_1280x720p_50HZ:
7521                      case _MODE_1280x720_60HZ_2:
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 125 

7522                      case _MODE_1920x1080p_50Hz:
7523                      case _MODE_1920x1080p_60HZ:
7524                          return _TRUE;
7525                          break;
7526          
7527                      default:
7528                          return _FALSE;
7529                          break;
7530                  }
7531              }
7532          #endif
7533          
7534              return _FALSE;
7535          }
7536          */
7537          //--------------------------------------------------
7538          // Description  : Check Whether Overscan
7539          // Input Value  : None
7540          // Output Value : return _TRUE if Overscan
7541          //--------------------------------------------------
7542          bit CModeOverScanConditionSwitch(void)
7543          {
7544   1          BYTE ucMode = 0;
7545   1      
7546   1      #if(_OVERSCAN_VGA_SUPPORT == _ON)
7547   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7548   1          {
7549   2              if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
7550   2              {
7551   3                  ucMode = stModeInfo.ModeCurr;
7552   3              }
7553   2              else
7554   2              {
7555   3                  ucMode = g_ucUserModeCurr;
7556   3              }
7557   2      
7558   2              switch(ucMode)
7559   2              {
7560   3                  case _MODE_720x480_60HZ:
7561   3                  case _MODE_720x480_60HZ_GTF:
7562   3                  case _MODE_720x576_60HZ:
7563   3                  case _MODE_1920x1080_60HZ_XBOX:
7564   3                  case _MODE_1920x1080_60HZ_RB:
7565   3                  case _MODE_1920x1080_60HZ:
7566   3                  case _MODE_1920x1080_50HZ_2:
7567   3                  case _MODE_1280x720_60HZ_2:
7568   3                  case _MODE_720x480p_60HZ:
7569   3                  case _MODE_720x576p_50Hz:
7570   3                  case _MODE_1280x720p_50HZ:
7571   3                  case _MODE_1280x720p_60HZ:
7572   3                  case _MODE_1920x1080p_50Hz:
7573   3                  case _MODE_1920x1080p_60HZ:
7574   3      
7575   3      #if(_COLOR_FORMAT_CONVERT == _ON)
7576   3                      if(GET_COLOR_FORMAT_STATUS() != _YUV_COLOR_FORMAT)
7577   3                      {
7578   4                          return _FALSE;
7579   4                      }
7580   3      #endif
7581   3      
7582   3                      return _TRUE;
7583   3                      break;
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 126 

7584   3      
7585   3                  default:
7586   3                      break;
7587   3              }
7588   2      
7589   2              return _TRUE;
7590   2          }   // End of if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7591   1      #endif
7592   1      
7593   1      #if((_YPBPR_SUPPORT == _ON) && (_OVERSCAN_YPBPR_SUPPORT == _ON))
7594   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
7595   1          {
7596   2              switch(stModeInfo.ModeCurr)
7597   2              {
7598   3                  case _VIDEO_720x576p_50HZ:
7599   3                  case _VIDEO_720x480p_60HZ:
7600   3                  case _VIDEO_1280x720p_50HZ:
7601   3                  case _VIDEO_1280x720p_60HZ:
7602   3                  case _VIDEO_1920x1080p_50HZ:
7603   3                  case _VIDEO_1920x1080p_60HZ:
7604   3      
7605   3      #if(_COLOR_FORMAT_CONVERT == _ON)
7606   3                      if(GET_COLOR_FORMAT_STATUS() != _YUV_COLOR_FORMAT)
7607   3                      {
7608   4                          return _FALSE;
7609   4                      }
7610   3      #endif
7611   3      
7612   3                      return _TRUE;
7613   3                      break;
7614   3      
7615   3                  default:
7616   3                      break;
7617   3              }
7618   2      
7619   2              return _TRUE;
7620   2          }
7621   1      #endif
7622   1      
7623   1          return _TRUE;
7624   1      }
7625          // V016 System Patch Note (25) Modify 20100831 End
7626          
7627          //--------------------------------------------------
7628          // Description  : Overscan Source Select
7629          // Input Value  : None
7630          // Output Value : TRUE/FALSE
7631          //--------------------------------------------------
7632          bit CModeOverScanSourceSelect(void)
7633          {
7634   1      // V016 System Patch Note (25) Modify 20100831 Start
7635   1      // Patch Reason : Modify Overscan Effect Condition.
7636   1      /*
7637   1      #if(_FRC_SUPPORT == _ON)
7638   1          if(GET_FRCSTATUS())
7639   1          {
7640   1              return _FALSE;
7641   1          }
7642   1      #endif
7643   1      
7644   1          switch(GET_INPUTSOURCE_TYPE())
7645   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 127 

7646   1      #if(_OVERSCAN_VGA_SUPPORT == _ON)
7647   1              case _SOURCE_VGA:
7648   1      
7649   1                  if(CScalerGetBit(_SYNC_SELECT_47, _BIT4) == 0)
7650   1                  {
7651   1                      return _FALSE;
7652   1                  }
7653   1      
7654   1                  return _TRUE;
7655   1                  break;
7656   1      #endif
7657   1      
7658   1      #if(_TMDS_SUPPORT == _ON)
7659   1      
7660   1      #if(_OVERSCAN_DVI_SUPPORT == _ON)
7661   1              case _SOURCE_DVI:
7662   1                  return _TRUE;
7663   1                  break;
7664   1      #endif
7665   1      
7666   1      #if((_HDMI_SUPPORT == _ON) && (_OVERSCAN_HDMI_SUPPORT == _ON))
7667   1              case _SOURCE_HDMI:
7668   1                  return _TRUE;
7669   1                  break;
7670   1      #endif
7671   1      
7672   1      #if((_DP_SUPPORT == _ON) && (_OVERSCAN_DP_SUPPORT == _ON))
7673   1              case _SOURCE_DP:
7674   1                  return _TRUE;
7675   1                  break;
7676   1      #endif
7677   1      
7678   1      #endif // End of #if(_TMDS_SUPPORT == _ON)
7679   1      
7680   1      #if((_YPBPR_SUPPORT == _ON) && (_OVERSCAN_YPBPR_SUPPORT == _ON))
7681   1              case _SOURCE_YPBPR:
7682   1      
7683   1                  if(CScalerGetBit(_SYNC_SELECT_47, _BIT4) == 0)
7684   1                  {
7685   1                      return _FALSE;
7686   1                  }
7687   1      
7688   1                  return _TRUE;
7689   1                  break;
7690   1      #endif
7691   1      
7692   1              default:
7693   1                  break;
7694   1          }
7695   1      
7696   1          return _FALSE;
7697   1      */
7698   1          BYTE ucMode = 0;
7699   1      
7700   1      #if(_FRC_SUPPORT == _ON)
                  if(GET_FRCSTATUS() == _TRUE)
                  {
                      return _FALSE;
                  }
              #endif
7706   1      
7707   1      #if(_OVERSCAN_VGA_SUPPORT == _ON)
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 128 

7708   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
7709   1          {
7710   2              if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
7711   2              {
7712   3                  ucMode = stModeInfo.ModeCurr;
7713   3              }
7714   2              else
7715   2              {
7716   3                  ucMode = g_ucUserModeCurr;
7717   3              }
7718   2      
7719   2              switch(ucMode)
7720   2              {
7721   3                  case _MODE_1920x1080i_50Hz:
7722   3                  case _MODE_1920x1080i_60HZ:
7723   3                  case _MODE_1440x480i_60HZ:
7724   3                  case _MODE_1440x576i_50Hz:
7725   3                  case _MODE_1920x1080i_50HZ_2:
7726   3                      return _TRUE;
7727   3                      break;
7728   3      
7729   3                  case _MODE_720x480_60HZ:
7730   3                  case _MODE_720x480_60HZ_GTF:
7731   3                  case _MODE_720x576_60HZ:
7732   3                  case _MODE_1920x1080_60HZ_XBOX:
7733   3                  case _MODE_1920x1080_60HZ_RB:
7734   3                  case _MODE_1920x1080_60HZ:
7735   3                  case _MODE_1920x1080_50HZ_2:
7736   3                  case _MODE_1280x720_60HZ_2:
7737   3                  case _MODE_720x480p_60HZ:
7738   3                  case _MODE_720x576p_50Hz:
7739   3                  case _MODE_1280x720p_50HZ:
7740   3                  case _MODE_1280x720p_60HZ:
7741   3                  case _MODE_1920x1080p_50Hz:
7742   3                  case _MODE_1920x1080p_60HZ:
7743   3      
7744   3                      if(CScalerGetBit(_SYNC_SELECT_47, _BIT4) == 0)
7745   3                      {
7746   4                          return _FALSE;
7747   4                      }
7748   3      
7749   3                      return _TRUE;
7750   3                      break;
7751   3      
7752   3                  default:
7753   3                      break;
7754   3              }
7755   2      
7756   2              return _FALSE;
7757   2          }
7758   1      #endif
7759   1      
7760   1      #if((_YPBPR_SUPPORT == _ON) && (_OVERSCAN_YPBPR_SUPPORT == _ON))
7761   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
7762   1          {
7763   2              switch(stModeInfo.ModeCurr)
7764   2              {
7765   3                  case _VIDEO_1440x576i_50HZ:
7766   3                  case _VIDEO_1440x480i_60HZ:
7767   3                  case _VIDEO_1920x1080i_50HZ:
7768   3                  case _VIDEO_1920x1080i_60HZ:
7769   3                  case _VIDEO_1920x1080i_50HZ_2:
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 129 

7770   3                      return _TRUE;
7771   3                      break;
7772   3      
7773   3                  case _VIDEO_720x576p_50HZ:
7774   3                  case _VIDEO_720x480p_60HZ:
7775   3                  case _VIDEO_1280x720p_50HZ:
7776   3                  case _VIDEO_1280x720p_60HZ:
7777   3                  case _VIDEO_1920x1080p_50HZ:
7778   3                  case _VIDEO_1920x1080p_60HZ:
7779   3      
7780   3                      if(CScalerGetBit(_SYNC_SELECT_47, _BIT4) == 0)
7781   3                      {
7782   4                          return _FALSE;
7783   4                      }
7784   3      
7785   3                      return _TRUE;
7786   3                      break;
7787   3      
7788   3                  default:
7789   3                      break;
7790   3              }
7791   2      
7792   2              return _FALSE;
7793   2          }
7794   1      #endif
7795   1      
7796   1      #if(((_OVERSCAN_HDMI_SUPPORT == _ON) || (_OVERSCAN_DP_SUPPORT == _ON) || (_OVERSCAN_DVI_SUPPORT == _ON)) &
             -& (_TMDS_SUPPORT == _ON))
7797   1      
7798   1          switch(GET_INPUTSOURCE_TYPE())
7799   1          {
7800   2      #if(_OVERSCAN_DVI_SUPPORT == _ON)
7801   2              case _SOURCE_DVI:
7802   2      #endif
7803   2      
7804   2      #if((_HDMI_SUPPORT == _ON) && (_OVERSCAN_HDMI_SUPPORT == _ON))
                      case _SOURCE_HDMI:
              #endif
7807   2      
7808   2      #if((_DP_SUPPORT == _ON) && (_OVERSCAN_DP_SUPPORT == _ON))
                      case _SOURCE_DP:
              #endif
7811   2                  if(GET_INTERLACE_MODE() == _TRUE)
7812   2                  {
7813   3                      return _TRUE;
7814   3                  }
7815   2      
7816   2      #if(_OVERSCAN_DVI_SUPPORT == _ON)
7817   2                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
7818   2                  {
7819   3                      return _FALSE;
7820   3                  }
7821   2      #endif
7822   2      
7823   2      #if(((_HDMI_SUPPORT == _ON) && (_OVERSCAN_HDMI_SUPPORT == _ON)) || ((_DP_SUPPORT == _ON) && (_OVERSCAN_DP_
             -SUPPORT == _ON)))
                          ucMode = 0;
              
                          while(tOverscanDigitalEnTable[ucMode][0] != 0)
                          {
                              if((abs(g_usOldIHWidth - tOverscanDigitalEnTable[ucMode][0]) <= 2) &&
                                 (g_usOldIVHeight == tOverscanDigitalEnTable[ucMode][1]) &&
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 130 

                                 (abs(stModeInfo.IVFreq - tOverscanDigitalEnTable[ucMode][2]) <= _VFREQ_TOLERANCE))
                              {
                                  break;
                              }
              
                              ucMode++;
                          }
              
                          if(tOverscanDigitalEnTable[ucMode][0] == 0)
                          {
                              return _FALSE;
                          }
              #endif
7843   2      
7844   2      #if((_HDMI_SUPPORT == _ON) && (_OVERSCAN_HDMI_SUPPORT == _ON))
                          if(GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
                          {
                              CScalerPageSelect(_PAGE2);
                              CScalerSetBit(_P2_HDMI_APC_C8, ~_BIT0, _BIT0);
                              CScalerGetDataPortByte(_P2_HDMI_ADDR_PORT_C9, _P2_HDMI_ACRCR_51, 1, pData, _NON_AUTOINC);
              
                              if(((pData[0] & (_BIT5 | _BIT4)) == _BIT4) || ((pData[0] & (_BIT5 | _BIT4)) == _BIT5)) // 
             -YUV Format
                              {
                                  return _TRUE;
                              }
                              else
                              {
                                  return _FALSE;
                              }
                          }
                          else
              #endif
7862   2      
7863   2      #if((_DP_SUPPORT == _ON) && (_OVERSCAN_DP_SUPPORT == _ON))
                          if(GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
                          {
                              CScalerPageSelect(_PAGEC);
                              CScalerGetDataPortByte(_PC_DP_ACCESS_PORT_B3, 0x02, 1, pData, _NON_AUTOINC);
              
                              if(((pData[0] & (_BIT2 | _BIT1)) == _BIT1) || ((pData[0] & (_BIT2 | _BIT1)) == _BIT2)) // 
             -YUV Format
                              {
                                  return _TRUE;
                              }
                              else
                              {
                                  return _FALSE;
                              }
                          }
                          else
              #endif
7880   2                  {
7881   3                      return _FALSE;
7882   3                  }
7883   2      
7884   2                  return _FALSE;
7885   2                  break;
7886   2      
7887   2              default:
7888   2                  break;
7889   2          }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 131 

7890   1      #endif
7891   1      
7892   1          return _FALSE;
7893   1      // V016 System Patch Note (25) Modify 20100831 End
7894   1      }
7895          
7896          //--------------------------------------------------
7897          // Description  : Set Capture Start for Overscan
7898          // Input Value  : None
7899          // Output Value : None
7900          //--------------------------------------------------
7901          void CModeOverScanSetCaptureStart(void)
7902          {
7903   1          if(GET_OVERSCAN_SUCCESS_STATUS() == _FALSE)
7904   1          {
7905   2              return;
7906   2          }
7907   1      
7908   1          CAdjustDisableWatchDog(_WD_ALL);
7909   1      
7910   1      #if(_YPBPR_SUPPORT == _ON)
7911   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
7912   1      #else
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VGA)
              #endif
7915   1          {
7916   2      #if(_SCALER_TYPE == _RTD2472D)
7917   2      
7918   2              // Set H/V Capture Start
7919   2              CScalerSetBit(_IPH_ACT_STA_H_14, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(g_usCaptureStartH + g_ucOverScan
             -H) & (_BIT2 | _BIT1 | _BIT0));
7920   2              CScalerSetByte(_IPH_ACT_STA_L_15, LOBYTE(g_usCaptureStartH + g_ucOverScanH));
7921   2              CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT2 | _BIT1 | _BIT0), HIBYTE(g_usCaptureStartV + g_ucOverScan
             -V) & (_BIT2 | _BIT1 | _BIT0));
7922   2      
7923   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
              
                      // Set H/V Capture Start
                      CScalerSetBit(_IPH_ACT_STA_H_14, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), HIBYTE(g_usCaptureStartH + g_uc
             -OverScanH) & (_BIT3 | _BIT2 | _BIT1 | _BIT0));
                      CScalerSetByte(_IPH_ACT_STA_L_15, LOBYTE(g_usCaptureStartH + g_ucOverScanH));
                      CScalerSetBit(_IPV_ACT_STA_H_18, ~(_BIT3 | _BIT2 | _BIT1 | _BIT0), HIBYTE(g_usCaptureStartV + g_uc
             -OverScanV) & (_BIT3 | _BIT2 | _BIT1 | _BIT0));
              
              #endif
7931   2      
7932   2              CScalerSetByte(_IPV_ACT_STA_L_19, LOBYTE(g_usCaptureStartV + g_ucOverScanV));
7933   2              CScalerSetByte(_IVS2DVS_DELAY_LINES_40, (g_ucIv2DvModify + g_ucOverScanV));
7934   2          }
7935   1      
7936   1      #if(_TMDS_SUPPORT == _ON)
7937   1      
7938   1          else if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
7939   1      #if(_HDMI_SUPPORT == _ON)
                  || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
              #endif
7942   1      
7943   1      #if(_DP_SUPPORT == _ON)
                  || (GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
              #endif
7946   1          )
7947   1          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 132 

7948   2              CScalerSetBit(_VGIP_CTRL_10, ~_BIT1, _BIT1);
7949   2      
7950   2      #if(_SCALER_TYPE == _RTD2472D)
7951   2              CScalerSetBit(_IPH_ACT_STA_H_14, 0xf8, 0x00);
7952   2              CScalerSetByte(_IPH_ACT_STA_L_15, g_ucOverScanH);
7953   2              CScalerSetByte(_IPV_ACT_STA_H_18, 0x00);
7954   2      
7955   2      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
                      CScalerSetBit(_IPH_ACT_STA_H_14, 0xf0, 0x00); // Input Video Horizontal Active Start[11:8]=4'b0000
                      CScalerSetByte(_IPH_ACT_STA_L_15, g_ucOverScanH);
                      CScalerSetBit(_IPV_ACT_STA_H_18, 0xf0, 0x00); // Input Video Vertical Active Start[11:8]=4'b0000
              
              #else
                      No Setting !!
              
              #endif // End of #if(_SCALER_TYPE == _RTD2472D)
7964   2      
7965   2              CScalerSetByte(_IPV_ACT_STA_L_19, g_ucOverScanV);
7966   2              CScalerSetByte(_IVS2DVS_DELAY_LINES_40, (g_ucIv2DvModify + g_ucOverScanV));
7967   2          }
7968   1      #endif
7969   1      
7970   1          CMiscApplyDoubleBuffer();
7971   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
7972   1          CTimerWaitForEvent(_EVENT_DEN_START);
7973   1      
7974   1          // Waiting for clearing the Status Register
7975   1          for(pData[15] = 0; pData[15] < 5; pData[15]++)
7976   1          {
7977   2              CMiscClearStatusRegister();
7978   2      
7979   2              CTimerWaitForEvent(_EVENT_DVS);                         // Wait for Frame End
7980   2              CTimerWaitForEvent(_EVENT_DVS);                         // Wait for Frame End
7981   2      
7982   2              CScalerRead(_STATUS0_02, 1, &pData[1], _NON_AUTOINC);
7983   2              CScalerRead(_STATUS1_03, 1, &pData[2], _NON_AUTOINC);
7984   2      
7985   2              if(((pData[1] & 0x03) == 0x00) && (pData[2] == 0x3F))
7986   2              {
7987   3                  break;
7988   3              }
7989   2          }
7990   1      
7991   1          if((pData[1] & 0x03) != 0x00)
7992   1          {
7993   2              CFrameSyncDo();
7994   2      
7995   2              CMiscClearStatusRegister();
7996   2              CTimerWaitForEvent(_EVENT_DVS);
7997   2              CTimerWaitForEvent(_EVENT_DVS);
7998   2          }
7999   1      
8000   1          CAdjustEnableWatchDog(_WD_ALL);
8001   1      }
8002          
8003          //--------------------------------------------------
8004          // Description  : Check Capture Window Setting
8005          // Input Value  : None
8006          // Output Value : return _TRUE means it should be do Overscan
8007          //--------------------------------------------------
8008          bit CModeOverScanCheckCaptureWindow(void)
8009          {
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 133 

8010   1      #if(_SCALER_TYPE == _RTD2472D)
8011   1      
8012   1          CScalerRead(_IPH_ACT_WID_H_16, 2, pData, _AUTOINC);
8013   1          ((WORD *)pData)[1] = (((WORD)(pData[0] & 0x07) << 8) | pData[1]);
8014   1      
8015   1          if(stModeInfo.IHWidth == ((WORD *)pData)[1])
8016   1          {
8017   2              return _FALSE;
8018   2          }
8019   1      
8020   1          CScalerRead(_IPV_ACT_LEN_H_1A, 2, pData, _AUTOINC);
8021   1          ((WORD *)pData)[1] = (((WORD)(pData[0] & 0x07) << 8) | pData[1]);
8022   1      
8023   1          if(stModeInfo.IVHeight == ((WORD *)pData)[1])
8024   1          {
8025   2              return _FALSE;
8026   2          }
8027   1      
8028   1      #elif((_SCALER_TYPE == _RTD2545LR) || (_SCALER_TYPE == _RTD247xRD) || (_SCALER_TYPE == _RTD248xRD))
              
                  CScalerRead(_IPH_ACT_STA_H_14, 1, pData, _AUTOINC);
                  CScalerRead(_IPH_ACT_WID_L_17, 1, &pData[1], _AUTOINC);
                  ((WORD *)pData)[1] = (((WORD)(pData[0] & 0xf0) << 4) | pData[1]);
              
                  if(stModeInfo.IHWidth == ((WORD *)pData)[1])
                  {
                      return _FALSE;
                  }
              
                  CScalerRead(_IPV_ACT_STA_H_18, 1, pData, _AUTOINC);
                  CScalerRead(_IPV_ACT_LEN_L_1B, 1, &pData[1], _AUTOINC);
                  ((WORD *)pData)[1] = (((WORD)(pData[0] & 0xf0) << 4) | pData[1]);
              
                  if(stModeInfo.IVHeight == ((WORD *)pData)[1])
                  {
                      return _FALSE;
                  }
              
              #endif
8049   1      
8050   1          return _TRUE;
8051   1      }
8052          
8053          //--------------------------------------------------
8054          // Description  : Overscan Setting
8055          // Input Value  : None
8056          // Output Value : None
8057          //--------------------------------------------------
8058          void CModeOverScan(void)
8059          {
8060   1          CModeOverScanSelect();
8061   1      
8062   1          if(GET_OVERSCAN_STATUS() == _FALSE)
8063   1          {
8064   2              return;
8065   2          }
8066   1      
8067   1          // V013 System Patch Note (12) Modify 20100412 Start
8068   1          // Patch Reason : Overscan function updates.
8069   1          LIGHTPOWER_DOWN();
8070   1          // V013 System Patch Note (12) Modify 20100412 End
8071   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 134 

8072   1          CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, _BIT5);
8073   1      
8074   1          CAdjustDisableWatchDog(_WD_ALL);
8075   1          CMiscDisableDoubleBuffer();
8076   1      
8077   1          CModeSetupDisplay();
8078   1          CModeOverscanFrameSyncFineTune();
8079   1          CModeOverScanAdjustPos();
8080   1      
8081   1          // V013 System Patch Note (12) Modify 20100412 Start
8082   1          // Patch Reason : Overscan function updates.
8083   1          /*
8084   1          CAdjustHPosition();
8085   1          CAdjustVPosition();
8086   1          */
8087   1          if((GET_INPUTSOURCE_TYPE() == _SOURCE_VGA) || (GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR))
8088   1          {
8089   2              CAdjustHPosition();
8090   2              CAdjustVPosition();
8091   2          }
8092   1          // V013 System Patch Note (12) Modify 20100412 End
8093   1      
8094   1          CMiscEnableDoubleBuffer();
8095   1          CAdjustEnableWatchDog(_WD_ALL);
8096   1      
8097   1      #if((_ASPECT_RATIO_SUPPORT == _ON) && (_MEMORY_WORK_TYPE == _OD_OFF_FRC_OFF))
8098   1          if(GET_READYFORDISPLAY() == _FALSE)
8099   1          {
8100   2              CModeSetDHWidthToDisplay();
8101   2              CTimerDelayXms(100);
8102   2          }
8103   1      #endif
8104   1      
8105   1          CScalerSetBit(_VDISP_CTRL_28, ~_BIT5, 0x00);
8106   1      
8107   1          // V013 System Patch Note (12) Modify 20100412 Start
8108   1          // Patch Reason : Overscan function updates.
8109   1          LIGHTPOWER_UP();
8110   1          // V013 System Patch Note (12) Modify 20100412 End
8111   1      }
8112          
8113          //--------------------------------------------------
8114          // Description  : CFrameSyncFineTune
8115          // Input Value  : None
8116          // Output Value : None
8117          //--------------------------------------------------
8118          void CModeOverscanFrameSyncFineTune(void)
8119          {
8120   1      #if(_YPBPR_SUPPORT == _ON)
8121   1          if(GET_INPUTSOURCE_TYPE() == _SOURCE_YPBPR)
8122   1          {
8123   2              switch(stModeInfo.ModeCurr)
8124   2              {
8125   3                  // V013 VGA Patch Note (5) 20100409 Modify Start
8126   3                  // Patch Reason : Modify YPbPr search mode flow to cover confuse mode problem.
8127   3                  /*
8128   3                  case _VIDEO_720x576i_50HZ:  //576i
8129   3                  case _VIDEO_720x480i_60HZ:  //480i
8130   3                  */
8131   3                  case _VIDEO_1440x576i_50HZ:
8132   3                  case _VIDEO_1440x480i_60HZ:
8133   3                  // V013 VGA Patch Note (5) 20100409 Modify End
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 135 

8134   3      
8135   3                  case _VIDEO_1920x1080i_50HZ: //1080i 50Hz
8136   3                  case _VIDEO_1920x1080i_60HZ: //1080i 60Hz
8137   3                      CScalerSetBit(_SCALE_CTRL_32, ~_BIT7, _BIT7);
8138   3                      CScalerSetBit(_VGIP_ODD_CTRL_13, ~_BIT0, _BIT0);
8139   3                      CFrameSyncFineTune(_ODD);
8140   3                      break;
8141   3              }
8142   2      
8143   2              return;
8144   2          }
8145   1      #endif
8146   1      
8147   1      #if(_VIDEO_SUPPORT == _ON)
                  if(GET_INPUTSOURCE_TYPE() == _SOURCE_VIDEO8)
                  {
                      CFrameSyncFineTune(_ODD);
                      return;
                  }
              #endif
8154   1      
8155   1      #if(_TMDS_SUPPORT == _ON)
8156   1              if((GET_INPUTSOURCE_TYPE() == _SOURCE_DVI)
8157   1      
8158   1      #if(_HDMI_SUPPORT == _ON)
                        || (GET_INPUTSOURCE_TYPE() == _SOURCE_HDMI)
              #endif
8161   1      
8162   1      #if(_DP_SUPPORT == _ON)
                        || (GET_INPUTSOURCE_TYPE() == _SOURCE_DP)
              #endif
8165   1              )
8166   1              {
8167   2                  if(GET_INTERLACE_MODE() == _TRUE)
8168   2                  {
8169   3                      CFrameSyncFineTune(_EVEN);
8170   3                  }
8171   2              }
8172   1      #endif
8173   1      }
8174          #endif  // End of #if(_OVERSCAN_SUPPORT == _ON)
8175          // V012 Modify 20100316 End
8176          
8177          // V012 Modify 20100321 Start
8178          // V012 Patch Note (14) : Fix the issue that SOG interlace signal could not light up the display when  V s
             -ync pulse is only 1H.
8179          //--------------------------------------------------
8180          // Description  : Check DVTotal Setting
8181          // Input Value  : None
8182          // Output Value : None
8183          //--------------------------------------------------
8184          void CModeCheckDVTotal(void)
8185          {
8186   1          WORD usDVTotal = 0;
8187   1          WORD usDVideal = 0;
8188   1      
8189   1          // Read DVTotal
8190   1          CScalerSetBit(_LAST_LINE_H_44, ~_BIT7, _BIT7);
8191   1          CScalerRead(_LAST_LINE_H_44, 2, pData, _AUTOINC);
8192   1          pData[0] &= 0x0F;
8193   1          usDVTotal = ((WORD *)pData)[0];
8194   1      
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 136 

8195   1          // V015 System Patch Note (5) Modify 20100629 Start
8196   1          // Patch Reason : Replace calculating DVTotal by reading DVTotal setting from register.
8197   1          // Read DVTotal Limit
8198   1          /*
8199   1          // Read DVTotal Limit
8200   1          ((WORD *)pData)[2] = ((DWORD)stModeInfo.IVTotal * stDisplayInfo.DVHeight) / stModeInfo.IVHeight + 64;
8201   1          */
8202   1          // Read DVTotal Limit
8203   1          CScalerSetByte(_DISP_ACCESS_PORT_2A, _DISP_DV_TOTAL_H_0B);
8204   1          CScalerRead(_DISP_DATA_PORT_2B, 2, &pData[4], _NON_AUTOINC);
8205   1          // V015 System Patch Note (5) Modify 20100629 End
8206   1      
8207   1          if(usDVTotal > ((WORD *)pData)[2])
8208   1          {
8209   2              // Ideal DVTotal
8210   2              usDVideal = ((WORD *)pData)[2] - 64;
8211   2      
8212   2              // Current DVTotal > (Ideal DVTotal * 2)
8213   2              if((((DWORD)usDVTotal * 1000) / usDVideal) > 1900)
8214   2              {
8215   3                  // Get Stable Period
8216   3                  CScalerRead(_STABLE_PERIOD_H_50, 2, pData, _AUTOINC);
8217   3                  pData[0] &= 0x07;
8218   3      
8219   3                  // Disable Hsync Type Detection Auto Run
8220   3                  CScalerSetBit(_SYNC_SELECT_47, ~(_BIT6 | _BIT5), 0x00);
8221   3      
8222   3                  // Set Vsync Counter Level = (Stable Period / 4)
8223   3                  CScalerSetBit(_VSYNC_COUNTER_LEVEL_MSB_4C, ~(_BIT2 | _BIT1 | _BIT0), (BYTE)(((WORD *)pData)[0]
             - >> 10) & 0x07);
8224   3                  CScalerSetByte(_VSYNC_COUNTER_LEVEL_LSB_4D, (BYTE)(((WORD *)pData)[0] >> 2));
8225   3      
8226   3                  // Enable Hsync Type Detection Auto Run
8227   3                  CScalerSetBit(_SYNC_SELECT_47, ~_BIT6, _BIT6);
8228   3      
8229   3                  // V012 Modify 20100329 Start
8230   3                  // V012 Patch Note (19) : Adjust polling time of Auto Run Typer according to different Crystal
             - frequency.
8231   3                  /*
8232   3                  // Wait for Auto Run Finish
8233   3                  CTimerPollingEventProc(180, CMiscHsyncTypeAutoRunFlagPollingEvent);
8234   3                  */
8235   3                  // Wait for Auto Run Finish
8236   3                  CTimerPollingFlagProc(_SP_AUTORUN_TIME_OUT, _PAGE_COMMON, _VSYNC_COUNTER_LEVEL_MSB_4C, _BIT7, 
             -_TRUE);
8237   3                  // V012 Modify 20100329 End
8238   3      
8239   3                  // Delay 2 frame for System Stable
8240   3                  CTimerWaitForEvent(_EVENT_IVS);
8241   3                  CTimerWaitForEvent(_EVENT_IVS);
8242   3                  CTimerWaitForEvent(_EVENT_IVS);
8243   3              }
8244   2          }
8245   1      
8246   1          CScalerSetBit(_LAST_LINE_H_44, ~_BIT7, 0x00);
8247   1      }
8248          // V012 Modify 20100321 End
8249          
8250          // V013 VGA Patch Note (23) Modify 20100513 Start
8251          // Patch Reason : For Video Mode Clamp Position Setting Flow
8252          //--------------------------------------------------
8253          // Description  : Check Current Mode Is Video Mode
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 137 

8254          // Input Value  : None
8255          // Output Value : Return _TRUE If Yes, _FALSE if No
8256          //--------------------------------------------------
8257          bit CModeCheckVideoMode(void)
8258          {
8259   1          // V014 VGA Patch Note (6) Modify 20100527 Start
8260   1          // Patch Reason : Modify Video Mode Can't Light On
8261   1          /*
8262   1          if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
8263   1          */
8264   1          if((GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE) && (GET_INPUTSOURCE_TYPE() == _SOURCE_VGA))
8265   1          // V014 VGA Patch Note (6) Modify 20100527 End
8266   1          {
8267   2              if(tINPUTMODE_PRESET_TABLE[stModeInfo.ModeCurr].PolarityFlag & (_VIDEO_MODE_GROUP1 | _VIDEO_MODE_G
             -ROUP2))
8268   2              {
8269   3                  return _TRUE;
8270   3              }
8271   2          }
8272   1      
8273   1          return _FALSE;
8274   1      }
8275          // V013 VGA Patch Note (23) Modify 20100513 End
8276          
8277          // V014 VGA Patch Note (6) Modify 20100527 Start
8278          // Patch Reason : Modify Video Mode Can't Light On
8279          //--------------------------------------------------
8280          // Description  : Recheck Clamp Position Setting
8281          // Input Value  : None
8282          // Output Value : None
8283          //--------------------------------------------------
8284          void CModeConfirmClampPositionSetting(void)
8285          {
8286   1          if(GET_MODE_SEARCH_TYPE() == _PRESET_MODE_TYPE)
8287   1          {
8288   2              switch(tINPUTMODE_PRESET_TABLE[stModeInfo.ModeCurr].PolarityFlag &  (_VIDEO_MODE_GROUP1 | _VIDEO_M
             -ODE_GROUP2))
8289   2              {
8290   3                  case _VIDEO_MODE_GROUP1:
8291   3                      pData[0] = 0x08;
8292   3                      pData[1] = 0x16;
8293   3                      pData[2] = 0x08;
8294   3                      pData[3] = 0x16;
8295   3      
8296   3                      break;
8297   3      
8298   3                  case _VIDEO_MODE_GROUP2:
8299   3                      pData[0] = 0x20;
8300   3                      pData[1] = 0x38;
8301   3                      pData[2] = 0x20;
8302   3                      pData[3] = 0x38;
8303   3      
8304   3                      break;
8305   3      
8306   3                  default:
8307   3                      pData[0] = 0x04;
8308   3                      pData[1] = 0x10;
8309   3                      pData[2] = 0x04;
8310   3                      pData[3] = 0x10;
8311   3      
8312   3                      break;
8313   3              }
C51 COMPILER V8.02   MODE                                                                  03/05/2012 13:24:16 PAGE 138 

8314   2      
8315   2          }
8316   1          else // User Mode Need Set Default Clamp Position.
8317   1          {
8318   2              pData[0] = 0x04;
8319   2              pData[1] = 0x10;
8320   2              pData[2] = 0x04;
8321   2              pData[3] = 0x10;
8322   2          }
8323   1      
8324   1          // Setting clamp position.
8325   1          CScalerSetByte(_SYNC_PROC_ACCESS_PORT_5C, 0x00);
8326   1          CScalerWrite(_SYNC_PROC_DATA_PORT_5D, 4, &pData[0], _NON_AUTOINC);
8327   1      }
8328          // V014 VGA Patch Note (6) Modify 20100527 End
8329          #endif  // End of #if(_SCALER_SERIES_TYPE == _RTD2472D_SERIES)
8330          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  17185    ----
   CONSTANT SIZE    =    316    ----
   XDATA SIZE       =     35    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      95
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
